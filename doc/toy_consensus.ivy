#lang ivy1.7

include collections

type node

isolate nset = {

    type this
    alias t = this
    type index

    relation member(N:node, S:t)
    relation majority(S:t)

    specification {
        invariant [majorities_intersect]
            (majority(S) & majority(T)) -> exists N. member(N,S) & member(N,T)
    }

    implementation {
	interpret index -> int
	function card(S:nset) : index
	instance arr : array(index,nset)
	destructor repr(N:nset) : arr
	individual all : arr
	
	axiom [all_ax] member(N,all)
	definition member(N,S) = exists i.0 <= i < array.len(s) & array.value(s, i, n)
	definition majority(S) = card(s) + card(s) > card(all)

	after init() {
	    card(S) := 0;
	    var i : index := 0;
	    while i < all.end
	        invariant (forall N.~(member(N,S) & member(N,T))) â†’
	                      card(S) + card(T) <= card(all)
	    {
		card(S) := card(S) + 1 if member(all.get(i), S) else card(S)
	    }
	}
    }
}

isolate toy_protocol = {

    relation voted(N:node,M:node)
    relation isleader(N:node)
    var quorum : nset

    after init {
        voted(N,M) := false;
        isleader(N) := false;
    }

    invariant [one_leader]
        isleader(N) & isleader(M) -> N = M

    invariant [one_vote_per_node] 
        voted(L, N ) & voted(L, M ) -> N = M

    invariant [leader_has_majority] 
        isleader(N) ->
            nset.majority(quorum) &
            forall M. nset.member(M , quorum) -> voted(M,N)

    action vote(v : node, n : node) = {
        require ~voted(v,N);
        voted(v, n) := true
    }

    action become_leader(n : node, s : nset) = {
        require nset.majority(s) & nset.member(N,s) -> voted(N, n);
        isleader(n) := true;
        quorum := s
    }
}
with nset

export toy_protocol.vote
export toy_protocol.become_leader
