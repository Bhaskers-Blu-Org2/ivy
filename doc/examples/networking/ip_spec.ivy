#lang ivy1.7

# This is an example of a wire specification for simplified version of
# IP. A wire specification describes the legal sequences of messages that
# can be observed in the execution of a protocol. Put another way, it tells
# us which mesages are legal for a given party to send at a given moment in
# the protocol's execution.
#
# There are many possible ways to describe such a specification. Here,
# we model the configuration of the internet by a relation called `intf`
# that describes all of the interfaces connecting hosts to local networks
# and their configured IP addresses. The `intf` relation describes a table
# with columns giving the host, network and IP address of the interface.
#
# We model the protocol with events of two types. The `send` events
# correspond to a client of IP (say, UDP or TCP) sending a
# datagram. The `transmit` events correspond to a datagram (or
# fragment of a datagram) making a "hop" from one host to another
# over local network.
#
# Our specification consists of a pair of guarded commands that tell
# us which `send` and `transmit` events are legal given the history of
# events. To specify these conditions, we use some shared variables that
# record information about the sent datagrams.
#
# In this version of the IP spec, we have made two important choices.
# First, we have described the protocol at two levels. The high level
# `send` events correspond to communication between the transport layer above
# (say, UDP or TCP) and the IP layer. The `tranmit` events below correspond to
# "hops" over the ethernet (i.e., the link layer). The high level events
# deterimine correct transmission of data at the low level.
#
# Second, we have written the spec so that it requires the data of all
# hops to be "up to date", i.e., to match the data currently being
# sent by the source for the give datagram identifier. This means that
# we can always correctly assemble datagram fragments at the
# destination, but the assume/guarantee specification of routers is
# unimplementable (see IP.md). As a result, router tests will fail.


# First, we declare some useful datatypes by including `stream.ivy`.

include stream

#
# Now let's move on to describing IP. We put all of the declarations
# related specifically to IP in a scope called `ip`. Ivy calls this an
# "object" (similarly to Scala) but you can also think of it as a
# namespace.

object ip = {

    # For IP we need some specific datatypes to represent fields of
    # the IP headers. Addresses are 32-bit numbers, protocol
    # identifiers are 4-bit numbers, datagram identifiers are 16-bit
    # numbers and so on. Note that even though `protocol` and
    # `version` are both instance of `bit_vector(4)`, they are
    # distinct types and are not assignment compatible.
    
    instance addr : bit_vector(32)
    instance protocol : bit_vector(8)
    instance ident : bit_vector(16)
    instance version : bit_vector(4)
    instance ttl : bit_vector(8)
#    instance tos : bit_vector(8)   # used for congestion control 
    
    # Now we define a struct to represent the IP datagram. Note this
    # is not quite like in C, where the struct definition might
    # describe the actual layout of the datagram at the byte
    # level. Instead, this structure gives a more high-level
    # description of the datagram's content. We will worry later about
    # the byte-level representation later. In particular, our high-level
    # struct is missing some fields of the byte-level IP header, because
    # these fields depend on the byte-level structure of the header. For this reasom,
    # our high-level struct has no fields for the header length, the total length
    # of the datagram, and the checksum. These fields will be added by the
    # encoding function that translates the high-level representatio ho byte-level.

    object datagram = {
        type this = struct {
            version_field : version,
    #        tos_field : tos,
            ident_field : ident,
            false_flag : bool,
            may_fragment_flag : bool,
            more_flag : bool,
            offset_field : pos,
            ttl_field : ttl,
            protocol_field : protocol,
            source_addr_field : addr,
            destination_addr_field : addr,
            payload : stream
        }

        action valid(d:datagram) returns (ok : bool) = {
            ok := (d.version_field = 4) & ~d.false_flag & d.offset_field < 0x2000;
        }
    }

    # An internetwork consists of a collection of networks and
    # hosts. A host that is connected to more than one network is a
    # router. For the moment, we don't want to think about what the actual
    # hosts and networks are in our internetwork. Instead we will declare
    # *uninterpreted types* to act as identifiers for hosts and networks.
    # These types are a bit like forward class references in C++. 

    type network
    type host

    # Our internet and the IP protocol have state. In Ivy, state
    # infomration is stored in relations, which you can think of as
    # database tables (there are also functions, which we will deal
    # with later).
    #
    # Each host in our internet is connected to some networks by a network
    # interface with a given IP address. We describe this configuration using
    # a relation `intf`. That is, `intf(H,N,A)` holds if host `H` is
    # connected to network `N` with an interface having address
    # `A`. Notice that this allows a host to have multiple interfaces
    # to the same network.
    #
    # We can think of the relation `intf` as a database table that describes
    # all of the interfaces in the internet and has columns for the host,
    # the IP address and the network. 
    #
    # This is how we declare the relation `intf`. Notice we give the
    # parameters of `intf` as typed variables. Variables in Ivy start
    # with capital letters (as in Prolog) and we will see more uses of
    # them later:
    
    relation intf(H:host,N:network,A:addr)

    # We do not allow interfaces with the same address connected to two
    # distinct hosts or networks. That is, the network configuration
    # must satisfy the following invariant:

    invariant intf(H1,N1,A) & intf(H2,N2,A) ->  H1 = H2 & N1 = N2

    # The invariant is a formula that must always be true about the
    # state.  Notice that the formula has some free variables in
    # it. This is interpreted to mean the formula must be true for
    # all possible values of the variables. Thus, the invariant states
    # that if we have any two interfaces with the same address `A`,
    # then they must also have the same host and network. The arrow
    # `->` in the formula stands for implication, or if/then.

    # This action represents the transfer of a packet from the client
    # (sya UDP or TCP) down to the network layer (IP). We assume the
    # packet is assigned an identifier at this point. 

    action send(h:host,d:datagram,n:network,id:ident)

    # The other action, `transmit`, corresponds to a datagram or
    # fragment of a datagram making a "hop" from one host to another
    # over a local network.  The parameters of the action are:
    #
    # - net: the local network
    # - sh : the sending host
    # - sip: the sending IP address 
    # - rip: the receiving IP address
    # - d: the datagram (possibly a fragment)
    # - len: the number of data bytes in the datagram
    #
    # The last parameter is redundant (since it is the same as the
    # length of payload stream) but we include it as a parameter to
    # make generation of `transmit` events easier, as we will see
    # below.
    
    action transmit(n:network,sh:host,sip:addr,rh:host,rip:addr,d:datagram,len:pos)

    # Notice that we have simply assumed here that the local network
    # has a way to send our datagram from `src` to `dst` without
    # considering how the IP datagram gets encapsulated in the
    # underlying local network protocol (say, Ethernet).
    
    # Now we need to provide a contract for this action, so that we know
    # which input values are legal at any given time. To write the
    # contract, we need to store some state information relating to
    # the protocol execution. 
    #
    # In particular, the specification state records which datagrams
    # have been sent. For this purpose, we identify a datagram by its
    # source, destination, protocol and identifier.  We again use a
    # relation to record this information:

    relation sent(S:addr,D:addr,P:protocol,I:ident)

    # In addition we use a function to record the payload data: This
    # is a map that takes the identifying information about a datagram
    # a yields the payload data. This lets us easily tell for any
    # datagram sent on the network whether its data is correct.

    function sent_data(S:addr,D:addr,P:protocol,I:ident) : stream

    # This relation needs to be initialized so that when the program
    # starts, no datagrams have been sent. We do this with an
    # *initializer*, which looks like this.

    after init {
        sent(S,D,P,I) := false
    }

    # Notice the use of Ivy variables in the assignment to `sent`.
    # This means that, for *all* values of host `H` and datagram `D`,
    # we set `sent(H,D)` to false (or if you want to think of `sent`
    # as a table, it means remove all of the rows from the table).
        
    # Now we give the guards and updates for each action. The `send`
    # action requires that the host actually have in interface on the
    # given network with the given source address.

    before send {
        require intf(h,n,d.source_addr_field); # host must control the source address
    }

    # The update for `send` records that the datagram ha been "sent" at the
    # sending host, and also the payload data. 

    after send {
        sent(d.source_addr_field,d.destination_addr_field,
             d.protocol_field, id) := true;
        sent_data(d.source_addr_field,d.destination_addr_field,
                  d.protocol_field, id) := d.payload;
    }

    # Now we get to the `transmit` event. There are several requriements:
    #
    # [1] The sending host must connect the the network via the sending IP address.
    #
    # [2] The receiving host must connect the the network via the recving IP address.
    #
    # These first two requirements say that the `transmit` event must corresponf to
    # a possible "hop" on the network. 
    # 
    # [3] A host may only transmit a datagram (or fragment of it)
    # if the datagram has bee sent. 
    #
    # [4] The version field must indicate IPv4.
    #
    # [5] The payload must equal the sub-sequence of bytes of the
    # datagram's original payload, starting at the offset * 8 and
    # having a length `len`.
    #
    # Here, we have used a trick to make generation of events
    # easier. That is, by making `len` a parameter, the SMT solver can
    # choose `len` and then the payload field of `d` can be filled in
    # by simply computing it according to equation [5]. This means the
    # SMT solver doesn't have to see the payload data, which makes it
    # significantly more efficient. This optimization is built into
    # Ivy, but sometimes we have to encode things in the right way to
    # enable the optimization.
    # 

    before transmit {
        require intf(sh,n,sip); # [1]
        require intf(rh,n,rip); # [2]
        require sent(d.source_addr_field,d.destination_addr_field,
                     d.protocol_field, d.ident_field); # [3]
        require d.version_field = 4; # [4]
        var begin := d.offset_field * 8;
        require d.payload =  # [5]
           sent_data(d.source_addr_field,d.destination_addr_field,
                     d.protocol_field, d.ident_field).segment(begin,begin+len);
    }

    # This specification is actually a little strange, since in principle
    # it allows a "clairvoyant" host to forward a datagram it hasn't actually
    # received, so long as the payload is correct. There's nothing really wrong
    # with this, but later, when we deal with the TTL field, we'll also have
    # to remember which TTL values a gateway has seen in order to determine the
    # allowable TTL values in the forwarded datagram.
    #
    # Also, notice that we haven't said that a host can't send two datagrams with
    # the same identifying information (i.e., protocol, src, dst and ident). The RFC
    # says that the host shouldn't recycle an identifier until all copies or fragments
    # of the old datagram have left the network, but there's no way to locally determine
    # this.

    # TODO: Must all packets with more flag must have multiple of 8 bytyes?
    # TODO: All packets without more flag must have correct length
    # 

    # Also, notice that we haven't said how routers actually choose to
    # forward packets. Obvious a real router will need a forwarding
    # table, but how to get the routing table is not part of the IP
    # specification. In effect, our specification lets routers forward
    # packets in any way they want. 


}    

