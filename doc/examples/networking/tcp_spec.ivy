#lang ivy1.7

# This file contains a wire specification of TCP, the Internet
# transmission control protocol. TCP provides port numbers and
# reliable, ordered connections between ports.
#
# THe TCP has interfaces at two levels: the app level and the protocol
# level. Events at the app level include listening on a prot, opening
# a connection, accepting a connection, sending/receiving data and
# closing a connection.  Events at the protocol level correspond to
# TCP sending and receiving IP datagrams.
#

include ip_spec

# This module defines an endpoint consisting of an address and a port
# number. The address and port types are parameters. The endpoint
# comes with a constructor called `make`.

module generic_endpoint(addr_type,port_type) = {
    type this = struct {
        port : port_type,
        addr : addr_type
    }
    action make(addr : addr_type, port : port_type) returns (res:this) = {
        res.addr := addr;
        res.port := port;
    }
}

# This object specifies the TCP protocol.

object tcp = {

    # TCP port numbers are 16-bit binary numbers.

    instance port : bit_vector(16)

    # TCP sequence numbers are 32-bit numbers.

    instance seq_num : bit_vector(32)

    # TCP window sizes are 16-bit numbers.

    instance wind_size : bit_vector(16)

    # Comparison operators on sequence numbers

    action mod_leq(x:seq_num,y:seq_num) returns(res:bool) = {
        res := (y - x) < 0x80000000;
    }

    action mod_lt(x:seq_num,y:seq_num) returns(res:bool) = {
        res := (y - x - 1) < 0x80000000;
    }

    # The TCP packet format has various fields describes in the RFC. Note
    # here that 
    # Note the the byte-level encoding of
    # the datagram has additional redundant fields (such as the checksum)that are derived
    # from these.

    object datagram = {
        type this = struct {
            src_port_field : port,
            dst_port_field : port,
            seq_num_field : seq_num,
            ack_num_field : seq_num,
            urg : bool,
            ack : bool,
            psh : bool,
            rst : bool,
            syn : bool,
            fin : bool,
            window_field : wind_size,
            urgent_pointer : wind_size,
            payload : stream
        }

        # Constructor for TCP datagrams

        action make(sp:port,dp:port,sn:seq_num,an:seq_num,urg:bool,ack:bool,psh:bool,
                    rst:bool,syn:bool,fin:bool,wind:wind_size,up:wind_size,pyld:stream)
        returns (dg:datagram) = {
            dg.src_port_field := sp;
            dg.dst_port_field := dp;
            dg.seq_num_field := sn;
            dg.ack_num_field := an;
            dg.urg := urg;
            dg.ack := ack;
            dg.psh := psh;
            dg.rst := rst;
            dg.syn := syn;
            dg.fin := fin;
            dg.window_field := wind;
            dg.urgent_pointer := up;
            dg.payload := pyld;
        }            

        # Constructor for empty TCP datagrams, having given src prt, dst port and
        # sequence number, with other fields zero or false and empty payload.

        action make_empty(sp:port,dp:port,sn:seq_num) returns (dg:datagram) = {
            dg := make(sp,dp,sn,0,false,false,false,false,false,false,0,0,stream.empty);
        }
    }

    # The state of an endpoint, according to RFC 793.

    type states = {
        closed,
        listening,
        syn_sent,
        syn_rcvd,
        established,
        fin_wait_1,
        fin_wait_2,
        closing,
        close_wait,
        time_wait,
        last_ack
    }

    # We define an endpoint type for TCP as an instance of the generic
    # endpoint module, where the address field is an IP address and the
    # port field is a TCP port.

    instance endpoint : generic_endpoint(ip.addr,port)

    # This object specifies the app level interface. It has actions
    # corresponding to the Posix API calls `listen`, `connect`, `close`,
    # `recv` (here `transmit`) and `send` (here `receive`). Note however, that
    # these actions specify connection endpoints and not sockets.
    #
    # Also, the `connect` action has two additional parameters: `sn`
    # is the initial sequence number of the connection and `wind` is
    # the initial receive window size.
    
    object app = {

        # API actions

        action listen(src:endpoint,dst:endpoint)
        action connect(src:endpoint,dst:endpoint,sn:seq_num,wind:wind_size)
        action close(src:endpoint,dst:endpoint)
        action transmit(src:endpoint,dst:endpoint,pyld:stream)
        action receive(src:endpoint,dst:endpoint,pyld:stream)


        specification {

            # State of the interface.
            #
            # `sent`: the bytes sent over the API thus far
            # `sent_end` : the numbner of bytes sent over the API thus far
            # `received` : the bytes received over the API thus far

            function sent(S:endpoint,D:endpoint) : stream
            function sent_end(S:endpoint,D:endpoint) : pos
            function received(S:endpoint,D:endpoint) : pos

            after init {
                sent_end(S,D) := 0;
            }

            # To listen, must be in closed.

            before listen {
                require ~protocol.enqueued(src,dst);
                require src.addr ~= 0 & dst.addr ~=0 & src.addr ~= 0xFFFFFFFF & dst.addr ~= 0xFFFFFFFF;
                require protocol.state(src,dst) = closed;
            }
            after listen {
                protocol.state(src,dst) := listening;
            }

            # To connect, must be in closed.

            before connect {
                require ~protocol.enqueued(src,dst);
                require protocol.state(src,dst) = closed;
            }

            # On connect, send active SYN, with given sequence number and window

            after connect {
                var dg := datagram.make_empty(src.port,dst.port,sn);
                dg.syn := true;
                dg.window_field := wind;
                call protocol.enqueue(src.addr,dst.addr,dg);
                protocol.state(src,dst) := syn_sent;
            }

            # TODO: We require that all sent data must be acked before
            # closing.  Is this correct?
            # TODO: This requires zero window for the FIN segment. OK?

            before close {
                require ~protocol.enqueued(src,dst);
                var st := protocol.state(src,dst);
                require st ~= closed & st ~= fin_wait_1;
                require st ~= fin_wait_2 & st ~= closing;
                require st ~= time_wait & st ~= last_ack;
                require protocol.send_wind_ack(src,dst) = protocol.send_wind_next(src,dst);
            }

            after close {
                var st := protocol.state(src,dst);
                if st ~= listening & st ~= syn_sent {
                    var dg := datagram.make_empty(src.port,dst.port,protocol.send_wind_next(src,dst));
                    dg.fin := true;
                    dg.ack := true;
                    dg.seq_num_field := protocol.send_wind_next(src,dst);
                    dg.ack_num_field := protocol.recv_wind_end(src,dst);
                    call protocol.enqueue(src.addr,dst.addr,dg);
                    protocol.send_wind_next(src,dst) := protocol.send_wind_next(src,dst) + 1;
                }
            }
                
            before transmit {
                require ~protocol.enqueued(src,dst);
#                var st := protocol.state(src,dst);
#                require st ~= closed;
            }
            after transmit {
                sent(src,dst) := sent(src,dst).extend(pyld);
                sent_end(src,dst) := sent(src,dst).end;  # for very technical reasons!
            }

            before receive {
                var rcvd := received(src,dst);
                require rcvd + pyld.end <= sent(src,dst).end;
                require pyld = sent(src,dst).segment(rcvd,rcvd + pyld.end);
            }
                

        }
    }

    # This object specifies the protocol level interface. It has one
    # action, representing transmission of an IP datagram by TCP.  The
    # specification says that all transmitted IP datagrams must have
    # correspond to previously sent TCP datagrams. 

    object protocol = {

        action receive(s:endpoint,d:endpoint,rdg:datagram,sn:seq_num,wind:wind_size,len:wind_size)
        action transmit(s:endpoint,d:endpoint,dg:datagram)

        # Internal actions

        action send(src:endpoint,dst:endpoint,wind:wind_size,len:wind_size)
        action retry(src:endpoint,dst:endpoint,begin:seq_num,wind:wind_size,len:wind_size)
        action timeout(src:endpoint,dst:endpoint)

        specification {

            # The state of the TCP specificion is defined by the
            # following variables.

            # A connection is defined by a source and destination
            # endpoint. Connections always come in pairs.
            
            # The beginning of the sending window for a connection
            function send_wind_begin(S:endpoint,D:endpoint) : seq_num

            # The highest acknowledged sequence number + 1
            function send_wind_ack(S:endpoint,D:endpoint) : seq_num

            # The position of the next byte to be sent
            function send_wind_next(S:endpoint,D:endpoint) : seq_num

            # The beginning of the receiving window for a connection (last byte + 1)
            function recv_wind_begin(S:endpoint,D:endpoint) : seq_num

            # The end of the receiving window for this connection (last octet + 1)
            function recv_wind_end(S:endpoint,D:endpoint) : seq_num

            # The current state of each TCP connection
            function state(S:endpoint,D:endpoint) : states

            # Segments queued for transmission via IP.

            relation enqueued(S:endpoint,D:endpoint)
            function next(S:endpoint,D:endpoint) : datagram
            
            # The last sequence position sent

            function sent_pos(S:endpoint,D:endpoint) : pos

            # Initially, all connections are in the CLOSED state, and nothing is queued.

            after init {
                state(S,D) := closed;
                enqueued(S,D) := false;
                sent_pos(S,D) := 0;
            }
            
            # This is the precondition for a TCP to send a segment. 
            
            before transmit {
                require enqueued(s,d);
                require dg = next(s,d);
            }

            after transmit {
                enqueued(s,d) := false;
            }
                
            action enqueue(src_addr:ip.addr,dst_addr:ip.addr,dg:datagram) = {
                var s := endpoint.make(src_addr,dg.src_port_field);
                var d := endpoint.make(dst_addr,dg.dst_port_field);
                call show_enqueue(s,d,dg);
                assert ~enqueued(s,d);  # Sanity check -- queue length is one
                enqueued(s,d) := true;
                next(s,d) := dg;
            }

            action send_rst(src:endpoint,dst:endpoint,sn:seq_num) = {
                var dg := datagram.make_empty(src.port,dst.port,sn);
                dg.rst := true;
                call protocol.enqueue(src.addr,dst.addr,dg);
            }                

            action send_ack(src:endpoint,dst:endpoint,pyld:stream) = {
                var dg := datagram.make_empty(src.port,dst.port,send_wind_next(src,dst));
                dg.ack := true;
                dg.ack_num_field := recv_wind_end(src,dst);
                dg.payload := pyld;
                call protocol.enqueue(src.addr,dst.addr,dg);
            }

            action handle_ack(src:endpoint,dst:endpoint,rdg:datagram) = {
                if rdg.ack {
                    if ~(mod_leq(rdg.ack_num_field,send_wind_next(src,dst)) &
                         mod_leq(send_wind_begin(src,dst),rdg.ack_num_field))
                    {
                        call send_rst(src,dst,send_wind_next(src,dst));
                    }
                    else {
                        if mod_leq(send_wind_ack(src,dst),rdg.ack_num_field) {
                            send_wind_ack(src,dst) := rdg.ack_num_field;
                        }
                    }
                }
            }

            after receive {
                var src := d;
                var dst := s;
                var dg := datagram.make_empty(src.port,dst.port,send_wind_next(src,dst));
                dg.window_field := wind;
                var st := state(src,dst);
                if st = closed {
                    call send_rst(src,dst,0);  # TODO: what sequence number in RST?
                } else if st = listening {
                    if ~rdg.rst {  # TODO: on RST stay listening?
                        if rdg.syn & ~rdg.ack {
                            state(src,dst) := syn_rcvd;
                            dg.syn := true;
                            dg.ack := true;
                            dg.ack_num_field := rdg.seq_num_field+1;
                            protocol.send_wind_begin(src,dst) := sn;
                            protocol.send_wind_next(src,dst) := sn + 1;
                            protocol.recv_wind_begin(src,dst) := rdg.seq_num_field;
                            protocol.recv_wind_end(src,dst) := rdg.seq_num_field+1;
                            call protocol.enqueue(src.addr,dst.addr,dg);
                        } else {
                            call send_rst(src,dst,send_wind_next(src,dst));  # TODO: what sequence number in RST?
                        }
                    }
                } else if st = syn_rcvd {
                    if rdg.rst {
                        state(src,dst) := listening;
                    } else {
                        # TODO: what if we get SYN?
                        if rdg.ack {
                            if rdg.ack_num_field ~= send_wind_next(src,dst) {
                                call send_rst(src,dst,send_wind_next(src,dst));
                            } else {
                                if rdg.payload.end > 0 {
                                    # The last ACK of the handshake might contain data
                                    if rdg.seq_num_field = recv_wind_end(src,dst) {
                                        call app.receive(src,dst,rdg.payload);
                                        recv_wind_end(src,dst) := rdg.seq_num_field + bfe[0][15](rdg.payload.end);
                                    }
                                };
                                state(src,dst) := established;
                            }
                        }
                    };
                } else if st = syn_sent {
                    if rdg.rst {
                        state(src,dst) := closed; # TODO: is this right?
                    } else {
                        if rdg.syn {
                            if rdg.ack {
                                if rdg.ack_num_field ~= send_wind_next(src,dst) {
                                    call send_rst(src,dst,send_wind_next(src,dst));
                                } else {
                                    state(src,dst) := established;
                                    dg.ack := true;
                                    dg.ack_num_field := rdg.seq_num_field+1;
                                    protocol.recv_wind_begin(src,dst) := rdg.seq_num_field;
                                    protocol.recv_wind_end(src,dst) := rdg.seq_num_field+1;
                                    var max_len : wind_size := bfe[0][15](app.sent(src,dst).end);
                                    len := max_len if len > max_len else len;
                                    dg.payload := app.sent(src,dst).segment(0,bfe[0][15](len));
                                    call protocol.enqueue(src.addr,dst.addr,dg);
                                }
                            } else {
                                state(src,dst) := syn_rcvd;
                                dg.syn := true;
                                dg.ack := true;
                                dg.ack_num_field := rdg.seq_num_field+1;
                                dg.seq_num_field := protocol.send_wind_begin(src,dst);
                                protocol.recv_wind_begin(src,dst) := rdg.seq_num_field;
                                protocol.recv_wind_end(src,dst) := rdg.seq_num_field+1;
                                call protocol.enqueue(src.addr,dst.addr,dg);
                            }
                        }
                    }
               
                } else if st = established {
                    if rdg.rst {
                        state(src,dst) := closed; # TODO: is this right?
                    } else {
                        call handle_ack(src,dst,rdg);
                        var end := rdg.seq_num_field + bfe[0][15](rdg.payload.end);
                        if rdg.payload.end > 0 {
                            if mod_leq(rdg.seq_num_field,recv_wind_end(src,dst)) &
                                mod_leq(recv_wind_end(src,dst),end)
                            {
                                recv_wind_end(src,dst) := end;
                            }
                        };
                        if rdg.fin {
                            state(src,dst) := close_wait;
                            recv_wind_end(src,dst) := end + 1;
                            call send_ack(src,dst,stream.empty);
                        }
                    }
                } else if st = fin_wait_1 {
                    if rdg.rst {
                        state(src,dst) := closed; # TODO: is this right?
                    } else {
                        call handle_ack(src,dst,rdg);
                        var end := rdg.seq_num_field + bfe[0][15](rdg.payload.end);
                        if ~mod_leq(end,recv_wind_end(src,dst)) {
                            call send_rst(src,dst,send_wind_next(src,dst));
                        } else {
                            if rdg.fin {
                                call send_ack(src,dst,stream.empty);
                                if mod_leq(send_wind_next(src,dst),send_wind_ack(src,dst)) {
                                    state(src,dst) := time_wait;
                                } else {
                                    state(src,dst) := fin_wait_2;
                                }
                            }
                        }
                    }
                } else if st = fin_wait_2 {
                    if rdg.rst {
                        state(src,dst) := closed; # TODO: is this right?
                    } else {
                        call handle_ack(src,dst,rdg);  # TODO: RFC doesn't mention ACK in this state. OK?
                        var end := rdg.seq_num_field + bfe[0][15](rdg.payload.end);
                        if ~mod_leq(end,recv_wind_end(src,dst)) {
                            call send_rst(src,dst,send_wind_next(src,dst));
                        } else {
                            if rdg.fin {
                                call send_ack(src,dst,stream.empty);
                                state(src,dst) := time_wait;
                            }
                        }
                    }
                } else if st = closing {
                    if rdg.rst {
                        state(src,dst) := closed; # TODO: is this right?
                    } else {
                        call handle_ack(src,dst,rdg);
                        var end := rdg.seq_num_field + bfe[0][15](rdg.payload.end);
                        if ~mod_leq(end,recv_wind_end(src,dst)) {
                            call send_rst(src,dst,send_wind_next(src,dst));
                        } else {
                            if rdg.fin {
                                # TODO: what???
                            };                                
                            if mod_leq(send_wind_next(src,dst),send_wind_ack(src,dst)) {
                                state(src,dst) := time_wait;
                            }
                        }
                    }
                } else if st = time_wait {
                    if rdg.rst {
                        state(src,dst) := closed; # TODO: is this right?
                    }
                    # TODO: in tme_wait ignore everything but RST?
                } else if st = close_wait {
                    if rdg.rst {
                        state(src,dst) := closed; # TODO: is this right?
                    }
                    # TODO: in close_wait ignore everything but RST?
                } else if st = last_ack {
                    if rdg.rst {
                        state(src,dst) := closed; # TODO: is this right?
                    } else {
                        call handle_ack(src,dst,rdg);
                        # TODO: what if we get data in this state?
                        if mod_leq(send_wind_next(src,dst), send_wind_ack(src,dst)) {
                            state(src,dst) := closed;
                        }
                    }
                }
            }

            before timeout {
                var st := state(src,dst);
                require st = time_wait;
            }

            after timeout {
                var st := state(src,dst);
                if st = time_wait {
                    state(src,dst) := closed;
                }
            }
            
            before send {
                require ~enqueued(src,dst);
                var st := state(src,dst);
                require st = established;
            }

            after send {
                var dg := datagram.make_empty(src.port,dst.port,send_wind_next(src,dst));
                dg.window_field := wind;
                dg.ack := true;
                dg.ack_num_field := recv_wind_end(src,dst);
                dg.seq_num_field := send_wind_next(src,dst);
                var max_len : wind_size := bfe[0][15](send_wind_next(src,dst) - dg.seq_num_field);
                len := max_len if len > max_len else len;
                var idx := sent_pos(src,dst);
                dg.payload := app.sent(src,dst).segment(idx,idx + bfe[0][15](len));
                call enqueue(src.addr,dst.addr,dg);
                send_wind_next(src,dst) := send_wind_next(src,dst) + bfe[0][15](len);
                sent_pos(src,dst) := sent_pos(src,dst) + bfe[0][15](len);
            }

            # To retry, must not be in closed or listening.  TODO: can
            # we retry ACK in FIN-WAIT-2, while waiting for FIN?

            before retry {
                require ~enqueued(src,dst);
                var st := state(src,dst);
                require st ~= closed & st ~= listening;
                require st ~= fin_wait_2 & st ~= time_wait;
                require mod_leq(begin,send_wind_next(src,dst));
                require mod_leq(send_wind_ack(src,dst),begin);
            }

            # A retry operations resends previous data, or SYN.

            after retry {
                var begin := send_wind_ack(src,dst);
                var dg := datagram.make_empty(src.port,dst.port,begin);
                dg.window_field := wind;
                var st := state(src,dst);
                if st = syn_rcvd {
                    # If in syn_rcvd, resend SYN/ACK
                    dg.syn := true;
                    dg.ack := true;
                    dg.seq_num_field := send_wind_next(src,dst);
                    dg.ack_num_field := recv_wind_end(src,dst);
                    send_wind_next(src,dst) := dg.seq_num_field + 1;
                } else if st = syn_sent {
                    # If in syn_sent, resend SYN
                    dg.syn := true;
                    dg.seq_num_field := send_wind_next(src,dst);
                    send_wind_next(src,dst) := dg.seq_num_field + 1;
                } else {
                    # If in synchronized, resend data
                    dg.ack := true;
                    dg.ack_num_field := recv_wind_end(src,dst);
                    var max_len : wind_size := bfe[0][15](send_wind_next(src,dst) - begin);
                    len := max_len if len > max_len else len;
                    var idx := sent_pos(src,dst) + bfe[0][15](max_len);
                    dg.payload := app.sent(src,dst).segment(idx,idx + bfe[0][15](len));
                    # If retrying in fin_wait1 or close_wait, set FIN
                    if st = fin_wait_1 | st = close_wait {
                        dg.fin := true;
                    }
                }; 
                call enqueue(src.addr,dst.addr,dg);
            }
        }
    }
}

attribute radix=16
import action show_enqueue(s:tcp.endpoint,d:tcp.endpoint,dg:tcp.datagram)
