#lang ivy1.7

# This is another verion of the IP spec that models datagram
# fragmentation.  Essentially, the specification says that all the
# forwarded and originated fragments must be consistent with past
# fragments. This allows fragments to be correctly forwardedm but the
# host role is not implementable, because datagram identifiers cannot
# be re-used for different data. Alternately, we could write a
# specification in which identifiers are re-used, but then reassembly
# becomes unimplementable. See the discussion in `IP.md`.
# 

# First, we declare some useful datatypes by including `stream.ivy`.

include stream

#
# So much for the generic. Now let's move on to describing IP. We put
# all of the declarations related specifically to IP in a scope called
# `ip`. Ivy calls this an "object" (similarly to Scala) but you can
# also think of it as a namespace.

object ip = {

    # For IP we need some specific datatypes to represent fields of
    # the IP headers. Addresses are 32-bit numbers, protocol
    # identifiers are 4-bit numbers, datagram identifiers are 16-bit
    # numbers and so on. Note that even though `protocol` and
    # `version` are both instance of `bit_vector(4)`, they are
    # distinct types and are not assignment compatible.
    
    instance addr : bit_vector(32)
    instance protocol : bit_vector(8)
    instance ident : bit_vector(16)
    instance version : bit_vector(4)
    instance ttl : bit_vector(8)
#    instance tos : bit_vector(8)   # used for congestion control 
    
    # Now we define a struct to represent the IP datagram. Note this
    # is not quite like in C, where the struct definition might
    # describe the actual layout of the datagram at the byte
    # level. Instead, this structure gives a more high-level
    # description of the datagram's content. We will worry later about
    # the byte-level representation later. In particular, our high-level
    # struct is missing some fields of the byte-level IP header, because
    # these fields depend on the byte-level structure of the header. For this reasom,
    # our high-level struct has no fields for the header length, the total length
    # of the datagram, and the checksum. These fields will be added by the
    # encoding function that translates the high-level representatio ho byte-level.

    object datagram = {
        type this = struct {
            version_field : version,
    #        tos_field : tos,
            ident_field : ident,
            false_flag : bool,
            may_fragment_flag : bool,
            more_flag : bool,
            offset_field : pos,
            ttl_field : ttl,
            protocol_field : protocol,
            source_addr_field : addr,
            destination_addr_field : addr,
            payload : stream
        }

        action valid(d:datagram) returns (ok : bool) = {
            ok := (d.version_field = 4) & ~d.false_flag & d.offset_field < 0x2000;
        }
    }

    # An internetwork consists of a collection of networks and
    # hosts. A host that is connected to more than one network is a
    # router. For the moment, we don't want to think about what the actual
    # hosts and networks are in our internetwork. Instead we will declare
    # *uninterpreted types* to act as identifiers for hosts and networks.
    # These types are a bit like forward class references in C++. 

    type network
    type host

    # Our internet and the IP protocol have state. In Ivy, state
    # infomration is stored in relations, which you can think of as
    # database tables (there are also functions, which we will deal
    # with later).
    #
    # Each host in out internet is connected to some networks by a network
    # interface with a given IP address. We describe this configuration using
    # a relation `intf`. That is, `intf(H,N,A)` holds if host `H` is
    # connected to network `N` with an interface having address
    # `A`. Notice that this allows a host to have multiple interfaces
    # to the same network.
    #
    # This is how we declare the relation `intf`. Notice we give the
    # parameters of `intf` as typed variables. Variables in Ivy start
    # with capital letters (as in Prolog) and we will see more uses of
    # them later:
    
    relation intf(H:host,N:network,A:addr)

    # We do not allow interfaces with the same address connected to two
    # distinct hosts or networks. That is, the network configuration
    # must satisfy the following invariant:

    invariant intf(H1,N1,A) & intf(H2,N2,A) ->  H1 = H2 & N1 = N2

    # The invariant is a formula that must always be true about the
    # state.  Notice that the formula has some free variables in
    # it. This is interpreted to mean the formula must be true for
    # all possible values of the variables. Thus, the invariant states
    # that if we have any two interfaces with the same address `A`,
    # then they must also have the same host and network. The arrow
    # `->` in the formula stands for implication, or if/then.

    # Ivy programs consist of actions, which we can think of as
    # procedures with contracts. In the IP protocol, there is just one
    # action, corresponding to the transmission of a datagram by a
    # host on a local network, via an interface. The idea is that each
    # time an actual transmission occurs, this procedure is
    # called. Here is the declaration of the action `transmit`:
    
    action transmit(h:host,src:addr,dst:addr,n:network,d:datagram)

    # The action has five parameters (these are the inputs of our
    # specification).  The parameters give the identify of the sender,
    # the sending and receiving interfaces, the network identifier and
    # the datagram being transmitted. Notice that we have simply assumed
    # here that the local network has a way to send our datagram from
    # `src` to `dst` without considering how the IP datagram gets
    # encapsulated in the underlying local network protocol.
    
    # Now we need to provide a contract for this action, so that we know
    # which input values are legal at any given time. To write the
    # contract, we need to store some state information relating to
    # the protocol execution. 
    #
    # In particular, the specification state records which datagrams
    # have been seen by which which hosts. A datagram is considered
    # seen by a host if it is transmitted on a network to which the
    # host is connected. We again use a relation to record this
    # information:

    relation byte_seen(S:addr,D:addr,P:protocol,I:ident,B:pos)
    function byte_value(S:addr,D:addr,P:protocol,I:ident,B:pos) : byte
    relation seen(H:host,D:datagram)

    # This relation needs to be initialized so that when the program
    # starts, no datagrams have been seen. We do this with an
    # *initializer*, which looks like this.

    after init {
        byte_seen(S,D,I,P,B) := false;
        seen(H,D) := false
    }

    # Notice the use of Ivy variables in the assignment to `seen`.
    # This means that, for *all* values of host `H` and datagram `D`,
    # we set `seen(H,D)` to false (or if you want to think of `seen`
    # as a table, it means remove all of the rows from the table).
        
    # Now we get to the requirements of the contract. There are two of
    # these. The first says that a host may not attempt to transmit a
    # datagram on an interface it does not possess (part of the nature
    # of formal specifications is that you often have to state the
    # obvious).
    #
    # The second contract requirement is that a datgram may only be
    # transmitted by the host if the host has seen the datagram, or if it is
    # the originator of the datagram (meaning that the sending interface is
    # the same as the source address of the datagram).

    # If the these requirements are met, our program updates the state
    # to reflect the transmission event. When a transmission occurs, we
    # update the `seen` relation to reflect the fact that all hosts
    # with interfaces on the network have now seen the datagram.

    # This contract is specified using a special statement call
    # `before`.  It provides some code that should be executed before
    # the action actually occurs. This is very similar to the notion of 'advice'
    # in an aspect-oriented programmin g language such as AspectJ.
    #
    # The `before` code in this case states the contract requirements
    # with a special form of code assertion called `require`. Here, we
    # give two conditions that are required to hold. If these
    # assertions pass, then we go on to update the `seen`
    # relation. Notice again the we use a variable to update many rows
    # of the table at once. The assignment says that for every host,
    # we should add a row indicating it has seen the datagram `d` if
    # the host has an interface on network `n` with the given
    # destination address `dst`. 

    # TODO: All packets with more flag must have multiple of 8 bytyes
    # TODO: All packets with not more flag must agree on total length
    # 

    before transmit {
        var  sem := datagram_semantics(d);
        require intf(h,n,src); # host must control the local source address
        require exists H. intf(H,n,dst); # destination interface must exist
        require intf(h,n,d.source_addr_field) | seen(h,sem);
        require ~d.more_flag -> d.offset_field = 0;
        require d.version_field = 4;
        var begin := d.offset_field * 8;
        require intf(h,n,d.source_addr_field) |
          (forall X. X < d.payload.end
          -> byte_seen(d.source_addr_field,d.destination_addr_field,
                       d.protocol_field,d.ident_field,X));
        require forall X. X < d.payload.end
          & byte_seen(d.source_addr_field,d.destination_addr_field,
                        d.protocol_field,d.ident_field,X+begin)
            -> byte_value(d.source_addr_field,d.destination_addr_field,
                        d.protocol_field,d.ident_field,X+begin) = d.payload.value(X);
    }

    after transmit {
        var  sem := datagram_semantics(d);
        seen(H,sem) := seen(H,sem) | intf(H,n,dst);
        var begin := d.offset_field * 8;
        var idx := d.payload.begin;
        while idx < d.payload.end {
            byte_seen(d.source_addr_field,d.destination_addr_field,
                        d.protocol_field,d.ident_field,idx+begin) := true;
            byte_value(d.source_addr_field,d.destination_addr_field,
                        d.protocol_field,d.ident_field,idx+begin) := d.payload.value(idx);
            idx := idx.next;
        }
    }
    
    # Note we haven't dealt with TTL yet. This specification really
    # says that you have to forward the *exact* packet you receive,
    # including the same TTL field. Obviously, this is wrong, but
    # we'll correct it later. Similarly, we haven't dealt with
    # fragmentation. Here we just want the simplest possible example
    # of a wire specification top see how specifications are written in
    # Ivy.

    # Also, notice that we haven't said how routers actually choose to
    # forward packets. Obvious a real router will need a forwarding
    # table, but how to get the routing table is not part of the IP
    # specification. In effect, our specification lets routers forward
    # packets in any way they want. 

    # This action clears the fields of the datagram that do not effect its
    # semantics, so that we can compare datagrams semantically. 

    action datagram_semantics(d:datagram) returns(d:datagram) = {
        d.ttl_field := 0;
        d.payload := stream.create(0,0);
    }
        

}    

