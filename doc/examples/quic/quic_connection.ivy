#lang ivy1.7

# ---
# layout: page
# title: QUIC connection protocol
# ---

# This document describes the wire specification of QUIC.  It is based
# on the following IETF drafts:
#
# 1.[QUIC: A UDP-Based Multiplexed and Secure Transport
# draft-ietf-quic-transport-09](https://tools.ietf.org/html/draft-ietf-quic-transport-09).
#
# 2. [Using Transport Layer Security (TLS) to Secure QUIC
# draft-ietf-quic-tls-09](https://tools.ietf.org/html/draft-ietf-quic-tls-09).
#
# The protocol is viewed as a sequence of *packet events*
# corresponding to transmission of a UDP packet from a QUIC source
# endpoint to a QUIC destination endpoint.

# References
# ==========

include quic_types
include quic_frame
include quic_packet
include tls_protocol
include quic_transport_parameters

# Connections
# ===========

# This section gives the wire specification of the QUIC protocol.  It
# tracks the state of connections resulting from a sequence of packet
# events.

# History variables
# -----------------

# These history variables are referenced in the specification of QUIC
# packet events.

# - For each endpoint E, and cid C, `conn_seen(C,E)` is true if C has
#   been sent by E.
#
# - For each endpoint E, and cid C, `conn_closed(C,E)` is true if C has
#   been closed by E.
#
# - The predicate `initializing(C,S)` holds if client endpoint C has sent an
#   Initial packet to server endpoint S, but the server has not replied.
#
# - The packet number of the initial packet from client endpoint C to
#   server endpoint S is represented by `initial_pkt_num(C,S)`.
#
# - The cid of the initial packet from client endpoint C to
#   server endpoint S is represented by `initial_pkt_cid(C,S)`.
#
# - For each endpoint E and cid C, last_pkt_num(E,C) represents the
#   number of the latest packet sent by E on C.
#
# - For each endpoint E and cid C, sent_pkt(E,C,N) is true if
#   a packet numbered N has been sent by E on C.
#
# - For each endpoint E and cid C, acked_pkt(E,C,N) is true if
#   a packet numbered N sent by E on connection C has been
#   acknowledged. 
#
# - For each endpoint E and cid C, max_acked(E,C) is the greatest
#   packet number N such that acked_pkt(E,C,N), or zero if
#   forall N. ~acked(E,C,N).
#
# - For each endpoint E and cid C, ack_credit(E,C) is the number
#   of non-ack-only packets sent to E on C, less the number of
#   ack-only packets sent from E on C.
#
# - For each endpoint E and cid C, `trans_params_set(E,C)`
#   is true if endpoint E has declared transport parameters for
#   connection E.
#
# - For each endpoint E, cid C,and stream id S, `stream_seen(E,C,S)`
#   indicates that a stream frame for stream id S on connection C
#   has been sent to destination endpoint E.
#
# - For each endpoint E, cid C,and stream id S, `stream_open(E,C,S)`
#   indicates that a stream frame for stream id *greater than or equal
#   to* S on connection C has been sent to destination endpoint E.
#
# - For each endpoint E, cid C,and stream id S, `max_stream_data_val(E,C,S)`
#   indicates the maximum number of bytes that may be sent on stream
#   id S on connection C to destination endpoint E.
#
# - For each endpoint E, cid C,and stream id S, `max_stream_data_set(E,C,S)`
#   indicates the maximum number of bytes that may be sent on stream
#   id S on connection C to destination endpoint E ha been set.
#
# - For each endpoint E, cid C,and stream id S, `stream_length(E,C,S)`
#   indicates the length of the stream data transmitted to endpoint E
#   on stread id S of cid C. The length is the least stream position greater
#   than the position of all bytes transmitted.
#
# - For each endpoint E, cid C,and stream id S, `stream_finished(E,C,S)`
#   indicates that the stream transmitted to endpoint E
#   with strean id S and cid C is finished (that is, a FIN frame has been sent). 
#
# - For each endpoint E, cid C,and stream id S, `stream_reset(E,C,S)`
#   indicates that the stream transmitted to endpoint E with stream id
#   S and cid C is reset (that is, a RESET_STREAM frame has been
#   sent).
#
# - For each destination endpoint E, cid C,and stream kind K, `max_stream_set(E,C,K)`
#   indicates that the maximum stream id is set.
#
# - For each destination endpoint E, cid C,and stream kind K, `max_stream(E,C,K)`
#   indicates the maximum stream id.


relation conn_seen(E:ip.endpoint,C:cid)
relation conn_closed(E:ip.endpoint,C:cid)
relation initializing(C:ip.endpoint,S:ip.endpoint)
function initial_pkt_num(C:ip.endpoint,S:ip.endpoint) : pkt_num
function initial_pkt_cid(C:ip.endpoint,S:ip.endpoint) : cid
function last_pkt_num(E:ip.endpoint,C:cid) : pkt_num
relation sent_pkt(E:ip.endpoint,C:cid,N:pkt_num)
relation acked_pkt(E:ip.endpoint,C:cid,N:pkt_num)
function max_acked(E:ip.endpoint,C:cid) : pkt_num
function ack_credit(E:ip.endpoint,C:cid) : pkt_num
relation trans_params_set(E:ip.endpoint,C:cid)
function trans_params(E:ip.endpoint,C:cid) : trans_params_struct
relation stream_seen(E:ip.endpoint,C:cid,S:stream_id)
relation stream_open(E:ip.endpoint,C:cid,S:stream_id)
function max_stream_data_val(E:ip.endpoint,C:cid,S:stream_id) : stream_pos
relation max_stream_data_set(E:ip.endpoint,C:cid,S:stream_id)
function stream_length(E:ip.endpoint,C:cid,S:stream_id) : stream_pos
relation stream_finished(E:ip.endpoint,C:cid,S:stream_id)
relation stream_reset(E:ip.endpoint,C:cid,S:stream_id)
relation max_stream_set(E:ip.endpoint,C:cid,K:stream_kind)
function max_stream(E:ip.endpoint,C:cid,K:stream_kind) : stream_id


# Initial state
# -------------

# The history variables are initialized as follows.  Initially, no
# connections have been seen and no packets have been sent or
# acknowledged.

after init {
    conn_seen(E,C) := false;
    conn_closed(E,C) := false;
    sent_pkt(E,C,N) := false;
    acked_pkt(E,C,N) := false;
    max_acked(E,C) := 0;
    ack_credit(E,C) := 0;
    trans_params_set(E:ip.endpoint,C:cid) := false;
    stream_seen(E,C,S) := false;
    stream_open(E,C,S) := false;
    max_stream_data_set(E,C,S) := false;
    stream_finished(E,C,S) := false;
    stream_reset(E,C,S) := false;
}

# Packet events
# -------------

# A packet event represents the transmision of a UDP packet `pkt` from
# QUIC source endpoint `src` to a QUIC destination endpoint `dst`.

# The packet *kind* depends on the field `hdr_type` according to
# the following table:
#
#   | hdr_type  | kind      |
#   |-----------|-----------|
#   | 0x7f      | Initial   |
#   | 0x7d      | Handshake |
#

# ### Requirements
#
# - An Initial packet represents an attempt by a client to establish a
#   connection. The cid is arbitary, but must not have been previously
#   seen. The initial packet must consist (apart from padding) of a
#   single stream frame for stream zero, containing the initial security
#   handshake information [1].
#
# - A Handshake packet is sent in response to an Initial packet or
#   a previous Handshake. In the latter case, the cid must match
#   the original cid.
#
# - TEMPORARY: We require that only one connection be initializing for
#   a given client endpoint at a given time [2]. This seems unreasonable,
#   but otherwise there is no way to match Handshake packets to Initial
#   packets, at least without looking at the security information.
#
# - A packet number may not be re-sent on a given connection. 
#
# - Initial packets may not be sent on a cid that has
#   been closed by the sender [6].
#
# ### Effects
#
# - The `conn_seen` and `sent_pkt` relations are updated to reflect
#   the observed packet [1].
# - The `last_pkt_num` functiona is updated to indicate the observed
#   packets as most recent for the packet's source and cid.
# - For Initial packets, `initializing` is set to true for the packet's
#   source and destination. The packet number is recorded in
#   `initial_pkt_num` and the cid in `initial_pkt_cid` [3]. 
# - For Handshake packets, `initializing` is set to false for the
#   source and destination of the Initial packet (the reverse of the
#   handshake packet). The initial packet is transfered to the cid
# - A sender may not re-use a packet number on a given cid [4].
# - A packet containing only ack frames and padding is *ack-only*.
#   For a given cid, the number of ack-only packets sent from src to dst
#   must not be greater than the number of non-ack-only packets sent
#   from dst to src [5].
#   
#
# ### Notes
#
# - The effective packet number is computed according to the procedure
#   `decode_packet_number` defined below.
#
# - It isn't clear whether a packet that is multiply-delivered packet
#   can be responded to by multple ack-only packets. Here, we assume it
#   cannot. That is, only a new distinct packet number allows an ack-only
#   packet to be sent in response.

before packet_event(src:ip.endpoint,dst:ip.endpoint,pkt:quic_packet) {
    
    # Extract the cid and packet number from the packet.

    var pcid := pkt.hdr_cid;
    var pnum := decode_packet_number(src,dst,pkt);

    require ~sent_pkt(src,pcid,pnum);  # [4]

    # Record that the connection has been seen from this source, and
    # the packet has been sent.

    conn_seen(src,pcid) := true;  # [1]
    sent_pkt(src,pcid,pnum) := true;  # [1]

    # Record the packet number as latest seen

    last_pkt_num(src,pcid) := pnum;

    # An ack-only packet must be in response to a non-ack-only packet

    var ack_only := forall (I:frame.idx) 0 <= I & I < pkt.payload.end ->
                                 (pkt.payload.value(I) isa frame.ack);
    if ack_only {
#	require ack_credit(src,pcid) > 0;  # [5]
	ack_credit(src,pcid) := ack_credit(src,pcid) - 1;
    } else {
	ack_credit(dst,pcid) := ack_credit(dst,pcid) + 1;
    };
    
    # An Initial packet has hdr_type 0x7f

    if pkt.hdr_type = 0x7f {
        require pkt.payload.end = 1;  # [1]
	require pkt.payload.value(0) isa frame.stream;
        require ~initializing(src,dst);  # [2]
        require ~conn_closed(src,pcid);  # [6]

        initializing(src,dst) := true;  # [3]
        initial_pkt_num(src,dst) := pnum;  # [3]
        initial_pkt_cid(src,dst) := pcid;  # [3]
    }

    # A Handshake packet has hdr_type 0x7d

    else if pkt.hdr_type = 0x7d {
   
        # The Handshake is matched to the cid `icid` of an Initial packet sent
        # by the destination. This connection is marked as no longer
        # initializing. The state of the Initial packet is transferred to the new cid.
        
        if initializing(dst,src) {
            initializing(dst,src) := false;
            var ipnum := initial_pkt_num(dst,src);
            sent_pkt(dst,pcid,ipnum) := true;
            last_pkt_num(dst,pcid) := ipnum;
            trans_params(dst,pcid) := trans_params(dst,initial_pkt_cid(dst,src));
	    ack_credit(src,pcid) := 1;  # one credit for initial packet
        }
    };

    # The frames are handled in order of occurrence in the packet. The frame
    # handlers are defined below.

    var idx : frame.idx := 0;
    while idx < pkt.payload.end {
        call pkt.payload.value(idx).handle(src,dst,pcid);
        idx := idx + 1
    }

}


# ### Frame handlers

# The `handle` action of a frame provides a monitor for the
# frame. This action takes as arguments the frame, the source and
# desitnation endpoints, and the cid of the connection. Each frame
# variant has an implementation of `handle` defined below.

object frame = {
   ...
   action handle(f:this,src:ip.endpoint,dst:ip.endpoint,pcid:cid) = {}
}

# #### Ack handler

# The set of packet numbers acknowledged by an Ack frame is determined
# by the `largest_ack` field and the `ack_blocks` field. Each Ack
# block acknowledges packet numbers in the inclusive range `[last - gap, last -
# gap - blocks]` where `gap` and `blocks` are the fields of the Ack
# block and `last` is `largest_ack` minus the sum of `gap + blocks`
# for all the previous ack blocks.
#
# The `gap` field for the first ack block is always zero and is not
# present in the low-level syntax.

# Requirements:
#
# - Every acknowledged packet must have been sent by the destination endpoint [1].

# Effects:
#
# - The acknowledged packets are recorded in the relation `acked_pkts(S,C,N)`
#   where `S` is the *source* of the acknowledged packet (not of the Ack) `C` is
#   the cid and `N` is the packet number [2].
# - The greatest acked packet is also tracked in `max_act(S,C)` [3]

object frame = {
    ...
    object ack = {
        ...
        action handle(f:frame.ack,src:ip.endpoint,dst:ip.endpoint,pcid:cid) = {
            var idx : frame.ack.block.idx := 0;
            var last := f.largest_acked;
            if max_acked(dst,pcid) < last {
                max_acked(dst,pcid) := last;  # [3]
            };
            while idx < f.ack_blocks.end {
                var ack_block := f.ack_blocks.value(idx);
                var upper := last - ack_block.gap;
                last := upper - ack_block.blocks;
                require (last <= N & N <= upper) -> sent_pkt(dst,pcid,N);  # [1]
                acked_pkt(dst,pcid,N) := (last <= N & N <= upper) | acked_pkt(dst,pcid,N);  # [2]
                idx := idx.next;
            }
        }
    }
}

# Stream frames carry stream data. Stream id 0 is special, in that it
# carries only TLS handshake data in the form of TLS records. 
#
# Requirements:
#
# - Stream frames with id 0 must consist of a sequence of well-formed
#   TLS records [1].
#
# - The upper bound of the stream frame may not exceed the current
#   value of `max_stream_data_val` for the given destination and cid, if
#   it has been set [2].
#
# - If the stream is finished, the the frame offset plus length must
#   not exceed the stream length [5].
#
# - Except on stream 0, the stream id must be less than or equal to
#   the max stream id for the kind of the stream [6].
#
# - Except on stream 0, the stream must not have been reset [7].
#
# - The connection must not have bee closed by the source endpoint [8].
#
# Effects:
#
# - If the stream has not been seen before, and if the
#   `initial_max_stream_data` transport parameter has been set, then
#   the `max_stream_data_val` value is set to the value of the
#   `initial_max_stream_data` transport parameter [3].
#
# - The QUIC-specific information in each TLS record in stream zero is
#    handled [4].
#
# - The length of the stream is updated. 
#
# - If the fin bit is set, the stream is marked as finished.
#
# Question: what is the value of `initial_max_stream_data` for stream
# zero? Here we assume there is no back-pressure on stream zero.

object frame = {
    ...
    object stream = {
        ...
        action handle(f:frame.stream,src:ip.endpoint,dst:ip.endpoint,pcid:cid) = {

            require ~conn_closed(src,pcid);  # [8]

            if f.id = 0 {
                var tr := tls.parser.deserialize(f.data);  # [1]
                var idx := tr.begin;
                while idx < tr.end {
                    var tls_rec := tr.value(idx);
                    call tls.event(src,dst,tls_rec);
                    call handle_tls_record(src,dst,pcid,tls_rec);  #[4]
                    idx := idx.next
                }
            }
            else {
                var kind := get_stream_kind(f.id);
                require max_stream_set(dst,pcid,kind) -> f.id <= max_stream(dst,pcid,kind);  # [6]
                require ~stream_reset(dst,pcid,f.id);  # [7]
                if ~stream_seen(dst,pcid,f.id) {
                    if initial_max_stream_data.is_set(trans_params(dst,pcid)) {
                        max_stream_data_val(dst,pcid,f.id) :=
                            initial_max_stream_data.value(trans_params(dst,pcid)).stream_pos_32;  # [3]
                        max_stream_data_set(dst,pcid,f.id) := true
                    };
                    if initial_max_stream_id_bidi.is_set(trans_params(dst,pcid)) {
                        max_stream(dst,pcid,bidir) :=
                            initial_max_stream_id_bidi.value(trans_params(dst,pcid)).stream_id_32;  # [3]
                        max_stream_set(dst,pcid,bidir) := true
                    };
                    if initial_max_stream_id_uni.is_set(trans_params(dst,pcid)) {
                        max_stream(dst,pcid,unidir) :=
                            initial_max_stream_id_uni.value(trans_params(dst,pcid)).stream_id_32;  # [3]
                        max_stream_set(dst,pcid,unidir) := true
                    };
                    stream_length(dst,pcid,f.id) := 0;
                };
                if max_stream_data_set(dst,pcid,f.id) {
                    require ((f.offset) + (f.length)) <= max_stream_data_val(dst,pcid,f.id)  # [2]
                };
                var length := f.offset + f.length;
                require stream_finished(dst,pcid,f.id) -> length <= stream_length(dst,pcid,f.id);  # [5]
                if stream_length(dst,pcid,f.id) < length {
                    stream_length(dst,pcid,f.id) := length
                };
                if f.fin {
                    stream_finished(dst,pcid,f.id) := true;
                };
                stream_seen(dst,pcid,f.id) := true;
                stream_open(dst,pcid,S) := true if S <= f.id else stream_open(dst,pcid,S);
            }
        }
    }
}

# Reset stream frames cause an identified stream to be abruptly terminated,
# meaning the no further transmissions (or retransmissions) will be sent for
# this stream and the receiver may ignore any data previously transmitted.
#
# Requirements:
#
# - Stream id must not exceed maximim stream id for the stream kind [4].
# - QUESTION: Can a previously reset stream be reset?
# - The final stream position may not be lesser than that of any previous
#   stream frame for the same stream id [1].
# - The connection must not have been closed by the source endpoint [5].
#
# Effects:
#
# - The specified stream id is marked as reset [2].
# - The stream length is set to the given final offset [3].
#

object frame = { ...
    object rst_stream = { ...
        action handle(f:frame.rst_stream,src:ip.endpoint,dst:ip.endpoint,pcid:cid) = {

            require ~conn_closed(src,pcid);  # [5]

            require stream_length(dst,pcid,f.id) <= f.final_offset;  # [1]
            var kind := get_stream_kind(f.id);
            require max_stream_set(dst,pcid,kind) -> f.id <= max_stream(dst,pcid,kind);  # [4]
            stream_reset(dst,pcid,f.id) := true;  # [2]
            stream_length(dst,pcid,f.id) := f.final_offset;  #[3]
        }
    }
}

# Max stream id frames cause the maximum stream id to be set. 
# The receiver of the max stream id may use stream ids up to and including
# the given maximum. Bit 1 of the stream id (the next-to-least significant)
# determines whether the limit is set for unidirectional or bidirectional
# streams. A max stream id containing a stream id lower than the current
# maximum is allowed and ignored.
#
# Requirements:
#
# - The connection must not have been closed by the source endpoint [2].
#
# Effects:
#
# - The maximum stream id is set [1].
#

object frame = { ...
    object max_stream_id = { ...
        action handle(f:frame.max_stream_id,src:ip.endpoint,dst:ip.endpoint,pcid:cid) = {

            require ~conn_closed(src,pcid);  # [2]

            var kind := get_stream_kind(f.id);
            if ~ (max_stream_set(dst,pcid,kind) & f.id < max_stream(dst,pcid,kind)) {
                max_stream_set(dst,pcid,kind) := true;
                max_stream(dst,pcid,kind) := f.id; #  [1]
            }
        }
    }
}

# Connection close frames indicate to the peer that the connection is being closed.
# It is unclear what this means operationally, but it seems reasonable to assume that the
# endpoint closing the connection will not send or receive any further data on the connection,
# so it is as if all the open streams are reset by this operation.
#
# A connection close frame can occur at any time. 
#
# Questions:
#
# - Are Ack frames still allowed after connection close?
# - Are retransmissions allowed after connection close?
# - When is a connection close allowed?
#
# Requirements:
#
# (None)
#
# Effects:
#
# - The connection state is set to closed for the source endpoint.
#

object frame = { ...
    object connection_close = { ...
        action handle(f:frame.connection_close,src:ip.endpoint,dst:ip.endpoint,pcid:cid) = {
            conn_closed(src,pcid) := true;
        }
    }
}

# Max stream data frames set the limit on data bytes that the source endpoint is willing
# to receive for a given stream.
#
# Requirements
#
# - The stream must be open for receiving at the source endpoint [1].
#
# Effects
# - If the given limit is greater than any previously set limit, then
#   the max stream data limit for the given stream is updated [2].
#

object frame = { ...
    object max_stream_data = { ...
        action handle(f:frame.max_stream_data,src:ip.endpoint,dst:ip.endpoint,pcid:cid) = {
            require stream_open(src,pcid,f.id);  # [1]
            if ~(max_stream_data_set(dst,pcid,f.id) & f.pos < max_stream_data_val(dst,pcid,f.id)) {
                max_stream_data_set(dst,pcid,f.id) := true;
                max_stream_data_val(dst,pcid,f.id) := f.pos;  # [2]
            }
        }
    }
}

# ### Packet number decoding

# The packet number is decoded from the packet header fields as follows.

# If the connection is new, the field `hdr_pkt_num` gives the
# exact first packet number. Otherwise, it represents only a number
# of low order bits. The high-order bits must be inferred from the
# last packet number seen for this connection.

# For short format packets. the number of low order bits present
# in `hdr_pkt_num` depends on the `hdr_type` field of the packet,
# according to this table:
#
#   | hdr_type | bits |
#   |----------|------|
#   | 0x1d     | 32   |
#   | 0x1e     | 16   | 
#   | 0x1f     |  8   |
#
# For long format packets, the number of bits is always 32.  The
# decoded packet number is the nearest number to the last packet number seen
# whose whose low-order bits agree with `hdr_pkt_num`. Note this is ambiguous
# in the case that `hdr_pkt_num - last_pkt_num = 2^(n-1) mod 2^n` where `n`
# is the number of bits, since `last_pkt_num + 2^(n-1)` and `last_pkt_num - 2^(n-1)`
# both equal `hdr_pkt_num` modulo `2^n` and are equidistant from `last_pkt_num`.
# This case is forbidden.
#
# Requirements
#
# - The sent packet number must be no greater than `la + max/2` where
#   `la` is the greatest acknowledged packet number (or zero if there
#   have been no acks) and `max` is a largest number that can be
#   represented with the number of bits provided [1].
#
# Notes:
#
# - The IETF draft uses this langauge: "The sender MUST use a packet
#   number size able to represent more than twice as large a range
#   than the difference between the largest acknowledged packet and
#   packet number being sent." The meaning of "more than twice as
#   large a range" isn't clear, but here we take it to mean that
#   `2 * (pnum - la) ` is representable. It is also not clear how the
#   maximum packet number is computed if no acks have been received,
#   but we assume here that `la` is zero in this case.
#
#   TODO: this seems inconsistent with the following statement: "The
#   initial value for packet number MUST be selected randomly from a
#   range between 0 and 2^32 - 1025 (inclusive)." Possibly there is no
#   upper limit on the packet number if no acks have been received
#   yet, but this seems questionable.

action decode_packet_number(src:ip.endpoint,dst:ip.endpoint,pkt:quic_packet) returns (pnum:pkt_num) = {

    var cid := pkt.hdr_cid;
    var la := max_acked(src,cid);
    pnum := pkt.hdr_pkt_num;


    if conn_seen(src,cid) {

        # This is a last number transmitted by the source on this connection.

        var last := last_pkt_num(src,cid);

        # If long format or type is 0x1d, we match 32 bits

        if pkt.hdr_long | pkt.hdr_type = 0x1d {
            var diff : pkt_num := bfe[0][31](pnum - last);
            pnum := last + diff;
            if diff >= 0x80000000 {
                pnum := pnum - 0x100000000
            };
            require pnum <= la + 0x7ffffffe;
        }

        # else if long format or type is 0x1e, we match 16 bits

        else if pkt.hdr_type = 0x1e {
            pnum := last + bfe[0][15](pnum - last);
            require pnum <= la + 0x7ffe;
        }

        # else (type is 0x1f) we match 8 bits

        else {
            pnum := last + bfe[0][7](pnum - last);
            require pnum <= la + 0x7e;
        }
    }
}

# TLS extensions are used in the client hello and server hello
# messages to carry the QUIC transport parameters, via special TLS
# extension type `quic_transport_parameters`. This type is define in
# the reference `quic_transport_parameters`. Here we define the
# protocol rules associated with `quic_transport_parameters`.
#
# The `handle_tls_extensions` rules apply to each `client_hello` or
# `server_hello` message, in order of occurrence in a handshake
# record. The last parameter, `is_client_hello`, is true for a `client_hello`
# message (see below).

action handle_tls_record(src:ip.endpoint,dst:ip.endpoint,pcid:cid,tls_rec:tls.record) = {

    if some(hr:tls.handshake_record) tls_rec *> hr {
        var idx := hr.fragment.begin;
        while idx < hr.fragment.end {
            var hs := hr.fragment.value(idx);
            if some(ch:tls.client_hello) hs *> ch {
                call handle_tls_extensions(src,dst,pcid,ch.extensions,true);
            };
            if some(sh:tls.server_hello) hs *> sh {
                call handle_tls_extensions(src,dst,pcid,sh.extensions,false);
            };
            idx := idx.next
        }
    }
}

# Requirements:
#
# 1. Transport parameters must be declared in the client hello
#    and server hello message [1] and may be declared only once [2].
#
# The rules in `handle_client_transport_parameters` apply to each
# `quic_transport_parameters` extension instance in order of
# occurrence.
#

action handle_tls_extensions
    (src:ip.endpoint,
     dst:ip.endpoint,
     pcid:cid,
     exts:vector[tls.extension],
     is_client_hello:bool) =
{

    # We process the extensions in a message in order.

    var idx := exts.begin;
    while idx < exts.end {
        var ext := exts.value(idx);
            
        # For every `quic_transport_parameters` extension...

        if some (tps:quic_transport_parameters) ext *> tps {
            call handle_client_transport_parameters(src,dst,pcid,tps,is_client_hello);
            require ~trans_params_set(src,pcid);  # [2]
            trans_params_set(src,pcid) := true;
            
        };
        idx := idx.next
    };
    # TEMPORARY: exempt server from sending transport parameters, since
    # minq doesn't implement this.
    if is_client_hello {
        require trans_params_set(src,pcid);
    }
}


# The rules in `handle_transport_parameter` apply to each
# `transport_parameter` instance a `quic_transport_parameters`
# extension, in order of occurrence.

# Requirements:
#
# - The endpoint must issue an `initial_max_stream_data` value [1].
# - The endpoint must issue an `initial_max_data` value [2].
# - The endpoint must issue an `idle_timeout` value [3].
# - A client must not issue an `stateless_reset_token` value [4].
#
# Note:
#
# - Setting a transport parameter requires that the parameter is not
#   previously set.

action handle_client_transport_parameters(src:ip.endpoint,dst:ip.endpoint,pcid:cid,
                                          tps:quic_transport_parameters,
                                          is_client_hello : bool) =
{
    call client_transport_parameters_event(src,dst,pcid,tps);
    var idx := tps.transport_parameters.begin;
    while idx < tps.transport_parameters.end {
        trans_params(src,pcid) := tps.transport_parameters.value(idx).set(trans_params(src,pcid));
        idx := idx.next
    };
    require initial_max_stream_data.is_set(trans_params(src,pcid));  # [1]
    require initial_max_data.is_set(trans_params(src,pcid));  # [2]
    require idle_timeout.is_set(trans_params(src,pcid));  # [3]
    if is_client_hello {
        require ~stateless_reset_token.is_set(trans_params(src,pcid));  # [4]
    }
}






action client_transport_parameters_event(src:ip.endpoint,dst:ip.endpoint,pcid:cid,
                                         tps:quic_transport_parameters)

import client_transport_parameters_event
