#lang ivy1.7

# ---
# layout: page
# title: QUIC connection protocol
# ---

# This document describes the wire specification of QUIC.  It is based
# on the following IETF drafts:
#
# 1.[QUIC: A UDP-Based Multiplexed and Secure Transport
# draft-ietf-quic-transport-09](https://tools.ietf.org/html/draft-ietf-quic-transport-09).
#
# 2. [Using Transport Layer Security (TLS) to Secure QUIC
# draft-ietf-quic-tls-09](https://tools.ietf.org/html/draft-ietf-quic-tls-09).
#
# The protocol is viewed as a sequence of *packet events*
# corresponding to transmission of a UDP packet from a QUIC source
# endpoint to a QUIC destination endpoint.

# References
# ==========

include quic_types
include quic_frame
include quic_packet
include tls_protocol
include quic_transport_parameters

# Connections
# ===========

# This section gives the wire specification of the QUIC protocol.  It
# tracks the state of connections resulting from a sequence of packet
# events, along with a some 'ghost' events that represent hidden
# processes inside the endpoints.
#
# Many of the relations below take both an endpoint and a cid as
# parameters. The cid in question is always the cid used by that
# endpoint, that is, the one that it sends as the source cid in
# the long packet format.

# History variables
# -----------------

# These history variables are referenced in the specification of QUIC
# packet events.

# - For each endpoint E, and cid C, `conn_seen(C,E)` is true if C has
#   been sent by E.
#
# - For each endpoint E, and cid C, `conn_closed(C,E)` is true if C has
#   been closed by E.
#
# - The predicate `initializing(C,S)` holds if client endpoint C has sent an
#   Initial packet to server endpoint S, but the server has not replied.
#   TODO: unneeded as of version 11. should be removed
#
# - The packet number of the initial packet from client endpoint C to
#   server endpoint S is represented by `initial_pkt_num(C,S)`.
#   TODO: unneeded as of version 11. should be removed
#
# - The cid of the initial packet from client endpoint C to
#   server endpoint S is represented by `initial_pkt_cid(C,S)`.
#   TODO: unneeded as of version 11. should be removed
#
# - For each endpoint E and cid C, last_pkt_num(E,C,L) represents the
#   number of the latest packet sent by E on C in encryption level L.
#
# - For each endpoint E and cid C, sent_pkt(E,C,L,N) is true if
#   a packet numbered N has been sent by E on C in encryption level L.
#
# - For each endpoint E and cid C, acked_pkt(E,C,L,N) is true if
#   a packet numbered N sent by E on connection C in encryption level L has been
#   acknowledged. 
#
# - For each endpoint E and cid C, max_acked(E,C,L) is the greatest
#   packet number N such that acked_pkt(E,C,L,N), or zero if
#   forall N. ~acked(E,C,L,N).
#
# - For each endpoint E and cid C, ack_credit(E,C) is the number
#   of non-ack-only packets sent to E on C, less the number of
#   ack-only packets sent from E on C.
#
# - For each endpoint E and cid C, `trans_params_set(E,C)`
#   is true if endpoint E has declared transport parameters for
#   connection E.
#
# - For each endpoint E, and destination cid C, `crypto_data(E,C,L)`
#   represents the crypto data transmitted by TLS to endpoint E for
#   cid C at encyption level L. This data may or may not have been
#   transmitted in any QUIC packet.
#
# - For each endpoint E and destination cid C, `crypto_length(E,C,L)`
#   indicates the length of the stream data transmitted in QUIC
#   packets to endpoint E for cid C at encyption level L. The length is the
#   least stream position greater than the position of all bytes
#   transmitted. Note this may be less than the length of the crypto
#   data, but may not be greater.
#
# - For each endpoint E and destination cid C, `crypto_pos(E,C,L)`
#   represents the read position of the crypto data transmitted by the application to endpoint E
#   for cid C at encyption level L. This is the number of bytes in the stream that have
#   been read by TLS at the destination.
#
# - For each endpoint E, cid C,and stream id S, `stream_seen(E,C,S)`
#   indicates that a stream frame for stream id S on connection C
#   has been sent to destination endpoint E.
#
# - For each endpoint E, cid C,and stream id S, `stream_open(E,C,S)`
#   indicates that a stream frame for stream id *greater than or equal
#   to* S on connection C has been sent to destination endpoint E.
#
# - For each endpoint E, cid C,and stream id S, `max_stream_data_val(E,C,S)`
#   indicates the maximum number of bytes that may be sent on stream
#   id S on connection C to destination endpoint E.
#
# - For each endpoint E, cid C,and stream id S, `max_stream_data_set(E,C,S)`
#   indicates the maximum number of bytes that may be sent on stream
#   id S on connection C to destination endpoint E ha been set.
#
# - For each endpoint E, cid C,and stream id S, `stream_length(E,C,S)`
#   indicates the length of the stream data transmitted in QUIC
#   packets to endpoint E on stread id S of cid C. The length is the
#   least stream position greater than the position of all bytes
#   transmitted. Note this may be less than the length of the application
#   data, but may not be greater.
#
# - For each endpoint E, cid C,and stream id S, `stream_app_data(E,C,S)`
#   represents the stream data transmitted by the application to endpoint E
#   on stread id S of cid C. This data may or may not have been transmitted in
#   any QUIC packet.
#
# - For each endpoint E, cid C,and stream id S, `stream_app_pos(E,C,S)`
#   represents the read position of the stream data transmitted by the application to endpoint E
#   on stread id S of cid C. This is th number of bytes in the stream that have
#   been read by the application.
#
# - For each endpoint E, cid C,and stream id S, `stream_finished(E,C,S)`
#   indicates that the stream transmitted to endpoint E
#   with strean id S and cid C is finished (that is, a FIN frame has been sent). 
#
# - For each endpoint E, cid C,and stream id S, `stream_reset(E,C,S)`
#   indicates that the stream transmitted to endpoint E with stream id
#   S and cid C is reset (that is, a RESET_STREAM frame has been
#   sent).
#
# - For each destination endpoint E, cid C,and stream kind K, `max_stream_set(E,C,K)`
#   indicates that the maximum stream id is set.
#
# - For each destination endpoint E, cid C,and stream kind K, `max_stream(E,C,K)`
#   indicates the maximum stream id.
#
# - The queued frames at source endpoint `E` for connection `C` are
#   represented by `queued_frames(E,C)` and are initially empty.
#
# - The relation `queued_hello(E,C)` indicates that one of the queued
#   frames at endpoint `E` for connection `C` contains a TLS hello record.
#
# - The function num_queued_frames(E:ip.endpoint,C:cid) gives the number of frames
#   queue at endpoint `E` for connection `C`.
#
# - The predicate `cid_dst_to_src_set` indicates that the cid `C` at
#   endpoint `D` has been mapped to a cid on the peer. This mapping
#   occurs conceptually when a server produces a server hello frame.
#
# - The function `cid_dst_to_src(D,C)` maps the cid `C` at endpoint `D` to the
#   corresponding cid of the per, if such a cid exists.

relation conn_seen(E:ip.endpoint,C:cid)
relation conn_closed(E:ip.endpoint,C:cid)
relation initializing(C:ip.endpoint,S:ip.endpoint)
function initial_pkt_num(C:ip.endpoint,S:ip.endpoint) : pkt_num
function initial_pkt_cid(C:ip.endpoint,S:ip.endpoint) : cid
function last_pkt_num(E:ip.endpoint,C:cid,L:encryption_level) : pkt_num
relation sent_pkt(E:ip.endpoint,C:cid,L:encryption_level,N:pkt_num)
relation acked_pkt(E:ip.endpoint,C:cid,L:encryption_level,N:pkt_num)
function max_acked(E:ip.endpoint,C:cid,L:encryption_level) : pkt_num
function ack_credit(E:ip.endpoint,C:cid) : pkt_num
relation trans_params_set(E:ip.endpoint,C:cid)
function trans_params(E:ip.endpoint,C:cid) : trans_params_struct
relation stream_seen(E:ip.endpoint,C:cid,S:stream_id)
relation stream_open(E:ip.endpoint,C:cid,S:stream_id)
function max_stream_data_val(E:ip.endpoint,C:cid,S:stream_id) : stream_pos
relation max_stream_data_set(E:ip.endpoint,C:cid,S:stream_id)
function conn_enc_level(E:ip.endpoint,C:cid) : encryption_level
function crypto_data(E:ip.endpoint,C:cid,L:encryption_level) : stream_data
function crypto_data_end(E:ip.endpoint,C:cid,L:encryption_level) : stream_pos
function crypto_pos(E:ip.endpoint,C:cid,L:encryption_level) : stream_pos
function crypto_length(E:ip.endpoint,C:cid,L:encryption_level) : stream_pos
function stream_app_data(E:ip.endpoint,C:cid,S:stream_id) : stream_data
function stream_app_data_end(E:ip.endpoint,C:cid,S:stream_id) : stream_pos
function stream_app_pos(E:ip.endpoint,C:cid,S:stream_id) : stream_pos
function stream_length(E:ip.endpoint,C:cid,S:stream_id) : stream_pos
relation stream_finished(E:ip.endpoint,C:cid,S:stream_id)
relation stream_reset(E:ip.endpoint,C:cid,S:stream_id)
relation max_stream_set(E:ip.endpoint,C:cid,K:stream_kind)
function max_stream(E:ip.endpoint,C:cid,K:stream_kind) : stream_id
function queued_frames(E:ip.endpoint,C:cid) : frame.arr
function queued_level(E:ip.endpoint,C:cid) : encryption_level
relation queued_hello(E:ip.endpoint,C:cid)
function num_queued_frames(E:ip.endpoint,C:cid) : frame.idx
relation cid_renamed(C:cid)
relation cid_new_name(C:cid)
function cid_orig_name(C:cid) : cid
relation cid_dst_to_src_set(D:ip.endpoint,C:cid)
function cid_dst_to_src(D:ip.endpoint,C:cid) : cid



# Initial state
# -------------

# The history variables are initialized as follows.  Initially, no
# connections have been seen and no packets have been sent or
# acknowledged.

after init {
    conn_seen(E,C) := false;
    conn_closed(E,C) := false;
    sent_pkt(E,C,L,N) := false;
    acked_pkt(E,C,L,N) := false;
    max_acked(E,C,L) := 0;
    ack_credit(E,C) := 0;
    trans_params_set(E:ip.endpoint,C:cid) := false;
    stream_seen(E,C,S) := false;
    stream_open(E,C,S) := false;
    stream_length(E,C,S) := 0;
    max_stream_data_set(E,C,S) := false;
    stream_finished(E,C,S) := false;
    stream_reset(E,C,S) := false;
    stream_app_pos(E,C,S) := 0;
    queued_hello(E,C) := false;
    cid_renamed(C) := false;
    cid_new_name(C) := false;
    conn_enc_level(E,C) := encryption_level.initial;
}

# Ghost events
# ------------
#
# A ghost event is an internal event of the system under test that may
# not be directly observable by the tester. These events may
# correspond to communication between an application and a protocol
# imlemenation, or an action within the application. In this case the
# ghost event typically represents in some way the semantics of a
# service being provided. Ghost evenst also sometimes correspond to
# non-deterministic events within the implementation of a service, for
# example the ordering of requests.
#
# During testing, inference of unobservable ghost events may be
# computationally intractable. In these cases, the system under test
# may need to be instrumented to record these events. In other cases,
# it may be feasible to infer the events from the observable
# communication. This is usually done by instrumenting the
# communication monitors with additional code the generates the ghost
# events. Incorrect inference of ghost events may result in a false
# alarm in testing.
#
#
# Open event
# ==========
#
# The first event in the life of a connection at a given is an `open_event`.
# At this point, the endpoint chooses its default transport parameters. Once
# the `open_event` has occurred, the security handshake can begin.
#
# Requirements:
#
# - The connection must not already be open at the endpoint
# - The transport parameters have not already been set
#

# before open_event(src:ip.endpoint, dst:ip.endpoint, pcid:cid, tp:trans_params_struct) {
#     require conn_open(src,pcid);
#     require ~trans_params_set(dst,pcid)
#     conn_open(src,pcid) := true;
#     trans_params_set(dst,pcid) := true;
#     trans_params(dst,pcid) := tp;
# }    

# Application send event
# ======================
#
# This event corresponds to transfer of application data to QUIC to
# be transmitted.
#
# Requirements
#
# - None
#
# Effects
#
# - The data bytes are appended to `stream_app_data(E,C,S)` where
#   `E` is the destination endpoint, `C` is the cid and
#   `S` is the stream id.
#

action app_send_event(src:ip.endpoint, dst:ip.endpoint, dcid:cid, s : stream_id, data : stream_data)

after app_send_event {
    var idx := data.begin;
    while idx < data.end {
	stream_app_data(dst,dcid,s) := stream_app_data(dst,dcid,s).append(data.value(idx));
        stream_app_data_end(dst,dcid,s) := stream_app_data(dst,dcid,s).end;
	idx := idx.next
    }
}

# Encryption level change

action set_encryption_level(src:ip.endpoint, scid:cid, e:encryption_level)

after set_encryption_level {
    conn_enc_level(src,scid) := e;
}

# TLS send event
# ==============
#
# This event corresponds to transmission of data between from a TLS
# endpoint to its peer on a given connection. In concept it occurs at
# the moment when the implmentation of TLS passes data to QUIC to be
# transmitted to the peer. This is a ghost event, since it is not
# visible on the wire. However, it can easily be inferred by examining
# the QUIC crypto frames.
#
# Requirements
#
# - The connection must be open [3].
# - The data must consist of a sequence of whole TLS records [1]
#
# Effects
#
# - The TLS data is appended to the crypto data [4].
#
# - The effect of each transmitted TLS record on the QUIC connection
#   state is defined by `handle_tls_record`, below [2]. A TLS
#   extension to client and server hello messages carries the
#   connection's initial transport parameters and is required.
#

before tls_send_event(src:ip.endpoint, dst:ip.endpoint, scid:cid, dcid:cid, data : stream_data) {
    # require conn_open(src,dcid);  # [3]
    var hs := tls.handshake_parser.deserialize(data);  # [1]
    var idx := hs.begin;
    while idx < hs.end {
        var h := hs.value(idx);
        call tls.handshake_event(src,dst,h);
        call handle_tls_handshake(src,dst,scid,dcid,h);  #[2]
        idx := idx.next
    };
    var jdx := data.begin;
    var e := conn_enc_level(src,scid);
    while jdx < data.end {
	crypto_data(src,scid,e) :=
	    crypto_data(src,scid,e).append(data.value(jdx));  # [4]
        crypto_data_end(src,scid,e) := crypto_data(src,scid,e).end;
	jdx := jdx.next
    }
}

#
# TLS receive event
# =================
#
# This event corresponds to transfer of data from QUIC to the TLS
# implementation. 

action tls_recv_event(src:ip.endpoint, dst:ip.endpoint, scid:cid, dcid:cid, e:encryption_level, lo: stream_pos, hi : stream_pos)
    
around tls_recv_event {

    require lo < hi & lo = crypto_pos(dst,dcid,e) & hi <= crypto_length(src,scid,e);
    #    require (data.end) + crypto_pos(dst,pcid,0) <= crypto_length(dst,pcid,0);
#    require 0 <= N & N < data.end -> data.value(N) = crypto_data(dst,pcid,0).value(N + crypto_pos(dst,pcid,0));
    ...
    
    crypto_pos(dst,dcid,e) := hi;
    #    crypto_pos(dst,pcid,0) := crypto_pos(dst,pcid,0) + data.end 
}


#
# Connection rename event
#
# On receipt of an initial packet, the server may give the connection a new cid. We
# record the fact that the old cid has been renamed. On future packet events, the
# header cid must be the new cid and is translated to the original.
#
# Requirements:
#
# - The connection must be initializing
#   
# Effects
#
# - The state of the old cid is transferred to the new cid
# - The connection is no longer initializing
#
# TODO: this event is unneeded as of version 11 and should be removed.
#

action rename_connection(src:ip.endpoint,dst:ip.endpoint,oldcid:cid,newcid:cid)

around rename_connection {
    require initializing(dst,src);
    require oldcid = initial_pkt_cid(dst,src)
    ...
    initializing(dst,src) := false;
    # var ipnum := initial_pkt_num(dst,src);
    # sent_pkt(dst,newcid,ipnum) := true;
    # last_pkt_num(dst,newcid) := ipnum;
    # trans_params(dst,newcid) := trans_params(dst,initial_pkt_cid(dst,src));
    # ack_credit(src,newcid) := 1;  # one credit for initial packet
    cid_renamed(oldcid) := true;
    cid_new_name(newcid) := true;
    cid_orig_name(newcid) := oldcid;
}

action orig_cid(pcid:cid) returns(pcid:cid) = {
    if cid_new_name(pcid) {
        pcid := cid_orig_name(pcid)
    }
}

# Packet events
# -------------

# A packet event represents the transmision of a UDP packet `pkt` from
# QUIC source endpoint `src` to a QUIC destination endpoint `dst`
# containing a sequence of queued frames.

# The packet *kind* depends on the field `hdr_type` according to
# the following table:
#
#   | hdr_type  | kind      |
#   |-----------|-----------|
#   | 0x7f      | Initial   |
#   | 0x7d      | Handshake |
#

# ### Requirements
#
# - The packet payload may not be empty [7].
#
# - The header type must be one of the above [8].
#
# - An Initial packet represents an attempt by a client to establish a
#   connection. The scid is arbitrary, but must not have been previously
#   seen. The dcid is unspecified. The initial packet must consist (apart from padding) of a
#   single crypto, containing the initial security
#   handshake information [1].
#
# - A Handshake packet is sent in response to an Initial packet or
#   a previous Handshake. In the latter case, the dcid must match
#   the scid provided by the peer.
#
# - Initial packets may not be sent on a cid that has
#   been closed by the sender [6].
#
# - Once a cid has been renamed by the server, it may no longer be used in a packet header.
#   Instead the new cid must be used. [9]
#
# - A sender may not re-use a packet number on a given scid [4].
#
# - A packet containing only ack frames and padding is *ack-only*.
#   For a given cid, the number of ack-only packets sent from src to dst
#   must not be greater than the number of non-ack-only packets sent
#   from dst to src [5].

# ### Effects
#
# - The `conn_seen` and `sent_pkt` relations are updated to reflect
#   the observed packet [1].
# - The `last_pkt_num` function is updated to indicate the observed
#   packets as most recent for the packet's source and cid.
#   
#
# ### Notes
#
# - The effective packet number is computed according to the procedure
#   `decode_packet_number` defined below.
#
# - It isn't clear whether a packet that is multiply-delivered packet
#   can be responded to by multple ack-only packets. Here, we assume it
#   cannot. That is, only a new distinct packet number allows an ack-only
#   packet to be sent in response.

around packet_event(src:ip.endpoint,dst:ip.endpoint,pkt:quic_packet) {
    
    # TEMPORARY
    require ~pkt.hdr_long -> (pkt.dcid = 5 & pkt.scid = 0);
    require pkt.hdr_long -> (pkt.dcid > 0 & pkt.scid > 0);
    require pkt.hdr_token_length = pkt.hdr_token.end;
    require pkt.hdr_token_length ~= 0 -> (pkt.hdr_long & pkt.hdr_type = 0x7f);

    # Allowed header types

    require pkt.hdr_long -> (pkt.hdr_type = 0x7d | pkt.hdr_type = 0x7f);
    require ~pkt.hdr_long -> pkt.hdr_type = 0x30;
    
    # Extract the source and destination cid's and packet number from the packet.

    var dcid := pkt.dst_cid;
    var scid := pkt.hdr_cid;

    # On long headers, both cids are given. Record the correspondence.
    # If the scid has been mapped, make sure it maps to the dcid.

    if pkt.hdr_long {
        require cid_dst_to_src_set(src,scid) -> cid_dst_to_src(src,scid) = dcid
    }

    # On short headers, the scid is not given, so we use the recorded value

    # TODO: this is not reliable for testing, since a short header might
    # arrive before a corresping long header due to packet re-ordering. We
    # need to handle this case. This is a general problem with the test setup:
    # the specification applies to packets in the actual order of transmission,
    # while the tester may receive them out-of-order. One fix for this would be
    # to have the spec also allow re-ordering, but this might introduce some
    # significant complexity.

    else {
        require cid_dst_to_src_set(dst,dcid);
        scid := cid_dst_to_src(dst,dcid)
    };

    var e := queued_level(src,scid);

    # The header type depends on the encryption level

    require e = encryption_level.initial -> pkt.hdr_long & pkt.hdr_type = 0x7f;
    require e = encryption_level.handshake -> pkt.hdr_long & pkt.hdr_type = 0x7d;
    require e = encryption_level.other -> ~pkt.hdr_long;
    
    var pnum := decode_packet_number(src,dst,pkt);

    require ~sent_pkt(src,scid,e,pnum);  # [4]

    # The payload may not be empty

    require num_queued_frames(src,scid) > 0;  # [7]

    # A packet is an initial packet iff it contains a client hello.

    # TODO: what to say about this?
    # assert pkt.hdr_type = 0x7f <-> queued_hello(src,scid);

    # Record that the connection has been seen from this source, and
    # the packet has been sent.

    conn_seen(src,scid) := true;  # [1]
    sent_pkt(src,scid,e,pnum) := true;  # [1]

    # Record the packet number as latest seen

    last_pkt_num(src,scid,e) := pnum;

  
    # The payload must exactly match the queued frames.

    require pkt.payload = queued_frames(src,scid)

    # var idx : frame.idx := 0;
    # while idx < pkt.payload.end {
    #     call pkt.payload.value(idx).handle(src,dst,dcid);
    #     idx := idx + 1
    # }

    ...

    # TEMPORARY: The following are repeated because currently locals defined in
    # the "before" section cannot be accessed in the "after" section.

    var dcid := pkt.dst_cid;
    var scid := pkt.hdr_cid;
    if ~pkt.hdr_long {
        scid := cid_dst_to_src(dst,dcid)
    };

    if pkt.hdr_type = 0x7f {
        require forall (I:frame.idx) 0 <= I & I < pkt.payload.end ->
               ((pkt.payload.value(I) isa frame.ack) | (pkt.payload.value(I) isa frame.crypto));
        require ~conn_closed(src,scid);  # [6]
    };

    # An ack-only packet must be in response to a non-ack-only packet

    var ack_only := forall (I:frame.idx) 0 <= I & I < pkt.payload.end ->
                                 (pkt.payload.value(I) isa frame.ack);
    if ack_only {
#	require ack_credit(src,scid) > 0;  # [5]
	ack_credit(src,scid) := ack_credit(src,scid) - 1;
    } else {
	ack_credit(dst,dcid) := ack_credit(dst,dcid) + 1;
    };

    # The queued frames are deleted
    
    queued_frames(src, scid) := frame.arr.empty;
    queued_hello(src, scid) := false;
    num_queued_frames(src, scid) := 0;
}

# The frame protocol
# ==================
#
# The frame protocol is defined by a sequence of frame events.
# This protocol is layered on the packet protocol, such that
# each packet event contains a sub-sequence of the frame events.
#
# The frame events are subdivided into variants called frame types.
# For each frame type, we define a ghost event `handle` corresponding
# to the generation of a frame and its transfer to the packet protocol
# for transmission. Frame events effect the protocol state by
# enqueueing frames to be encapsulated into packets. The effect of
# this is that frame and packet events are interleaved, such that the
# frames in each packet occur immediately before the packet event in
# the same order in which they occur in the packet payload. TODO:
# While this ordering seems sensible from a semantic point of view,
# implementations might transmit frames out of order. Requiring ghost
# frame events to be in order might complicate a modular proof of the
# implementation.
#
# Each frame has an encryption level. The enryption level determines
# the keys used to protect to protect that packet payload. Only frames
# of the same encryption level may be encapsulated in the same packet
# (however, multiple packets may be concatenated in a single UDP
# datagram). This requirement is enforced by requiring that every
# frame queue contains only frames of the same encryption level. The
# frame handler for each type enforces this condition.

#
# This generic `handle` action for frames is specialized for each
# frame type.  Its arguments are the frame, the source and destination
# endpoints, the source and destination cids and the encryption level.

object frame = {
   ...
    action handle(f:this,src:ip.endpoint,dst:ip.endpoint,scid:cid,dcid:cid,e:encryption_level) = {
	require false; # this generic action should never be called
    }
}

# Frame events cause frames to be enqueued for transmission in a
# packet. This action enqueues a frame.
#
# Effects:
#
# - Appends frame to the frame queue for the given source endpoint and cid.
# - Updates auxiliary functions `num_queued_frames` and `queued_level`.
#
# Note: the auxilary functions contain redundant information that is useful for
# specifying packet events. By encoding history information in this way, we make
# it easier for constraint solvers to construct tests.

action enqueue_frame(src:ip.endpoint, scid:cid, f:frame, e:encryption_level) = {
    queued_frames(src,scid) := queued_frames(src,scid).append(f);
    num_queued_frames(src, scid) := queued_frames(src,scid).end;
    queued_level(src,scid) := e;
}

# #### Ack handler

# The set of packet numbers acknowledged by an Ack frame is determined
# by the `largest_ack` field and the `ack_blocks` field. Each Ack
# block acknowledges packet numbers in the inclusive range `[last - gap, last -
# gap - blocks]` where `gap` and `blocks` are the fields of the Ack
# block and `last` is `largest_ack` minus the sum of `gap + blocks`
# for all the previous ack blocks.
#
# The `gap` field for the first ack block is always zero and is not
# present in the low-level syntax.

# Requirements:
#
# - Every acknowledged packet must have been sent by the destination endpoint [1].

# Effects:
#
# - The acknowledged packets are recorded in the relation `acked_pkts(S,C,N)`
#   where `S` is the *source* of the acknowledged packet (not of the Ack) `C` is
#   the cid and `N` is the packet number [2].
# - The greatest acked packet is also tracked in `max_act(S,C)` [3]

# TEMPORARY: use this to enforce new acks in testing

var force_new_ack : bool

object frame = {
    ...
    object ack = {
        ...
        action handle(f:frame.ack,src:ip.endpoint,dst:ip.endpoint,scid:cid,dcid:cid,e:encryption_level)

	around handle {
            require num_queued_frames(src,scid) > 0 -> e = queued_level(src,scid);
            var idx : frame.ack.block.idx := 0;
            var last := f.largest_acked;
            if max_acked(dst,dcid,e) < last {
                max_acked(dst,dcid,e) := last;  # [3]
            };
            require f.ack_blocks.end > 0;
            var some_new_ack := false;
            while idx < f.ack_blocks.end {
                var ack_block := f.ack_blocks.value(idx);
                require idx > 0 -> ack_block.gap < last - 1;
                var upper := last - ((ack_block.gap+2) if idx > 0 else 0);
                require ack_block.blocks <= upper;
                last := upper - ack_block.blocks;
                require (last <= N & N <= upper) -> sent_pkt(dst,dcid,e,N);  # [1]
		var jdx := last;
		while jdx <= upper {
                    if ~acked_pkt(dst,dcid,e,jdx) {
                        some_new_ack := true;
                    };
		    acked_pkt(dst,dcid,e,jdx) := true;
		    jdx := jdx + 1
		};
#                acked_pkt(dst,dcid,N) := (last <= N & N <= upper) | acked_pkt(dst,dcid,N);  # [2]
                idx := idx.next;
            };
            require force_new_ack -> some_new_ack;
	    ...
            force_new_ack := false;
            call enqueue_frame(src,scid,f,e);
        }
    }
}

# Stream frames carry stream data. 
#
# Requirements:
#
# - The upper bound of the stream frame may not exceed the current
#   value of `max_stream_data_val` for the given destination and cid, if
#   it has been set [2].
#
# - If the stream is finished, the the frame offset plus length must
#   not exceed the stream length [5].
#
# - The stream id must be less than or equal to
#   the max stream id for the kind of the stream [6].
#
# - The stream must not have been reset [7].
#
# - The connection must not have been closed by the source endpoint [8].
#
# - The connection id must have been seen at the source [9]
#   and the connection between source and destination must not be initializing [10].

# Effects:
#
# - If the stream has not been seen before, and if the
#   `initial_max_stream_data` transport parameter has been set, then
#   the `max_stream_data_val` value is set to the value of the
#   `initial_max_stream_data` transport parameter [3].
#
# - The length of the stream is updated. 
#
# - If the fin bit is set, the stream is marked as finished.
#
# Question: what is the value of `initial_max_stream_data` for stream
# zero? Here we assume there is no back-pressure on stream zero.
#
# Question: is the FIN bit allowed on stream zero?

object frame = {
    ...
    object stream = {
        ...
        action handle(f:frame.stream,src:ip.endpoint,dst:ip.endpoint,scid:cid,dcid:cid,e:encryption_level)

	around handle {
            require e = encryption_level.other;
            require num_queued_frames(src,scid) > 0 -> e = queued_level(src,scid);
            require ~conn_closed(src,scid);  # [8]

            var offset := f.offset if f.off else stream_length(dst,dcid,f.id);
	    require ((offset) + (f.length)) <= stream_app_data_end(dst,dcid,f.id);
            call show_offset_length(offset,f.length);
	    require f.data = stream_app_data(dst,dcid,f.id).segment(offset,offset+f.length); 

            # var kind := get_stream_kind(f.id);
            # require max_stream_set(dst,dcid,kind) -> f.id <= max_stream(dst,dcid,kind);  # [6]
            # require ~stream_reset(dst,dcid,f.id);  # [7]
            # require conn_seen(src,scid);  # [9]
            # if ~stream_seen(dst,dcid,f.id) {
            #     if initial_max_stream_data.is_set(trans_params(dst,dcid)) {
            #         max_stream_data_val(dst,dcid,f.id) :=
            #             initial_max_stream_data.value(trans_params(dst,dcid)).stream_pos_32;  # [3]
            #         max_stream_data_set(dst,dcid,f.id) := true
            #     };
            #     if initial_max_stream_id_bidi.is_set(trans_params(dst,dcid)) {
            #         max_stream(dst,dcid,bidir) :=
            #             (initial_max_stream_id_bidi.value(trans_params(dst,dcid)).stream_id_16) * 4;  # [3]
            #         max_stream_set(dst,dcid,bidir) := true
            #     };
            #     if initial_max_stream_id_uni.is_set(trans_params(dst,dcid)) {
            #         max_stream(dst,dcid,unidir) :=
            #             (initial_max_stream_id_uni.value(trans_params(dst,dcid)).stream_id_16) * 4;  # [3]
            #         max_stream_set(dst,dcid,unidir) := true
            #     };
            #     stream_length(dst,dcid,f.id) := 0;
            # };
            # if max_stream_data_set(dst,dcid,f.id) {
            #     require ((offset) + (f.length)) <= max_stream_data_val(dst,dcid,f.id)  # [2]
            # };
            var length := offset + f.length;
            # require stream_finished(dst,dcid,f.id) -> length <= stream_length(dst,dcid,f.id);  # [5]
            if stream_length(dst,dcid,f.id) < length {
                stream_length(dst,dcid,f.id) := length
            };
            if f.fin {
                stream_finished(dst,dcid,f.id) := true;
            };
            stream_seen(dst,dcid,f.id) := true;
            stream_open(dst,dcid,S) := true if S <= f.id else stream_open(dst,dcid,S);
	    ...
            call enqueue_frame(src,scid,f,e);
        }
    }
}

# Crypto frames carry crypto handshake data, that is, TLS records.
#
# Requirements:
#
# - The connection must not have bee closed by the source endpoint [1].
#
# Effects:
#
# - The length of the crypto stream is updated. 

object frame = {
    ...
    object crypto = {
        ...
        action handle(f:frame.crypto,src:ip.endpoint,dst:ip.endpoint,scid:cid,dcid:cid,e:encryption_level)

	around handle {
            require num_queued_frames(src,scid) > 0 -> e = queued_level(src,scid);
            call show_enc_level(e);
            require ~conn_closed(src,scid);  # [1]

	    require ((f.offset) + (f.length)) <= crypto_data_end(src,scid,e);
	    require f.data = crypto_data(src,scid,e).segment(f.offset,f.offset+f.length); 

	    ...
            var length := f.offset + f.length;
            if crypto_length(src,scid,e) < length {
                crypto_length(src,scid,e) := length
            };

            call enqueue_frame(src,scid,f,e);
        }
    }
}

# Reset stream frames cause an identified stream to be abruptly terminated,
# meaning the no further transmissions (or retransmissions) will be sent for
# this stream and the receiver may ignore any data previously transmitted.
#
# Requirements:
#
# - Stream id must not exceed maximim stream id for the stream kind [4].
# - QUESTION: Can a previously reset stream be reset?
# - The final stream position may not be lesser than that of any previous
#   stream frame for the same stream id [1].
# - The connection must not have been closed by the source endpoint [5].
#
# Effects:
#
# - The specified stream id is marked as reset [2].
# - The stream length is set to the given final offset [3].
#
# Question: is rst_stream allowed on stream zero?

object frame = { ...
    object rst_stream = { ...
        action handle(f:frame.rst_stream,src:ip.endpoint,dst:ip.endpoint,scid:cid,dcid:cid,e:encryption_level)

	around handle {
            require ~conn_closed(src,scid);  # [5]

            require stream_length(dst,dcid,f.id) <= f.final_offset;  # [1]
            var kind := get_stream_kind(f.id);
            require max_stream_set(dst,dcid,kind) -> f.id <= max_stream(dst,dcid,kind);  # [4]
            stream_reset(dst,dcid,f.id) := true;  # [2]
            stream_length(dst,dcid,f.id) := f.final_offset;  #[3]
	    ...
            call enqueue_frame(src,scid,f,e);
        }
    }
}

# Max stream id frames cause the maximum stream id to be set. 
# The receiver of the max stream id may use stream ids up to and including
# the given maximum. Bit 1 of the stream id (the next-to-least significant)
# determines whether the limit is set for unidirectional or bidirectional
# streams. A max stream id containing a stream id lower than the current
# maximum is allowed and ignored.
#
# Requirements:
#
# - The connection must not have been closed by the source endpoint [2].
#
# Effects:
#
# - The maximum stream id is set [1].
#

object frame = { ...
    object max_stream_id = { ...
        action handle(f:frame.max_stream_id,src:ip.endpoint,dst:ip.endpoint,scid:cid,dcid:cid,e:encryption_level)

	around handle {
            require num_queued_frames(src,scid) > 0 -> e = queued_level(src,scid);
            require ~conn_closed(src,scid);  # [2]

            var kind := get_stream_kind(f.id);
            if ~ (max_stream_set(dst,dcid,kind) & f.id < max_stream(dst,dcid,kind)) {
                max_stream_set(dst,dcid,kind) := true;
                max_stream(dst,dcid,kind) := f.id; #  [1]
            }
	    ...
            call enqueue_frame(src,scid,f,e);
        }
    }
}

# Connection close frames indicate to the peer that the connection is being closed.
# It is unclear what this means operationally, but it seems reasonable to assume that the
# endpoint closing the connection will not send or receive any further data on the connection,
# so it is as if all the open streams are reset by this operation.
#
# A connection close frame can occur at any time. 
#
# Questions:
#
# - Are Ack frames still allowed after connection close?
# - Are retransmissions allowed after connection close?
# - When is a connection close allowed?
#
# Requirements:
#
# (None)
#
# Effects:
#
# - The connection state is set to closed for the source endpoint.
#

object frame = { ...
    object connection_close = { ...
        action handle(f:frame.connection_close,src:ip.endpoint,dst:ip.endpoint,scid:cid,dcid:cid,e:encryption_level)
	around handle{
            require num_queued_frames(src,scid) > 0 -> e = queued_level(src,scid);
            conn_closed(src,scid) := true;
	    ...
            call enqueue_frame(src,scid,f,e);
        }
    }
}

# Application close frames indicate to the peer that the connection is being closed.
# It is unclear what this means operationally, but it seems reasonable to assume that the
# endpoint closing the connection will not send or receive any further data on the connection,
# so it is as if all the open streams are reset by this operation.
#
# An application close frame can occur at any time. 
#
# Questions:
#
# - Are Ack frames still allowed after application close?
# - Are retransmissions allowed after application close?
# - When is a application close allowed?
#
# Requirements:
#
# (None)
#
# Effects:
#
# - The connection state is set to closed for the source endpoint.
#

object frame = { ...
    object application_close = { ...
        action handle(f:frame.application_close,src:ip.endpoint,dst:ip.endpoint,scid:cid,dcid:cid,e:encryption_level)
	around handle{
            require num_queued_frames(src,scid) > 0 -> e = queued_level(src,scid);
            conn_closed(src,scid) := true;
	    ...
            call enqueue_frame(src,scid,f,e);
        }
    }
}

# Max stream data frames set the limit on data bytes that the source endpoint is willing
# to receive for a given stream.
#
# Requirements
#
# - The stream must be open for receiving at the source endpoint [1].
#
# Effects
# - If the given limit is greater than any previously set limit, then
#   the max stream data limit for the given stream is updated [2].
#

object frame = { ...
    object max_stream_data = { ...
        action handle(f:frame.max_stream_data,src:ip.endpoint,dst:ip.endpoint,scid:cid,dcid:cid,e:encryption_level)
	around handle {
            require num_queued_frames(src,scid) > 0 -> e = queued_level(src,scid);
            require stream_open(src,scid,f.id);  # [1]
            if ~(max_stream_data_set(dst,dcid,f.id) & f.pos < max_stream_data_val(dst,dcid,f.id)) {
                max_stream_data_set(dst,dcid,f.id) := true;
                max_stream_data_val(dst,dcid,f.id) := f.pos;  # [2]
            }
	    ...
            call enqueue_frame(src,scid,f,e);
        }
    }
}

# Ping frames contain no data and have no semantics. They can
# be used to keep a connection alive.

object frame = { ...
    object ping = { ...
        action handle(f:frame.ping,src:ip.endpoint,dst:ip.endpoint,scid:cid,dcid:cid,e:encryption_level)
	after handle {
            call enqueue_frame(src,scid,f,e);
        }
    }
}


# ### Packet number decoding

# The packet number is decoded from the packet header fields as follows.

# If the connection is new, the field `hdr_pkt_num` gives the
# exact first packet number. Otherwise, it represents only a number
# of low order bits. The high-order bits must be inferred from the
# last packet number seen for this connection.

# For short format packets. the number of low order bits present
# in `hdr_pkt_num` depends on the `hdr_type` field of the packet,
# according to this table:
#
#   | hdr_type | bits |
#   |----------|------|
#   | 0x1d     | 32   |
#   | 0x1e     | 16   | 
#   | 0x1f     |  8   |
#
# For long format packets, the number of bits is always 32.  The
# decoded packet number is the nearest number to the last packet number seen
# whose whose low-order bits agree with `hdr_pkt_num`. Note this is ambiguous
# in the case that `hdr_pkt_num - last_pkt_num = 2^(n-1) mod 2^n` where `n`
# is the number of bits, since `last_pkt_num + 2^(n-1)` and `last_pkt_num - 2^(n-1)`
# both equal `hdr_pkt_num` modulo `2^n` and are equidistant from `last_pkt_num`.
# This case is forbidden.
#
# Requirements
#
# - The sent packet number must be no greater than `la + max/2` where
#   `la` is the greatest acknowledged packet number (or zero if there
#   have been no acks) and `max` is a largest number that can be
#   represented with the number of bits provided [1].
#
# Notes:
#
# - The IETF draft uses this langauge: "The sender MUST use a packet
#   number size able to represent more than twice as large a range
#   than the difference between the largest acknowledged packet and
#   packet number being sent." The meaning of "more than twice as
#   large a range" isn't clear, but here we take it to mean that
#   `2 * (pnum - la) ` is representable. It is also not clear how the
#   maximum packet number is computed if no acks have been received,
#   but we assume here that `la` is zero in this case.
#
#   TODO: this seems inconsistent with the following statement: "The
#   initial value for packet number MUST be selected randomly from a
#   range between 0 and 2^32 - 1025 (inclusive)." Possibly there is no
#   upper limit on the packet number if no acks have been received
#   yet, but this seems questionable.

action decode_packet_number(src:ip.endpoint,dst:ip.endpoint,pkt:quic_packet) returns (pnum:pkt_num) = {

    var scid := pkt.hdr_cid;

    if ~pkt.hdr_long {
        scid := cid_dst_to_src(dst,pkt.dst_cid)
    };

    var e := conn_enc_level(src,scid);
    var la := max_acked(src,scid,e);
    pnum := pkt.hdr_pkt_num;


    if conn_seen(src,scid) {

        # This is a last number transmitted by the source on this connection.

        var last := last_pkt_num(src,scid,e);

        # If long format or type is 0x1d, we match 32 bits

        if pkt.hdr_long | pkt.hdr_type = 0x1d {
            var diff : pkt_num := bfe[0][31](pnum - last);
            pnum := last + diff;
            if diff >= 0x80000000 {
                pnum := pnum - 0x100000000
            };
            # require pnum <= la + 0x7ffffffe;
            # TEMPORARY: work around minquic bug
            require pnum <= la + 0x7;
        }

        # else if long format or type is 0x1e, we match 16 bits

        else if pkt.hdr_type = 0x1e {
            pnum := last + bfe[0][15](pnum - last);
            require pnum <= la + 0x7ffe;
        }

        # else (type is 0x1f) we match 8 bits

        else {
            pnum := last + bfe[0][7](pnum - last);
            require pnum <= la + 0x7e;
        }
    }
}

# TLS extensions are used in the client hello and server hello
# messages to carry the QUIC transport parameters, via special TLS
# extension type `quic_transport_parameters`. This type is define in
# the reference `quic_transport_parameters`. Here we define the
# protocol rules associated with `quic_transport_parameters`.
#
# The `handle_tls_handshake` rules apply to each `client_hello` or
# `server_hello` message, in order of occurrence in the crypto data.
# The last parameter, `is_client_hello`, is true for a `client_hello`
# message (see below).
#
# A server hello establishes the connection between the server and the
# client cids [1]. We have to do it this way because there is no way
# looking at just the QUIC packet header and frame types to
# distinguish a client initial message from a server initial message.
#
# We also infer changes in encryption level from the handshake message
# types. In particular, any non-hello message moves us from the initial
# level to the handshake level. TODO: this might not be reliable if there
# are changes to TLS. It would be better to get an explicit signal from
# TLS that the level is changing. TODO: Does the QUIC-TLS specification
# say explicitly when the encryption level should change?
#

action handle_tls_handshake(src:ip.endpoint,dst:ip.endpoint,scid:cid,dcid:cid,hs:tls.handshake) = {

    if some(ch:tls.client_hello) hs *> ch {
        queued_hello(src,scid) := true;
        call handle_tls_extensions(src,dst,scid,ch.extensions,true);
    }
    else if some(sh:tls.server_hello) hs *> sh {
        queued_hello(src,scid) := true;
        call map_cids(src,scid,dcid);    # [1]
        call map_cids(dst,dcid,scid);
        call handle_tls_extensions(src,dst,scid,sh.extensions,false);
    }
    else if conn_enc_level(src,scid) = encryption_level.initial {
        conn_enc_level(src,scid) := encryption_level.handshake 
    }
}

action map_cids(dst:ip.endpoint,dcid:cid,scid:cid) = {
    cid_dst_to_src_set(dst,dcid) := true;
    cid_dst_to_src(dst,dcid) := scid
}

# Requirements:
#
# 1. Transport parameters must be declared in the client hello
#    and server hello message [1] and may be declared only once [2].
#
# The rules in `handle_client_transport_parameters` apply to each
# `quic_transport_parameters` extension instance in order of
# occurrence.
#

action handle_tls_extensions
    (src:ip.endpoint,
     dst:ip.endpoint,
     scid:cid,
     exts:vector[tls.extension],
     is_client_hello:bool) =
{

    # We process the extensions in a message in order.

    var idx := exts.begin;
    while idx < exts.end {
        var ext := exts.value(idx);
            
        # For every `quic_transport_parameters` extension...

        if some (tps:quic_transport_parameters) ext *> tps {
            call handle_client_transport_parameters(src,dst,scid,tps,is_client_hello);
            require ~trans_params_set(src,scid);  # [2]
            trans_params_set(src,scid) := true;
            
        };
        idx := idx.next
    };
    # TEMPORARY: exempt server from sending transport parameters, since
    # minq doesn't implement this.
# TEMPORARY: skip this until Botan supports it
#    if is_client_hello {
#        require trans_params_set(src,scid);
#    }
}


# The rules in `handle_transport_parameter` apply to each
# `transport_parameter` instance a `quic_transport_parameters`
# extension, in order of occurrence.

# Requirements:
#
# - The endpoint must issue an `initial_max_stream_data` value [1].
# - The endpoint must issue an `initial_max_data` value [2].
# - The endpoint must issue an `idle_timeout` value [3].
# - A client must not issue an `stateless_reset_token` value [4].
#
# Note:
#
# - Setting a transport parameter requires that the parameter is not
#   previously set.

action handle_client_transport_parameters(src:ip.endpoint,dst:ip.endpoint,scid:cid,
                                          tps:quic_transport_parameters,
                                          is_client_hello : bool) =
{
    call client_transport_parameters_event(src,dst,scid,tps);
    var idx := tps.transport_parameters.begin;
    while idx < tps.transport_parameters.end {
        trans_params(src,scid) := tps.transport_parameters.value(idx).set(trans_params(src,scid));
        idx := idx.next
    };
    require initial_max_stream_data.is_set(trans_params(src,scid));  # [1]
    require initial_max_data.is_set(trans_params(src,scid));  # [2]
    require idle_timeout.is_set(trans_params(src,scid));  # [3]
    if is_client_hello {
        require ~stateless_reset_token.is_set(trans_params(src,scid));  # [4]
    }
}






action client_transport_parameters_event(src:ip.endpoint,dst:ip.endpoint,scid:cid,
                                         tps:quic_transport_parameters)

import client_transport_parameters_event

action show_enc_level(e:encryption_level)

import show_enc_level

import action show_offset_length(offset:stream_pos,length:stream_pos)
