#lang ivy1.7

# Deduction example: array reversal
# =================================
# 
# This is an example of using tactics in Ivy to solve the problem of
# unstratified functions.
#
# We will define what it means for one array to be the reverse of another,
# then prove that reversing an array twice gives the original array.

include order
include collections
include deduction

# properties of rev relation

instance idx : unbounded_sequence

relation rev(U : idx, X : idx, Y : idx)

isolate rev_theory = {
    
    specification {
        property idx.succ(Y,U) -> rev(U,0,Y)
        property rev(U,X,Y) & idx.succ(X,X1) & idx.succ(Y1,Y) -> rev(U,X1,Y1)
        property rev(U,X,Y) -> rev(U,Y,X)
        theorem foo = {
            property 0 <= X & X < U -> exists Y. rev(U,X,Y)
        }
        proof
            apply impi;
            apply exi with witness = U - X - 1
    }

    implementation {
        definition rev(U,X,Y) = (X + Y = U - 1)
    }
} with idx.impl

type t

instance arr : array(idx,t)

function arr_rev(A1:arr,A2:arr) =
        arr.end(A1) = arr.end(A2) & forall X,Y. rev(arr.end(A1),X,Y) -> arr.value(A1,X) = arr.value(A2,Y)

property arr_rev(A1,A2) -> arr_rev(A2,A1)

isolate double_reverse1 = {
    property arr_rev(A,B) & arr_rev(A,C) & 0 <= X & X < arr.end(B) -> arr.value(B,X) = arr.value(C,X)
    proof assume rev_theory.foo with U = arr.end(B)

    property arr_rev(A,B) & arr_rev(A,C) -> B = C
    proof
        assume arr.spec.extensionality with X = B, Y = C
} with this


isolate double_reverse2 = {
    property arr_rev(A,B) & arr_rev(A,C) -> B = C
    proof
        apply impi;
        apply arr.spec.extensionality;
        apply andi;
        defergoal;
        apply alli ;
        assume rev_theory.foo with U = arr.end(B), X = x;
        showgoals
} with this

