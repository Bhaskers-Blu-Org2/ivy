#lang ivy1.7

include lang

# C++ subset syntax
# -----------------
#
# This file implements a small subset of the syntax of C++ that
# is used by the Ivy to C++ translator.
#

object cpp = {
    instantiate verb_base
    instantiate expr_base
    instantiate stmt_base(expr,"=",true)

    # Here, we parse statements specific to C++
    
    object simpletype = {
        type this = struct {
            _type : expr,
            name : expr
        }

        instance tup : tuple(simpletype,"(",")",verb)

        action encode(s:this,b:pretty,prio:verb) returns (b:pretty) = {
            b := s._type.encode(b,0);
            b := b.extend(" ");
            b := s.name.encode(b,99);
        }
        
        action parse(st : pstate, prio:verb) returns(st : pstate, res:simpletype) = {
            (st,res._type) := symbol.parse(st);
            if st.ok {
                (st,res.name) := symbol.parse(st);
            }
        }
    }

    object functype = {
        type this = struct {
            base : simpletype,
            args : vector[simpletype]
        }
        action encode(s:this,b:pretty,prio:verb) returns (b:pretty) = {
            b := s.base.encode(b,0);
            b := b.extend(" ");
            b := simpletype.tup.encode(s.args,b,0);
        }
        action parse(st : pstate, prio:verb) returns(st : pstate, res:functype) = {
            (st,res.base) := simpletype.parse(st,prio);
            if st.ok {
                (st,res.args) := simpletype.tup.parse(st,prio);
            }
        }
    }

    object varst = {
        variant this of stmt = struct {
            vtype : simpletype,
            ann : annot
        }

        instantiate generic_stmt_encode(1)

        action make(_type:expr, name:expr, ann:annot) returns (res:stmt) = {
            var s : this;
            s.vtype._type := _type;
            s.vtype.name := name;
            s.ann := ann;
            res := s;
        }
       

        action encode_int(s:this,b:pretty,prio:verb) returns (b:pretty) = {
            b := b.nest;
            b := s.vtype.encode(b,prio);
            b := b.extend(";");
            b := b.unnest;
        }
    }

    object retst = {
        variant this of stmt = struct {
            val : expr,
            ann : annot
        }

        instantiate generic_stmt_encode(1)

        action make(val:expr, ann:annot) returns (res:stmt) = {
            var s : this;
            s.val := val;
            s.ann := ann;
            res := s;
        }

        action encode_int(s:this,b:pretty,prio:verb) returns (b:pretty) = {
            b := b.nest;
            b := b.extend("return");
            b := b.extend(" ");
            b := s.val.encode(b,prio);
            b := b.extend(";");
            b := b.unnest;
        }
    }

    object stmt = { ...

        
        action parse_lang_stmt(st : pstate, prio:verb) returns(st : pstate, res:stmt) = {
            var lhs : expr;
            var ann : annot;
            (st,ann) := st.get_ann;
            (st,lhs) := expr.parse(st,3);
            if st.ok & st.tok = "=" {
                st := st.consume;
                var s : asgn;
                s.lhs := lhs;
                s.ann := ann;
                (st,s.rhs) := expr.parse(st,0);
                res := s;
            }
            else {
                # if not assignment, could be variable declaration
                var name : expr;
                (st,name) := symbol.parse(st);
                if st.ok {
                    var s : varst;
                    s.ann := ann;
                    s.vtype._type := lhs;
                    s.vtype.name := name;
                    res := s;
                }
            };
            if st.ok & st.tok = ";" {
                st := st.consume;
            } else {
                st.ok := false;  # cannot omit final semicolon in C++
            }
        }
    }



    object decl = {
        type this
        instantiate parse_intf(decl)
    }        


    object funcdecl = {
        variant this of decl = struct {
            ftype : functype,
            ann : annot
        }
        action encode(s:this,b:pretty,prio:verb) returns (b:pretty) = {
            b := s.ann.encode(b);
            b := b.nest;
            b := s.ftype.encode(b,0);
            b := b.extend(";");
            b := b.unnest;
            b := b.newline;
        }
    }

    object funcimpl = {
        variant this of decl = struct {
            ftype : functype,
            body : stmt,
            ann : annot
        }
        action encode(s:this,b:pretty,prio:verb) returns (b:pretty) = {
            b := s.ann.encode(b);
            b := b.nest;
            b := s.ftype.encode(b,0);
            b := b.unnest;
            b := b.extend(" ");
            b := s.body.encode(b,2);
        }
    }

    object decl = { ...
        action parse(st : pstate, prio:verb) returns(st : pstate, res:decl) = {
            var ann : annot;
            (st,ann) := st.get_ann;
            var f : functype;
            (st,f) := functype.parse(st,prio);
            if st.ok & st.tok = ";" {
                var s : funcdecl;
                s.ftype := f;
                s.ann := ann;
                res := s;
            } else if st.ok & st.tok = "{" {
                var s : funcimpl;
                s.ftype := f;
                s.ann := ann;
                (st,s.body) := stmt.parse(st,0);
                res := s;
            }
        }

        var foo : vector[decl]  # workaround

        action parse_list(st : pstate, prio:verb) returns(st : pstate, res:vector[decl]) = {
            while st.ok & st.tok.end > 0 & st.tok ~= "}" {
                var s : decl;
                (st,s) := parse(st,0);
                res := res.append(s);
            }
        }
    }

    action namedtype(name:str,ann : annot) returns(res:expr) = {
        var s : symbol;
        s.name := name;
        s.ann.line := ann.line;
        res := s;
    }

    action inttype(ann : annot) returns(res:expr) = {
        res := namedtype("int",ann);
    }

    action voidtype(ann : annot) returns(res:expr) = {
        res := namedtype("void",ann);
    }



}

export cpp.expr.enc
export cpp.expr.dec
export cpp.expr.encdec
export cpp.stmt.enc
export cpp.stmt.dec
export cpp.stmt.encdec
export cpp.decl.enc
export cpp.decl.dec
export cpp.decl.encdec


# export pretty.make
# export pretty.extend
# export pretty.flush

# action pr(max:pos,s:str) returns (res:str) = {
#     var p := pretty.make(max,4);
#     var st := pstate.make(s);
#     while st.tok.end > 0 {
# 	if st.tok = "(" {
# 	    p := p.nest
# 	};
# 	p := p.extend(st.tok);
# 	if st.tok = ")" {
# 	    p := p.unnest
# 	};
# #	call show_pretty(p);
# 	if st.b.value(st.p) = 32 {
# 	    p := p.extend(" ");
# #	    call show_pretty(p);
# 	};
# 	st := st.consume
#     };

#     p := p.flush;
#     res := p.output
# }

# export pr

# # after init {

# #     var p := pretty.make(11,4);
# #     var st := pstate.make("fooooooo + (bar + baaaaaz)");
# #     while st.tok.end > 0 {
# # 	if st.tok = "(" {
# # 	    p := p.nest
# # 	};
# # 	p := p.extend(st.tok);
# # 	if st.tok = ")" {
# # 	    p := p.unnest
# # 	};
# # 	call show_pretty(p);
# # 	if st.b.value(st.p) = 32 {
# # 	    p := p.extend(" ");
# # 	    call show_pretty(p);
# # 	};
# # 	st := st.consume
# #     };

# #     p := p.flush;
# #     call show_pretty(p);
    
# # }

# import action show_pretty(p:pretty)
