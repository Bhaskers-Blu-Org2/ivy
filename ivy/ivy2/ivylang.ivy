#lang ivy1.7

include lang

object ivy = {

    # Here, we instantiate the Ivy language traits that are in common
    # with C++.

    instantiate verb_base
    instantiate expr_base(false)
    instantiate stmt_base(expr,":=",false)
    instantiate decl_base(expr,stmt)

    # Now we have the operators that are unique to Ivy.
    #
    # The binary `:` operator is used to represent a type
    # judgement.

    instance colon : built_in_binary(":",verb.colon,50)

    # Here, we have statements specific to Ivy and the Ivy statement
    # parser.
    
    # The object `varst` represents the `var` statement.

    object varst = {
        variant this of stmt = struct {
            name : expr,
            ann : annot
        }

        action make (name:expr,ann:annot) returns (res:stmt) = {
            var s:this;
            s.name := name;
            s.ann := ann;
            res := s;
        }

        instantiate generic_stmt_encode(1)

        action encode_int(s:this,b:pretty,prio:priority) returns (b:pretty) = {
            b := s.ann.encode(b);
            b := b.nest;
            b := b.extend("var");
            b := b.extend(" ");
            b := s.name.encode(b,0);
            b := b.extend(";");
            b := b.unnest;
        }
    }

    object stmt = { ...

        action parse_lang_stmt(st : pstate, prio:priority) returns(st : pstate, res:stmt) = {
            if st.tok = "var" {
                st := st.consume;
                var s : varst;
                (st,s.ann) := st.get_ann;
                (st,s.name) := expr.parse(st,0);
                if st.ok & st.tok = ";" {
                    st := st.consume;
                } else {
                    st.ok := st.tok = "}";  # allow to omit final semicolon
                };
                res := s;
            } else {
                var s : asgn;
                (st,s.ann) := st.get_ann;
                (st,s.lhs) := expr.parse(st,3);
                if st.ok & st.tok = ":=" {
                    st := st.consume;
                    (st,s.rhs) := expr.parse(st,0);
                    if st.ok & st.tok = ";" {
                        st := st.consume;
                    } else {
                        st.ok := st.tok = "}";  # allow to omit final semicolon
                    }
                } else if st.ok & st.tok = ";" {
                    st := st.consume;
                    s.rhs := s.lhs;
                    s.lhs := empty.make(s.ann.strip);  # just an expression -- assign to ()
                } else {
                    st.ok := st.tok = "}";  # allow to omit final semicolon
                };
                res := s;
            }
        }
    }

    object groupdc = {
        variant this of decl = struct {
            decls : vector[decl]
        }

        action make(decls : vector[decl]) returns (res:decl) =
        {
            var s:this;
            s.decls := decls;
            res := s;
        }

        action encode(s:this,b:pretty,prio:priority) returns (b:pretty) = {
            b := b.nest;
            b := b.extend("{");
            var idx := s.decls.begin;
            while idx < s.decls.end {
                b := b.newline;
                b := s.decls.value(idx).encode(b,0);
                idx := idx.next;
            };
            b := b.unnest;
            b := b.newline;
            b := b.extend("}");
        }	    
    }

    object typedc = {
        variant this of decl = struct {
            sort : expr,
            ann : annot
        }

        action make(sort:expr) returns (res:decl) =
        {
            var s:this;
            s.sort := sort;
            res := s;
        }

        action encode(s:this,b:pretty,prio:priority) returns (b:pretty) = {
            b := b.nest;
            b := b.extend("type");
            b := b.extend(" ");
            b := s.sort.encode(b,0);
            b := b.unnest;
            b := b.newline;
        }	    
    }        

    object vardc = {
        variant this of decl = struct {
            typing : expr,
            is_destructor : bool,
            ann : annot
        }

        action make(typing:expr) returns (res:decl) =
        {
            var s:this;
            s.typing := typing;
            res := s;
        }

        action encode(s:this,b:pretty,prio:priority) returns (b:pretty) = {
            b := b.nest;
            b := b.extend("destructor" if s.is_destructor else "var");
            b := b.extend(" ");
            b := s.typing.encode(b,0);
            b := b.unnest;
            b := b.newline;
        }	    
    }        

    object decl = { ...
        action parse(st : pstate, prio:priority) returns(st : pstate, res:decl) = {
            if st.tok = "{" {
                st := st.consume;
                var s : groupdc;
                (st,s.decls) := parse_list(st,0);
                if st.tok = "}" {
                    st := st.consume;
                } else {st.ok := false};
                res := s
            }
            else if st.tok = "action" {
                st := st.consume;
                var s : actdc;
                (st,s.ann) := st.get_ann;
                (st,s.name) := expr.parse(st,99);
                if st.ok & st.tok = "(" {
                    (st,s.inputs) := expr.tup.parse(st,0);
                };
                if st.ok & st.tok = "returns" {
                    st := st.consume;
                    (st,s.outputs) := expr.tup.parse(st,0);
                };
                if st.ok & st.tok = "=" {
                    st := st.consume;
                    s.has_body := true;
                    if st.tok = "{" {
                        (st,s.body) := stmt.parse(st,1);
                    } else {st.ok := false}
                };
                res := s
            } else if st.tok = "type" {
                st := st.consume;
                var s : typedc;
                (st,s.ann) := st.get_ann;
                (st,s.sort) := expr.parse(st,0);
                res := s
            } else if st.tok = "var" | st.tok = "destructor" {
                var s : vardc;
                s.is_destructor := (st.tok = "destructor");
                st := st.consume;
                (st,s.ann) := st.get_ann;
                (st,s.typing) := expr.parse(st,0);
                res := s
            } else {st.ok := false}
        }
        action parse_list(st : pstate, prio:priority) returns(st : pstate, res:vector[decl]) = {
            while st.ok & st.tok.end > 0 & st.tok ~= "}" {
                var s : decl;
                (st,s) := parse(st,0);
                res := res.append(s);
            }
        }
    }

    instantiate prog_base

}

export ivy.expr.enc
export ivy.expr.dec
export ivy.expr.encdec
export ivy.stmt.enc
export ivy.stmt.dec
export ivy.stmt.encdec
export ivy.decl.enc
export ivy.decl.dec
export ivy.decl.encdec
export ivy.prog.enc
export ivy.prog.dec
export ivy.prog.encdec

import parse_error


export pretty.make
export pretty.extend
export pretty.flush

action pr(max:pos,s:str) returns (res:str) = {
    var p := pretty.make(max,4);
    var st := pstate.make(s);
    while st.tok.end > 0 {
	if st.tok = "(" {
	    p := p.nest
	};
	p := p.extend(st.tok);
	if st.tok = ")" {
	    p := p.unnest
	};
#	call show_pretty(p);
	if st.b.value(st.p) = 32 {
	    p := p.extend(" ");
#	    call show_pretty(p);
	};
	st := st.consume
    };

    p := p.flush;
    res := p.output
}

export pr

# after init {

#     var p := pretty.make(11,4);
#     var st := pstate.make("fooooooo + (bar + baaaaaz)");
#     while st.tok.end > 0 {
# 	if st.tok = "(" {
# 	    p := p.nest
# 	};
# 	p := p.extend(st.tok);
# 	if st.tok = ")" {
# 	    p := p.unnest
# 	};
# 	call show_pretty(p);
# 	if st.b.value(st.p) = 32 {
# 	    p := p.extend(" ");
# 	    call show_pretty(p);
# 	};
# 	st := st.consume
#     };

#     p := p.flush;
#     call show_pretty(p);
    
# }

import action show_pretty(p:pretty)
