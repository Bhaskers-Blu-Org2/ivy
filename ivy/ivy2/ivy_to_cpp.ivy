#lang ivy1.7

include ivylang
include cpplang
include hash
#include reader
include pass_flat
include pass_typeinfer
#include reader
include analysis

module generic_to_cpp(ivytype,cpptype,cppclass) = {
    action to_cpp(s:ivytype,st:tocppst) returns (res:cppclass,st:tocppst) = {
        var t : cpptype;
        (t,st) := s.to_cpp_int(st);
        t.ann := s.ann;
        res := t
    }
}


module binary_op_to_cpp(ivytype,cpptype,cppclass) = {
    instantiate generic_to_cpp(ivytype,cpptype,cppclass)
    action to_cpp_int(s:ivytype,st:tocppst) returns (res:cpptype,st:tocppst) = {
        (res.lhs,st) := s.lhs.to_cpp(st);
        (res.rhs,st) := s.rhs.to_cpp(st);
    }
}
    
module test_to_cpp(ivyclass,cppclass) = {
    export action test(s:str) returns(res:str) = {
        var ivyexpr := ivyclass.dec(s);
        var fst : flatst;
        (ivyexpr,fst) := ivyexpr.flat(fst);
        var cppexpr : cppclass;
        var st : tocppst;
        (cppexpr,st) := ivyexpr.to_cpp(st);
        res := cppexpr.enc
    }
    export action test1(s:str) returns(res:cppclass) = {
        var ivyexpr := ivyclass.dec(s);
        var fst : flatst;
        (ivyexpr,fst) := ivyexpr.flat(fst);
        var st : tocppst; 
        (res,st) := ivyexpr.to_cpp(st);
    }
    export action test2(s:str) returns(res:ivyclass) = {
        var ivyexpr := ivyclass.dec(s);
        var fst : flatst;
        (ivyexpr,fst) := ivyexpr.flat(fst);
        res := ivyexpr;
    }
}

object ivy = { ...


    instance ident_to_declvec : hash_map(ident,vector[decl])
    instance ident_to_cppclass : hash_map(ident,expr)

    object tocppst = {
        type this = struct {
            
            # Maps types to their members, which includes destructors and
            # member actions.

            members : ident_to_declvec,

            # Maps types to their C++ superclasses

            cppclasses : ident_to_cppclass,

            # Identifiers of all objects

            objects : ident_set,

            # True if we are emitting a member action

            is_member : bool,

            # The name of the "this" parameter in a member

            this_ident : ident,

	    # True if we are in a class declaration

	    in_class : bool,

            # True if we are only emitting prototypes

            proto_only : bool,

            # The subtyping relation

            subtype_rel : subtypes

        }

        action add_member(s:this,namesp:ident,member:decl) returns (s:this) = {
            var emp : vector[decl];
            s.members := s.members.set(namesp,s.members.get(namesp,emp).append(member));
        }
    }
        
    # In context of class declarations, identifiers are declared
    # without their namespaces.

    action name_in_context(name:expr,st:tocppst) returns(name:expr) = {
        if st.in_class {
	    name := symbol.make(name.get_name.get_member,name.get_ann);
	};
    }

    # Curry a function type, that is, translate type `t1 * ... tn -> s` to
    # type t1 -> (t2 * ... * tn -> s).

    object expr = { ...
        action curry(ty:expr) returns (ty:expr) = {
            var dom := times.unfold_left(ty.get_arg(0));
            var dom2 := dom.segment(1,dom.end);
            var rng := ty.get_arg(1);
            var ty2 :=
                rng if dom2.end = 0
                else arrow.make(times.fold_left(dom2,ty.get_arg(0).get_ann),rng,ty.get_ann);
            ty := arrow.make(dom.value(0),ty2,ty.get_ann.strip)
        }
    }
    
    object ident = { ...
        action to_cpp(s:this) returns (res:cpp.ident)
    }

    action strident_to_cpp(s:strident) returns (t:cpp.strident) = {
        t.val := s.val;
        var idx := s.subscrs.begin;
        while idx < s.subscrs.end {
            t.subscrs := t.subscrs.append(s.subscrs.value(idx).to_cpp);
            idx := idx.next
        }
    }

    object strident = { ...
        action to_cpp(s:this) returns (res:cpp.ident) = {
            var x := strident_to_cpp(s); # workaround
            var y : cpp.ident := x;
            res := y;
        }
    }

    object dotident = { ...
        action to_cpp(s:this) returns (res:cpp.ident) = {
            var t : cpp.dotident;
            t.namesp := s.namesp.to_cpp;
            t.member := strident_to_cpp(s.member);
            res := t
        }
    }

    object subsident = { ...
        action to_cpp(s:this) returns (res:cpp.ident) = {
            var t : cpp.subsident;
            t.namesp := s.namesp.to_cpp;
            var idx := s.subscrs.begin;
            while idx < s.subscrs.end {
                t.subscrs := t.subscrs.append(s.subscrs.value(idx).to_cpp);
                idx := idx.next
            };
            res := t
        }
    }

    object expr = { ...
        action to_cpp(s:expr,st:tocppst) returns (res:cpp.expr,st:tocppst)
    }
    
    # When translating symbols to C++, we need to take care of name clashes between
    # namespaces (Ivy objects) and classes (Ivy types). If a type has the same identifier as
    # an object, we append `.__t` to the identifier of the type.

    action fix_object_clash(id:ident,st:tocppst) returns (id:ident) = {
        if st.objects.mem(id) {
            var tok : strident;
            tok.val := "__t";
            id := dotident.make(id,tok);
        }
    }
    
    # Also, when compiling a class member function, the first argument is implicit, and
    # is replaced in the C++ by `(*this)`.

    object symbol = { ...
        instantiate generic_to_cpp(ivy.symbol,cpp.symbol,cpp.expr)
        action to_cpp_int(s:symbol,st:tocppst) returns (res:cpp.symbol,st:tocppst) = {
            if st.is_member & s.name = st.this_ident {
                res.name := cpp.strident.make("(*this)");
            } else {
                var id := fix_object_clash(s.name,st);
                res.name := id.to_cpp;
            };
            res.vrb := cpp.str_to_verb(res.name.to_str);
        }
    }

    action make_vector_type(ty:expr) returns (ty:expr) = {
	var vid : strident;
	vid.val := "vector";
	vid.subscrs := vid.subscrs.append(ty.get_name);
	var name := vid.prefix(strident.make("ivy"));
	ty := symbol.make(name,ty.get_ann)
    }

    action make_md_vector_type(dom:vector[expr],rng:expr) returns (ty:expr) = {
	var vid : strident;
	vid.val := "vector";
	vid.subscrs := vid.subscrs.append(rng.get_name);
	var idx := dom.begin;
	while idx < dom.end {
	    vid.subscrs := vid.subscrs.append(dom.value(idx).get_name);
	    idx := idx.next
	};
	var name := vid.prefix(strident.make("ivy"));
	ty := symbol.make(name,ty.get_ann)
    }

    action function_type(ty:expr) returns (ty:expr) = {
	if ty isa app {
	    # TODO: verify the domain type is convertible to size_t
	    # var cty := ty.curry;
	    # var rng := function_type(cty.get_arg(1));
	    # ty := make_vector_type(rng);
	    ty := make_md_vector_type(arrow.unfold_left(ty.get_arg(0)),ty.get_arg(1))
	}
    }

    object app = { ...
        action to_cpp(s:this,st:tocppst) returns (res:cpp.expr,st:tocppst) = {
	    if s.is(verb.colon) {
		(res,st) := s.args.value(0).to_cpp(st)
	    } else if s.is(verb.arrow) {
		var tmp : expr := s;  # workaround
		var fty := function_type(tmp);
		(res,st) := fty.to_cpp(st)
	    } else {
		var capp : cpp.app;
		(capp.func,st) := s.func.to_cpp(st);
		if s.func.is(verb.colon) {
		    var ftype := s.func.get_arg(1);
		    var argtys := arrow.unfold_left(ftype.get_arg(0));
		    var idx := s.args.begin;
		    while idx < s.args.end {
			var arg : cpp.expr;
			(arg,st) := upcast(argtys.value(idx),s.args.value(idx),st);
			capp.args := capp.args.append(arg);
			idx := idx.next
		    }
		} else {
		    var idx := s.args.begin;
		    while idx < s.args.end {
			var arg : cpp.expr;
			(arg,st) := s.args.value(idx).to_cpp(st);
			capp.args := capp.args.append(arg);
			idx := idx.next
		    };

		    # If of the form (x:t).f, where t is a variant
		    # type, convert to x->f.

		    if s.func.get_verb = verb.dot {
			var lhs := s.args.value(0);
			if lhs.is(verb.colon) {
			    var ty := lhs.get_arg(1);
			    if is_variant_type(ty,st) {
				capp.func := cpp.symbol.makestr("->",capp.func.get_ann)
			    }
			}
		    }
		};
		capp.ann := s.ann;
		res := capp
	    }
        }
    }

    object stmt = { ...
        action to_cpp(s:stmt,st:tocppst) returns (res:cpp.stmt,st:tocppst)
    }

    object skipst = { ...
        instantiate generic_to_cpp(ivy.skipst,cpp.skipst,cpp.stmt)
        action to_cpp_int(s:ivy.skipst,st:tocppst) returns (res:cpp.skipst,st:tocppst) = {
        }
    }

    action upcast(lhsty:expr,rhs:expr,st:tocppst) returns (res:cpp.expr,st:tocppst) = {
        (res,st) := rhs.to_cpp(st);
        if rhs.is(verb.colon) {
            var rhsty := rhs.get_arg(1);
            if st.subtype_rel.is_subtype(rhsty,lhsty) {
		var crhsty : cpp.expr;
		(crhsty,st) := rhsty.to_cpp(st);
                res := cpp.new.make(cpp.app.make1(crhsty,res,rhs.get_ann),rhs.get_ann);
            }
        }
    }

    object asgn = { ...
        instantiate generic_to_cpp(ivy.asgn,cpp.asgn,cpp.stmt)
        action to_cpp_int(s:ivy.asgn,st:tocppst) returns (res:cpp.asgn,st:tocppst) = {
            (res.lhs,st) := s.lhs.to_cpp(st);
	    if s.lhs.is(verb.colon) {
		(res.rhs,st) := upcast(s.lhs.get_arg(1),s.rhs,st)
	    } else {
		(res.rhs,st) := s.rhs.to_cpp(st)
	    }
        }
    }

    object sequence = { ...
        instantiate binary_op_to_cpp(ivy.sequence,cpp.sequence,cpp.stmt)
    }

    object ifst = { ...
        instantiate generic_to_cpp(ivy.ifst,cpp.ifst,cpp.stmt)
        action to_cpp_int(s:ivy.ifst,st:tocppst) returns (res:cpp.ifst,st:tocppst) = {
            (res.cond,st) := s.cond.to_cpp(st);
            (res.thenst,st) := s.thenst.to_cpp(st);
            (res.elsest,st) := s.elsest.to_cpp(st);
        }
    }

    object varst = { ...
        instantiate generic_to_cpp(ivy.varst,cpp.varst,cpp.stmt)
        action to_cpp_int(s:varst,st:tocppst) returns (res:cpp.varst,st:tocppst) = {
            var ty := fix_variant_type(s.name.get_arg(1),st);
            (res.vtype._type,st) := ty.to_cpp(st);
            (res.vtype.name,st) := s.name.get_arg(0).to_cpp(st);
        }
    }

    object decl = { ...
        action to_cpp(s:this,st:tocppst) returns (res:cpp.decl,st:tocppst)
        action reg_member(s:this,st:tocppst) returns (st:tocppst)
        action emitted(s:this,st:tocppst) returns (res:bool) = {
            res := true;
        }
    }

    # The full name of a C++ function depends on whether it is a member function.
    # If so, we find take the full name of the class and append the member name.
    # The full name of the class can differ from the name of Ivy type because of
    # object name clashes.

    action full_action_name(name:expr,is_member : bool,st:tocppst)
        returns (res:cpp.expr,st:tocppst) =
    {
        if is_member {
            var pref : ident := name.get_name.get_namesp;
            var clsid := fix_object_clash(pref,st);
            var funid := name.get_name.get_member.prefix(clsid);
            res := cpp.symbol.make(funid.to_cpp,name.get_ann);
        } else {
            (res,st) := name.to_cpp(st) 
        }
    }

    object actdc = { ...
        # Here, we translate an Ivy action declaration to a C++
        # function declaration. If the action is a member action, we
        # drop the first input and replace it with `*this`.
        
        action to_cpp(s:this,st:tocppst) returns (resd:cpp.decl,st:tocppst) = {
            var res : cpp.funcdecl;
            res.ann := s.ann;
            var has_output := s.outputs.end > 0;
            if has_output {
                var ty := fix_variant_type(s.outputs.value(0).get_arg(1),st);
                (res.ftype.base._type,st) := ty.to_cpp(st);
            } else {
                res.ftype.base._type := cpp.voidtype(s.ann);
            };
            var proto := ~s.has_body | st.proto_only;
            var is_member := s.is_member;
            var full_name : cpp.expr;
            (full_name,st) := full_action_name(s.name,is_member,st);
	    res.ftype.base.name := member_name(full_name) if (proto | st.in_class) else full_name; 
            var idx := s.inputs.begin;
            st.is_member := is_member;
            if st.is_member {
                idx := idx.next;   # skip the first input "this" if a member
                st.this_ident := s.inputs.value(0).get_arg(0).get_name;
            };
            while idx < s.inputs.end {
                var arg := s.inputs.value(idx);
                var argt : cpp.simpletype;
                var ty := fix_variant_type(arg.get_arg(1),st);
                (argt._type,st) := ty.to_cpp(st);
                (argt.name,st) := arg.get_arg(0).to_cpp(st);
                res.ftype.args := res.ftype.args.append(argt);
                idx := idx.next
            };
            res.has_body := s.has_body & ~proto;
            if s.has_body {
                var body :cpp.stmt;
                (body,st) := s.body.to_cpp(st);
                res.body := body;
                if has_output {
                    var rvar : cpp.expr;
                    (rvar,st) := s.outputs.value(0).get_arg(0).to_cpp(st);
                    var ret := cpp.retst.make(rvar,s.ann);
                    res.body := cpp.sequence.make(res.body,ret,s.ann);
                    var vs := cpp.varst.make(res.ftype.base._type,rvar,s.ann);
                    res.body := cpp.sequence.make(vs,res.body,s.ann);
                }
            };
            st.is_member := false;
            resd := res;
            if ~st.in_class & proto {
                resd := add_namespaces(resd,s.name.get_name);
            }
        }

        # Here, we register actions as members of types. These will be emitted
        # as members of the corresponding C++ class. 

        action reg_member(s:this,st:tocppst) returns (st:tocppst) = {
            if s.is_member {
                var actd := s;
                actd.has_body := false;
                st := st.add_member(s.member_type,actd);
            }
        }

        # An action declaration is not emitted if it is a member and
        # does not have a body.

        action emitted(s:this,st:tocppst) returns (res:bool) = {
            res := ~s.is_member | s.has_body & ~st.proto_only;
        }
    }

    action add_namespaces_rec(d:cpp.decl,id:ident) returns(d:cpp.decl) = {
        var nd : cpp.namespacedecl;
        nd.ann := d.get_ann;
        var name := id.get_member if (id isa dotident) else id;
        nd.name := cpp.symbol.make(name.to_cpp,d.get_ann);
        nd.members := nd.members.append(d);
        d := nd;
        if id isa dotident {
            d := add_namespaces(d,id.get_namesp);
        }
    }

    action add_namespaces(d:cpp.decl,id:ident) returns(d:cpp.decl) = {
        if id isa dotident {
            d := add_namespaces_rec(d,id.get_namesp);
        }
    }        

    action member_name(s:cpp.expr) returns(s:cpp.expr) = {
        if (s.get_name) isa cpp.dotident {
            s := cpp.symbol.make(s.get_name.get_member,s.get_ann)
        }
    }        


    # Translate a type declaration to C++. All Ivy types translate to
    # C++ structs.

    object typedc = { ...
        action to_cpp(s:this,st:tocppst) returns (resd:cpp.decl,st:tocppst) = {
            var res : cpp.structdecl;
            res.ann := s.ann;
            var members := st.members.get(s.sort.get_name,vector[decl].empty);
            var cls : cpp.expr;
            (cls,st) := s.sort.to_cpp(st);
            res.name := member_name(cls);
            if s.has_super {
                res.has_super := true;
                (res.super,st) := s.super.to_cpp(st)
            } else if st.cppclasses.mem(s.sort.get_name) {
                res.has_super := true;
                var dflt : expr;  # workaround
                var itype := st.cppclasses.get(s.sort.get_name,dflt);
                (res.super,st) := itype.to_cpp(st)
            };
            res.has_members := true;  # This is not a forward declaration
            var idx := members.begin;
	    st.in_class := true;
            while idx < members.end {
                var d : cpp.decl;
                (d,st) := members.value(idx).to_cpp(st);
                res.members := res.members.append(d);
                idx := idx.next
            };
	    st.in_class := false;
            resd := res; # workaround
            resd := add_namespaces(resd,fix_object_clash(s.sort.get_name,st)); 
	}
    }
	
    action is_variant_type(t:expr,st:tocppst) returns (res:bool) = {
        if t isa symbol {
            if st.subtype_rel.subtypes_of.mem(t.get_name) {
		res := true;
	    }
	}
    }

    # When storing values of variant types we use smart pointers. That is,
    # type `t` becomes `unique_ptr<t>`.

    action fix_variant_type(t:expr,st:tocppst) returns (t:expr) = {
        if is_variant_type(t,st) {
            var s : strident;
            s.val := "unique_ptr";
            s.subscrs := s.subscrs.append(t.get_name);
            t := symbol.make(s.prefix(strident.make("std")),t.get_ann);
        }
    }

    # Translate a local variable declaration to C++. 

    object vardc = { ...
        action to_cpp(s:this,st:tocppst) returns (resd:cpp.decl,st:tocppst) = {
            var res : cpp.vardecl;
            res.ann := s.ann;
            var ty := s.typing.get_arg(1);
            if s.is_destructor {
                ty := ty.curry.get_arg(1);
            };
            ty := fix_variant_type(ty,st);
	    (res.vtype._type,st) := ty.to_cpp(st);
            var name : cpp.expr;
            (name,st) := s.typing.get_arg(0).to_cpp(st);
            res.vtype.name := member_name(name);
            resd := res; # workaround
            if ~st.in_class {
                resd := add_namespaces(resd,s.typing.get_arg(0).get_name);
            }
	}

        # A type destructor is translated to a data member of the class;

        action reg_member(s:this,st:tocppst) returns (st:tocppst) = {
            if s.is_destructor {
                var dom := times.unfold_left(s.typing.get_arg(1).get_arg(0));
                var type_ident := dom.value(0).get_name;
                st := st.add_member(type_ident,s);
            }
        }

        # An variable declaration is not emitted if it is a destructor.

        action emitted(s:this,st:tocppst) returns (res:bool) = {
            res := ~s.is_destructor;
        }

    }

    # Translate a header declaration to C++
    
    object header = { ...
        instantiate generic_to_cpp(this,cpp.header,cpp.decl)
        
	action to_cpp_int(s:this,st:tocppst) returns (res:cpp.header,st:tocppst) = {
            res.filename := s.filename
	}
    }
    
    # Translate an interpret declaration to C++. 

    object interpdc = { ...

        # An interpret declararation determines the C++ superclass of the type.

        action reg_member(s:this,st:tocppst) returns (st:tocppst) = {
            st.cppclasses := st.cppclasses.set(s.itype.get_name,s.ctype);
        }

        # Interpret declarations are never emitted
        
        action emitted(s:this,st:tocppst) returns (res:bool) = {
            res := false;
        }

    }

    # Translate an object declaration to C++. 

    object objectdc = { ...

        # An object declaration corresponds to a namespace in C++. However,
        # we emit namespace declarations for the object members, not here.
        # Here, we just record the object identifiers, so we know when they
        # clash with type identifiers.

        action reg_member(s:this,st:tocppst) returns (st:tocppst) = {
            st.objects := st.objects.set(s.name.get_name,true);
        }

        # Object declarations are never emitted
        
        action emitted(s:this,st:tocppst) returns (res:bool) = {
            res := false;
        }

    }

    # Translate an Ivy program to C++. 

    object prog = { ...
	action to_cpp(s:this,st:tocppst) returns (res:cpp.prog,st:tocppst) = {

            # Take a pass to register all of the type members
            
            var idx := s.decls.begin;
	    while idx < s.decls.end {
                st := s.decls.value(idx).reg_member(st);
		idx := idx.next
	    };

            # Another pass to emit the C++ prototypes and class declarations
            
            st.proto_only := true;
            idx := s.decls.begin;
	    while idx < s.decls.end {
                if s.decls.value(idx).emitted(st) {
                    var d : cpp.decl;
                    (d,st) := s.decls.value(idx).to_cpp(st);
		    res.decls := res.decls.append(d);
                };
		idx := idx.next
	    };

            # Another pass to emit the C++ function implementations
            
            st.proto_only := false;
            idx := s.decls.begin;
	    while idx < s.decls.end {
                var ivyd := s.decls.value(idx);
                if (ivyd isa actdc) & s.decls.value(idx).emitted(st) {
                    var d : cpp.decl;
                    (d,st) := ivyd.to_cpp(st);
		    res.decls := res.decls.append(d);
                };
		idx := idx.next
	    }
            
            
	}

	import action show_prog(s:str)

        export action file_to_cpp(name:str) returns(res:str) = {

            # Read the program

            var ann : annot;
#            var p := prog.read_file(name,ann);
	    var p := prog.dec(name);

            # Flattening pass

            var fst : flatst;
            (p,fst) := p.flat(fst);

	    # Type inference pass

	    p := p.typeinfer;

	    call show_prog(p.enc);

            # Translation pass

            var cppexpr : cpp.prog;
            var st : tocppst;

            # Get the subtyping relation
            
            st.subtype_rel := p.get_subtypes;

            # Translate to C++

            (cppexpr,st) := p.to_cpp(st);

            # Pretty-print the C++

            res := cppexpr.enc
        }
    }

	

    object expr = { ...
        instantiate test_to_cpp(ivy.expr,cpp.expr)
    }
    
    object stmt = { ...
        instantiate test_to_cpp(ivy.stmt,cpp.stmt)
    }


}

