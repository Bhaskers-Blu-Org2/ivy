#lang ivy1.7

include syntax

# Common language traits between Ivy and C++
# ------------------------------------------
#
# This file contains a number of modules that are used in common
# between the Ivy and C++ languages.  Some of these modules have
# parameters that can vary the syntax, for example, by selecting
# the assignment or equality operator, or whether parentheses are
# required around the condition in an if/else statement.
#

# The type `priority` is used to represent the binding strength of
# operators, with stronger-binding operators having higher priority.
# For example, `*` has a higher priority that `+`. Priorities are used
# both to resolve ambiguous parses and to elide perenthese when
# printing.

type priority

# The `verb` type is an enumeration of the built-in symbols in the
# language.  This is used to avoid comparison of quoted strings
# representing the names of these symbols. Each verb also has a
# corresponding priority.  The verb corresponding to a symbol name is
# added as a meta-field to the symbol, in which case the string name
# can be empty (the value `none` is used for non-built-in symbols).
#
# - `str_to_verb` stores the map from string symbol names to verbs
# - `verb_to_str` is the inverse map
# - `verb_to_prio` gives the priority of a verb

# The verb `empty` represents the empty tuple, of type `unit`. Neither
# of these is available in the source lanuage, but they are used
# internally.

module verb_base = {
    object verb = {
        type this = { none, arrow, plus, times, colon, app, empty, dot }
    }
    
    function str_to_verb(X:str) : verb
    function verb_to_str(X:verb) : str
    function verb_to_prio(X:verb) : priority

    after init {
        str_to_verb(X) := verb.none
    }
}

module built_in (optok,vrb,opprio) = {
    after init {
        str_to_verb(optok) := vrb;
        verb_to_str(vrb) := optok; 
        verb_to_prio(vrb) := opprio
    }
}

module built_in_binary (optok,vrb,opprio) = {
    instantiate built_in(optok,vrb,opprio)

    action make(lhs:expr,rhs:expr,ann:annot) returns (res:expr) = {
        var s:app;
        s.func := symbol.makestr(optok,ann);
        s.args := s.args.append(lhs);
        s.args := s.args.append(rhs);
        s.ann := ann;
        res := s
    }

    action fold_left(args:vector[expr],ann:annot) returns (res:expr) = {
        if args.end > 0 {
            res := args.value(0);
            var idx := args.begin.next;
            while idx < args.end {
                res := make(res,args.value(idx),ann);
                idx := idx.next;
            }
        }
    }

}    

module built_in_const (optok,vrb) = {
    instantiate built_in(optok,vrb,0)

    action make(ann:annot) returns (res:expr) = {
        res := symbol.makestr(optok,ann);
    }
}
    
    
module genbinop(expr,arg) = {
    variant this of expr = struct {
	lhs : arg,
	rhs : arg,
        ann : annot
    }

    action make(x:arg,y:arg,ann:annot) returns (res:expr) = {
        var s:this;
        s.lhs := x;
        s.rhs := y;
        s.ann := ann;
        res := s;
    }
}

import action parse_error(p:pos,tok:str)

module parse_intf(expr) = {

    action encode(e:expr,b:pretty,prio:priority) returns (b:pretty)

    action enc(e:expr) returns (s:str) = {
        var p := pretty.make(15,4);
        p := e.encode(p,0);
        p := p.flush;
        s := p.output
    }

    action dec(s:str) returns (e:expr) = {
        var st := pstate.make(s);
        (st,e) := expr.parse(st,0);
        if ~st.ok | st.tok.end ~= 0 {
            call parse_error(st.ann.line,st.tok);
        }
    }

    action encdec(s:str) returns (res:str) = {
        var e := dec(s);
        res := enc(e)
    }
}



module expr_base(cppstyle) = {

    # Identifiers of type `ident` are use as names. They don't have
    # annotations, so they can be hashed and compared for equality.

    object ident = {
        type this
        action encode(s:this,b:pretty,prio:priority) returns (b:pretty)
        action to_str(s:this) returns (res:str)
        action get_namesp(s:this) returns (res:ident)
        action get_member(s:this) returns (res:str)
    }
    
    # String identifiers are used for all symbols occurring in the
    # source, including operators like `+` and `&`. 
        
    object strident = {
        variant this of ident = struct {
            val : str
        }
        action encode(s:this,b:pretty,prio:priority) returns (b:pretty) = {
            b := b.extend(s.val)
        }
        action make(val:str) returns (res:ident) = {
            var s : this;
            s.val := val;
            res := s
        }
        action to_str(s:this) returns (res:str) = {
            res := s.val
        }
    }

    # Numerical identifiers are used as temporaries internally. They
    # are printed as decimal number in brackets.

    object numident = {
        variant this of ident = struct {
            val : pos
        }
        action encode(s:this,b:pretty,prio:priority) returns (b:pretty) = {
            b := b.extend("[");
            b := b.extend(s.val.to_str);
            b := b.extend("]");
        }
        action make(val:pos) returns (res:ident) = {
            var s : this;
            s.val := val;
            res := s
        }
    }

    # Dotted identifiers are used to represent members of a namespace.
        
    object dotident = {
        variant this of ident = struct {
            namesp : ident,
            member : str
        }
        action encode(s:this,b:pretty,prio:priority) returns (b:pretty) = {
            b := s.namesp.encode(b,0);
            b := b.extend("::" if cppstyle else ".");
            b := b.extend(s.member)
        }
        action make(namesp:ident,member:str) returns (res:ident) = {
            var s : this;
            s.namesp := namesp;
            s.member := member;
            res := s
        }
        action to_str(s:this) returns (res:str) = {
            res := s.namesp.to_str;
            res := res.extend(".");
            res := res.extend(s.member);
        }
        action get_namesp(s:this) returns (res:ident) = {
            res := s.namesp;
        }
        action get_member(s:this) returns (res:str) = {
            res := s.member;
        }
    }

    object expr = {
        type this
        instantiate parse_intf(expr)
        action get_verb(s:this) returns (vrb:verb) = {
            vrb := verb.none;
        }
        action is(s:this,vrb:verb) returns (res:bool) = {
            res := false;
        }
        action get_arg(s:this,p:vector[expr].domain) returns (res:expr)
        action get_name(s:this) returns (res:ident)
        action app_verb(s:this) returns (res:verb)
        action get_ann(s:this) returns (res:annot)
    }

    object symbol = {
        variant this of expr = struct {
            name : ident,
            vrb : verb,
            ann : annot
        }
        action make(name:ident,ann:annot) returns (res:expr) = {
            var s:symbol;
            s.name := name;
            s.vrb := verb.none;
            s.ann := ann;
            res := s
        }
        action makestr(name:str,ann:annot) returns (res:expr) = {
            var s:symbol;
            s.name := strident.make(name);
            s.vrb := str_to_verb(name);
            s.ann := ann;
            res := s
        }
        action makenum(num:pos,ann:annot) returns (res:expr) = {
            var s:symbol;
            s.name := numident.make(num);
            s.vrb := verb.none;
            s.ann := ann;
            res := s
        }
        action encode(s:symbol,b:pretty,prio:priority) returns (b:pretty) = {
            b := s.ann.encode(b);
            b := s.name.encode(b,0);
        }
        action parse(st : pstate) returns(st : pstate, res:expr) = {
            if st.ok & st.tok.end ~= 0 {
                var s : symbol;
                s.name := strident.make(st.tok);
                (st,s.ann) := st.get_ann;
                res := s;
                st := st.consume;
            }
            else {
                st.ok := false;
            }
        }
        action get_verb(s:symbol) returns (res:verb) = {
            res := s.vrb;
        }
        action get_name(s:this) returns (res:ident) = {
            res := s.name
        }
        action get_ann(s:this) returns (res:annot) = {
            res := s.ann
        }
    }

    object app = {
        variant this of expr = struct {
            func : expr,
            args : vector[expr],
            ann : annot
        }
        action make(func:expr,args:vector[expr],ann:annot) returns (res:expr) = {
            var s:app;
            s.func := func;
            s.args := args;
            s.ann := ann;
            res := s
        }
        action make1(func:expr,arg0:expr,ann:annot) returns (res:expr) = {
            var s:app;
            s.func := func;
            s.args := s.args.append(arg0);
            s.ann := ann;
            res := s
        }
        action make2(func:expr,arg0:expr,arg1:expr,ann:annot) returns (res:expr) = {
            var s:app;
            s.func := func;
            s.args := s.args.append(arg0);
            s.args := s.args.append(arg1);
            s.ann := ann;
            res := s
        }
        action encode(s:this,b:pretty,prio:priority) returns (b:pretty) = {
            b := s.ann.encode(b);
            var vrb := s.func.get_verb;
            if vrb ~= verb.none {
                var opprio := verb_to_prio(vrb);
                if opprio < prio {
                    b := b.nest;
                    b := b.extend("(");
                };	    
                b := s.args.value(0).encode(b,opprio);
                b := b.extend(" ");
                b := b.extend(verb_to_str(vrb));
                b := b.extend(" ");
                b := s.args.value(1).encode(b,opprio+1);
                if opprio < prio {
                    b := b.extend(")");
                    b := b.unnest
                }
            } else {
                b := b.nest;
                b := s.func.encode(b,99);
                b := expr.tup.encode(s.args,b,0);
                b := b.unnest;
            }
        }
        action is(s:this,vrb:verb) returns (res:bool) = {
            res := s.func.get_verb = vrb;
        }
        action app_verb(s:this) returns (res:verb) = {
            res := s.func.get_verb
        }
        action get_arg(s:this,p:vector[expr].domain) returns (res:expr) = {
            res := s.args.value(p)
        }
        action get_ann(s:this) returns (res:annot) = {
            res := s.ann
        }
    }

    # Variables are used internally as placeholders but
    # are not intended to be parsed or printed out.

    object variable = {
        variant this of expr = struct {
            idx : pos,
            ann : annot
        }
        
        action make(idx:pos) returns (res:expr) = {
            var s:this;
            s.idx := idx;
            res := s
        }
    }
    
    object pi = {
        variant this of expr = struct {
            vars : vector[expr],
            body : expr,
	    ann : annot
        }

        action make (vars:vector[expr], body:expr,ann:annot) returns (res:expr) = {
            var s:this;
            s.vars := vars;
            s.ann := ann;
            res := s;
        }

        action encode(s:this,b:pretty,prio:priority) returns (b:pretty) = {
            b := s.ann.encode(b);
            b := b.nest;
            b := b.extend("pi");
            b := b.extend(" ");
            b := expr.tup.encode(s.vars,b,0);
            b := b.extend(".");
            b := b.extend(" ");
            b := s.body.encode(b,0);
            b := b.extend(";");
            b := b.unnest;
        }
        
    }

    instance arrow : built_in_binary("->",verb.arrow,5)
    instance plus : built_in_binary("+",verb.plus,10)
    instance times : built_in_binary("*",verb.times,11)
    instance empty : built_in_const("()",verb.empty)

    # Treat open paren as a builtin operator for function application. The
    # real operator is the empty string, but open paren will work.

    instantiate built_in("(",verb.app,99)        

    object expr = { ...

        var foo : vector[expr]  # workaround

        action parse(st : pstate, prio:priority) returns(st : pstate, res:expr) = {
            if st.tok = "(" {
                st := st.consume;
                (st,res) := parse(st,0);
                if st.ok & st.tok = ")" {
                    st := st.consume;
                } else {
                    st.ok := false;
                }
            } else {
                (st,res) := symbol.parse(st);
            };
            var vrb := str_to_verb(st.tok);
            while st.ok & vrb ~= verb.none & prio < verb_to_prio(vrb) {
                var s : app;
                (st,s.ann) := st.get_ann;
                if vrb = verb.app {
                    s.func := res;
                    (st,s.args) := tup.parse(st,0);
                } else {
                    s.func := symbol.makestr(st.tok,s.ann);
                    st := st.consume;
                    s.args := s.args.append(res);
                    var arg : expr;
                    (st,arg) := parse(st,verb_to_prio(vrb));
                    s.args := s.args.append(arg);
                };
                res := s;
                vrb := str_to_verb(st.tok);
            }
        }

        instance tup : tuple(expr,"(",")",verb)
    }
}

module generic_stmt_encode(stmt_prio) = {
    action encode(s:this,b:pretty,prio:priority) returns (b:pretty) = {
        b := s.ann.encode(b);
        if stmt_prio < prio {
            b := b.nest;
            b := b.extend("{");
            b := b.newline;
        };	    
        b := s.encode_int(b,prio);
        if stmt_prio < prio {
            b := b.unnest;
            b := b.newline;
            b := b.extend("}");
        }	    
    }
}

module stmt_base(expr,asgntok,cppstyle) = {

    object stmt = {
        type this
        instantiate parse_intf(stmt)
    }

    object asgn = {
        instantiate genbinop(stmt,expr)
        instantiate generic_stmt_encode(1)

        action encode_int(s:this,b:pretty,prio:priority) returns (b:pretty) = {
            b := b.nest;
            if s.lhs.get_verb ~= verb.empty {
                b := s.lhs.encode(b,0);
                b := b.extend(" ");
                b := b.extend(asgntok);
                b := b.extend(" ");
            };
            b := s.rhs.encode(b,0);
            b := b.extend(";");
            b := b.unnest;
        }
    }

    object sequence = {
        instantiate genbinop(stmt,stmt)
        instantiate generic_stmt_encode(0)

        action encode_int(s:this,b:pretty,prio:priority) returns (b:pretty) = {
            b := s.lhs.encode(b,1);
            b := b.newline;
            b := s.rhs.encode(b,0);
        }
    }

    object skipst = {
        variant this of stmt = struct {
            ann : annot
        }

        action make (ann:annot) returns (res:stmt) = {
            var s:this;
            s.ann := ann;
            res := s;
        }

        action encode(s:this,b:pretty,prio:priority) returns (b:pretty) = {
            b := s.ann.encode(b);
            b := b.extend("{");
            b := b.extend("}")
        }
    }


    object ifst = {
        variant this of stmt = struct {
            cond : expr,
            thenst : stmt,
            elsest : stmt,
            ann : annot
        }

        instantiate generic_stmt_encode(1)

        action make(cond:expr,thenst:stmt,elsest:stmt,ann:annot) returns (res:stmt) = {
            var s:this;
            s.cond := cond;
            s.thenst := elsest;
            s.elsest := elsest;
            s.ann := ann;
            res := s;
        }

        action encode_int(s:this,b:pretty,prio:priority) returns (b:pretty) = {
            b := b.extend("if");
            b := b.extend(" ");
            if cppstyle {
                b := b.extend("(");
            };
            b := s.cond.encode(b,0);
            if cppstyle {
                b := b.extend(")");
            };
            b := b.extend(" ");
            b := s.thenst.encode(b,2);
            if ~(s.elsest isa skipst) {
                b := b.extend(" ");
                b := b.extend("else");
                b := b.extend(" ");
                b := s.elsest.encode(b,2);
            };
        }
    }

    object stmt = { ...
        action parse(st : pstate, prio:priority) returns(st : pstate, res:stmt) = {
            while st.tok = ";" {
                st := st.consume;
            };
            if st.tok = "{" {
                st := st.consume;
                (st,res) := parse(st,0);
                if st.ok & st.tok = "}" {
                    st := st.consume;
                } else {
                    st.ok := false;
                }
            } else if st.tok = "if" {
                st := st.consume;
                var s : ifst;
                (st,s.ann) := st.get_ann;
                (st,s.cond) := expr.parse(st,0);
                if st.ok & st.tok = "{" {
                    (st,s.thenst) := stmt.parse(st,1);
                    if st.ok & st.tok = "else" {
                        st := st.consume;
                        if st.ok & (st.tok = "{" | st.tok = "if") {
                            (st,s.elsest) := stmt.parse(st,1);
                        } else {
                            st.ok := false;
                        }
                    } else {
                        var ann : annot; # missing else doesn't print, so don't annotate
                        s.elsest := skipst.make(ann)
                    }
                }
                else {
                    st.ok := false;
                };
                res := s;
            } else if st.tok = "}" {
                var ann : annot;
                (st,ann) := st.get_ann;
                res := skipst.make(ann);
            } else {
                (st,res) := stmt.parse_lang_stmt(st,prio);
            };
            if st.ok & prio = 0 & st.tok.end > 0 & st.tok ~= "}" {
                var sq : sequence;
                sq.lhs := res;
                (st,sq.rhs) := stmt.parse(st,0);
                res := sq;
            }
        }
    }
}

module decl_base(expr,stmt) = {
    object decl = {
        type this
        instantiate parse_intf(decl)
    }

    object actdc = {
        variant this of decl = struct {
            name : expr,
            inputs : vector[expr],
            outputs : vector[expr],
            has_body : bool,
            body : stmt,
            ann : annot
        }

        action make(name : expr, inputs : vector[expr], outputs : vector[expr], has_body:bool,
                    body : stmt)
            returns (res:decl) =
        {
            var s:this;
            s.name := name;
            s.inputs := inputs;
            s.outputs := outputs;
            s.has_body := has_body;
            s.body := body;
            res := s;
        }

        action encode(s:this,b:pretty,prio:priority) returns (b:pretty) = {
            b := s.ann.encode(b);
            b := b.nest;
            b := b.extend("action");
            b := b.extend(" ");
            b := s.name.encode(b,0);
            b := expr.tup.encode(s.inputs,b,prio);
            if s.outputs.end > 0 {
                b := b.extend(" ");
                b := b.extend("returns");
                b := expr.tup.encode(s.outputs,b,prio);
            };
            b := b.unnest;
            if s.has_body {
                b := b.extend(" ");
                b := b.extend("=");
                b := b.extend(" ");
                b := s.body.encode(b,2);
            }
        }

        # A member is a action of the form `action type.member(x:type,...)`

        action is_member(s:this) returns (res:bool) = {
            res := s.name.get_name isa dotident
            & s.inputs.end > 0
            & s.member_type = s.name.get_name.get_namesp;
        }

        # If this is a member action, return the type it is a member of.

        action member_type(s:this) returns (res:ident) = {
            res := s.inputs.value(0).get_arg(1).get_name;
        }

    }
}
    
module prog_base = {
    object prog = {
    type this = struct {
		decls : vector[decl]
	    }
	instantiate parse_intf(this)

	action make(decls : vector[decl]) returns (res:prog) =
	{
	    var s:this;
	    s.decls := decls;
	    res := s;
	}

	implement encode(s:this,b:pretty,prio:priority) returns (b:pretty)  {
	    var idx := s.decls.begin;
	    while idx < s.decls.end {
		b := b.newline;
		b := s.decls.value(idx).encode(b,0);
		idx := idx.next;
	    };
	}	    

	action parse(st : pstate, prio:priority) returns(st : pstate, res:prog) = {
	    while st.ok & st.tok.end > 0 {
		var dcl : decl;
		(st,dcl) := decl.parse(st,0);
		res.decls := res.decls.append(dcl);
	    }
	}
    }
}

