#lang ivy1.7

include syntax

# Common language traits between Ivy and C++
# ------------------------------------------
#
# This file contains a number of modules that are used in common
# between the Ivy and C++ languages.  Some of these modules have
# parameters that can vary the syntax, for example, by selecting
# the assignment or equality operator, or whether parentheses are
# required around the condition in an if/else statement.
#

# The type `priority` is used to represent the binding strength of
# operators, with stronger-binding operators having higher priority.
# For example, `*` has a higher priority that `+`. Priorities are used
# both to resolve ambiguous parses and to elide perenthese when
# printing.

type priority

# The `verb` type is an enumeration of the built-in symbols in the
# language.  This is used to avoid comparison of quoted strings
# representing the names of these symbols. Each verb also has a
# corresponding priority.  The verb corresponding to a symbol name is
# added as a meta-field to the symbol, in which case the string name
# can be empty (the value `none` is used for non-built-in symbols).
#
# - `str_to_verb` stores the map from string symbol names to verbs
# - `verb_to_str` is the inverse map
# - `verb_to_prio` gives the priority of a verb

module verb_base = {
    object verb = {
        type this = { none, arrow, plus, times, colon, app }
    }
    
    function str_to_verb(X:str) : verb
    function verb_to_str(X:verb) : str
    function verb_to_prio(X:verb) : priority

    after init {
        str_to_verb(X) := verb.none
    }
}

module built_in (optok,vrb,opprio) = {
    after init {
        str_to_verb(optok) := vrb;
        verb_to_str(vrb) := optok; 
        verb_to_prio(vrb) := opprio
    }
}

module built_in_binary (optok,vrb,opprio) = {
    instantiate built_in(optok,vrb,opprio)

    action make(lhs:expr,rhs:expr,ann:annot) returns (res:expr) = {
        var s:app;
        s.func := symbol.make(optok,ann);
        s.args := s.args.append(lhs);
        s.args := s.args.append(rhs);
        s.ann := ann;
        res := s
    }

}    

module genbinop(expr,arg) = {
    variant this of expr = struct {
	lhs : arg,
	rhs : arg,
        ann : annot
    }

    action make(x:arg,y:arg,ann:annot) returns (res:expr) = {
        var s:this;
        s.lhs := x;
        s.rhs := y;
        s.ann := ann;
        res := s;
    }
}

import action parse_error(p:pos,tok:str)

module parse_intf(expr) = {

    action encode(e:expr,b:pretty,prio:priority) returns (b:pretty)

    action enc(e:expr) returns (s:str) = {
        var p := pretty.make(15,4);
        p := e.encode(p,0);
        p := p.flush;
        s := p.output
    }

    action dec(s:str) returns (e:expr) = {
        var st := pstate.make(s);
        (st,e) := expr.parse(st,0);
        if ~st.ok | st.tok.end ~= 0 {
            call parse_error(st.ann.line,st.tok);
        }
    }

    action encdec(s:str) returns (res:str) = {
        var e := dec(s);
        res := enc(e)
    }
}


module expr_base = {

    object expr = {
        type this
        instantiate parse_intf(expr)
        action get_verb(s:this) returns (vrb:verb) = {
            vrb := verb.none;
        }
        action is(s:this,vrb:verb) returns (res:bool) = {
            res := false;
        }
    }

    object symbol = {
        variant this of expr = struct {
            name : str,
            vrb : verb,
            ann : annot
        }
        action make(name:str,ann:annot) returns (res:expr) = {
            var s:symbol;
            s.name := name;
            s.vrb := str_to_verb(name);
            s.ann := ann;
            res := s
        }
        action encode(s:symbol,b:pretty,prio:priority) returns (b:pretty) = {
            b := s.ann.encode(b);
            b := s.name.encode(b);
        }
        action parse(st : pstate) returns(st : pstate, res:expr) = {
            if st.ok & st.tok.end ~= 0 {
                var s : symbol;
                s.name := st.tok;
                (st,s.ann) := st.get_ann;
                res := s;
                st := st.consume;
            }
            else {
                st.ok := false;
            }
        }
        action get_verb(s:symbol) returns (res:verb) = {
            res := s.vrb;
        }
    }

    object app = {
        variant this of expr = struct {
            func : expr,
            args : vector[expr],
            ann : annot
        }
        action make(func:expr,args:vector[expr],ann:annot) returns (res:expr) = {
            var s:app;
            s.func := func;
            s.args := args;
            s.ann := ann;
            res := s
        }
        action encode(s:this,b:pretty,prio:priority) returns (b:pretty) = {
            b := s.ann.encode(b);
            var vrb := s.func.get_verb;
            if vrb ~= verb.none {
                var opprio := verb_to_prio(vrb);
                if opprio < prio {
                    b := b.nest;
                    b := b.extend("(");
                };	    
                b := s.args.value(0).encode(b,opprio);
                b := b.extend(" ");
                b := b.extend(verb_to_str(vrb));
                b := b.extend(" ");
                b := s.args.value(1).encode(b,opprio+1);
                if opprio < prio {
                    b := b.extend(")");
                    b := b.unnest
                }
            } else {
                b := b.nest;
                b := s.func.encode(b,99);
                b := expr.tup.encode(s.args,b,0);
                b := b.unnest;
            }
        }
        action is(s:this,vrb:verb) returns (res:bool) = {
            res := s.func.get_verb = vrb;
        }
    }

    # Variables are used internally as placeholders but
    # are not intended to be parsed or printed out.

    object variable = {
        variant this of expr = struct {
            idx : pos,
            ann : annot
        }
        
        action make(idx:pos) returns (res:expr) = {
            var s:this;
            s.idx := idx;
            res := s
        }
    }
    
    object pi = {
        variant this of expr = struct {
            vars : vector[expr],
            body : expr
        }

        action make (vars:vector[expr], body:expr,ann:annot) returns (res:stmt) = {
            var s:this;
            s.vars := vars;
            s.ann := ann;
            res := s;
        }

        action encode(s:this,b:pretty,prio:priority) returns (b:pretty) = {
            b := s.ann.encode(b);
            b := b.nest;
            b := b.extend("pi");
            b := b.extend(" ");
            b := expr.tup.encode(s.vars,b,0);
            b := b.extend(".");
            b := b.extend(" ");
            b := s.body.encode(b,0);
            b := b.extend(";");
            b := b.unnest;
        }
        
    }

    instance arrow : built_in_binary("->",verb.arrow,5)
    instance plus : built_in_binary("+",verb.plus,10)
    instance times : built_in_binary("*",verb.times,11)

    # Treat '(' as a builtin operator for function application. The
    # real operator is '', but '(' will work.

    instantiate built_in("(",verb.app,99)        

    object expr = { ...

        var foo : vector[expr]  # workaround

        action parse(st : pstate, prio:priority) returns(st : pstate, res:expr) = {
            if st.tok = "(" {
                st := st.consume;
                (st,res) := parse(st,0);
                if st.ok & st.tok = ")" {
                    st := st.consume;
                } else {
                    st.ok := false;
                }
            } else {
                (st,res) := symbol.parse(st);
            };
            var vrb := str_to_verb(st.tok);
            while st.ok & vrb ~= verb.none & prio < verb_to_prio(vrb) {
                var s : app;
                (st,s.ann) := st.get_ann;
                if vrb = verb.app {
                    s.func := res;
                    (st,s.args) := tup.parse(st,0);
                } else {
                    s.func := symbol.make(st.tok,s.ann);
                    st := st.consume;
                    s.args := s.args.append(res);
                    var arg : expr;
                    (st,arg) := parse(st,verb_to_prio(vrb));
                    s.args := s.args.append(arg);
                };
                res := s;
                vrb := str_to_verb(st.tok);
            }
        }

        instance tup : tuple(expr,"(",")",verb)
    }
}

module generic_stmt_encode(stmt_prio) = {
    action encode(s:this,b:pretty,prio:priority) returns (b:pretty) = {
        b := s.ann.encode(b);
        if stmt_prio < prio {
            b := b.nest;
            b := b.extend("{");
            b := b.newline;
        };	    
        b := s.encode_int(b,prio);
        if stmt_prio < prio {
            b := b.unnest;
            b := b.newline;
            b := b.extend("}");
        }	    
    }
}

module stmt_base(expr,asgntok,cppstyle) = {

    object stmt = {
        type this
        instantiate parse_intf(stmt)
    }

    object asgn = {
        instantiate genbinop(stmt,expr)
        instantiate generic_stmt_encode(1)

        action encode_int(s:this,b:pretty,prio:priority) returns (b:pretty) = {
            b := b.nest;
            b := s.lhs.encode(b,0);
            b := b.extend(" ");
            b := b.extend(asgntok);
            b := b.extend(" ");
            b := s.rhs.encode(b,0);
            b := b.extend(";");
            b := b.unnest;
        }
    }

    object sequence = {
        instantiate genbinop(stmt,stmt)
        instantiate generic_stmt_encode(0)

        action encode_int(s:this,b:pretty,prio:priority) returns (b:pretty) = {
            b := s.lhs.encode(b,1);
            b := b.newline;
            b := s.rhs.encode(b,0);
        }
    }

    object skipst = {
        variant this of stmt = struct {
            ann : annot
        }

        action make (ann:annot) returns (res:stmt) = {
            var s:this;
            s.ann := ann;
            res := s;
        }

        action encode(s:this,b:pretty,prio:priority) returns (b:pretty) = {
            b := s.ann.encode(b);
            b := b.extend("{");
            b := b.extend("}")
        }
    }


    object ifst = {
        variant this of stmt = struct {
            cond : expr,
            thenst : stmt,
            elsest : stmt,
            ann : annot
        }

        instantiate generic_stmt_encode(1)

        action make(cond:expr,thenst:stmt,elsest:stmt,ann:annot) returns (res:stmt) = {
            var s:this;
            s.cond := cond;
            s.thenst := elsest;
            s.elsest := elsest;
            s.ann := ann;
            res := s;
        }

        action encode_int(s:this,b:pretty,prio:priority) returns (b:pretty) = {
            b := b.extend("if");
            b := b.extend(" ");
            if cppstyle {
                b := b.extend("(");
            };
            b := s.cond.encode(b,0);
            if cppstyle {
                b := b.extend(")");
            };
            b := b.extend(" ");
            b := s.thenst.encode(b,2);
            if ~(s.elsest isa skipst) {
                b := b.extend(" ");
                b := b.extend("else");
                b := b.extend(" ");
                b := s.elsest.encode(b,2);
            };
        }
    }

    object stmt = { ...
        action parse(st : pstate, prio:priority) returns(st : pstate, res:stmt) = {
            while st.tok = ";" {
                st := st.consume;
            };
            if st.tok = "{" {
                st := st.consume;
                (st,res) := parse(st,0);
                if st.ok & st.tok = "}" {
                    st := st.consume;
                } else {
                    st.ok := false;
                }
            } else if st.tok = "if" {
                st := st.consume;
                var s : ifst;
                (st,s.ann) := st.get_ann;
                (st,s.cond) := expr.parse(st,0);
                if st.ok & st.tok = "{" {
                    (st,s.thenst) := stmt.parse(st,1);
                    if st.ok & st.tok = "else" {
                        st := st.consume;
                        if st.ok & (st.tok = "{" | st.tok = "if") {
                            (st,s.elsest) := stmt.parse(st,1);
                        } else {
                            st.ok := false;
                        }
                    } else {
                        var ann : annot; # missing else doesn't print, so don't annotate
                        s.elsest := skipst.make(ann)
                    }
                }
                else {
                    st.ok := false;
                };
                res := s;
            } else if st.tok = "}" {
                var ann : annot;
                (st,ann) := st.get_ann;
                res := skipst.make(ann);
            } else {
                (st,res) := stmt.parse_lang_stmt(st,prio);
            };
            if st.ok & prio = 0 & st.tok.end > 0 & st.tok ~= "}" {
                var sq : sequence;
                sq.lhs := res;
                (st,sq.rhs) := stmt.parse(st,0);
                res := sq;
            }
        }
    }
}

module decl_base(expr,stmt) = {
    object decl = {
        type this
        instantiate parse_intf(decl)
    }

    object actdc = {
        variant this of decl = struct {
            name : expr,
            inputs : vector[expr],
            outputs : vector[expr],
            body : stmt,
            ann : annot
        }

        action make(name : expr,inputs : vector[expr],outputs : vector[expr],body : stmt)
            returns (res:decl) =
        {
            var s:this;
            s.name := name;
            s.inputs := inputs;
            s.outputs := outputs;
            s.body := body;
            res := s;
        }

        action encode(s:this,b:pretty,prio:priority) returns (b:pretty) = {
            b := s.ann.encode(b);
            b := b.nest;
            b := b.extend("action");
            b := b.extend(" ");
            b := s.name.encode(b,0);
            b := expr.tup.encode(s.inputs,b,prio);
            if s.outputs.end > 0 {
                b := b.extend(" ");
                b := b.extend("returns");
                b := expr.tup.encode(s.outputs,b,prio);
            };
            b := b.unnest;
            b := b.extend(" ");
            b := b.extend("=");
            b := b.extend(" ");
            b := s.body.encode(b,2);
        }
    }
}
