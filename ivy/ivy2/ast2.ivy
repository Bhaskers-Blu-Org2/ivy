#lang ivy1.7

include order
include string
include collections

instance pos : unbounded_sequence

object char = {
    type this
    type kinds = {alphanum,bracket,other}
    function is_alphanum(X:char) = (48 <= X & X < 58) | (65 <= X & X < 91) | (97 <= X & X < 123)
    function is_bracket(X:char) = (X = 40 | X = 41 | X = 91 | X = 93 | X = 123 | X = 125)
    function kind(X:char) = alphanum if is_alphanum(X:char)
                            else (bracket if is_bracket(X) else other)
}
    
instance str : string(pos,char)

object pretty = {

    type token = struct {
	pair : bool,
        tdepth : pos,
	first : str,
	second : pos
    }

    var foo : vector[token]

    type state = struct {
	begin : vector[token].domain,
	total : pos
    }
    

    type this = struct {
        tokens : vector[token],
	st : state,
        maxline : pos,
	indent : pos,
	whitespace : str,
	states : vector[state],
	stack : vector[pos],
	output : str,
	space : pos,
        depth : pos
    }
    
    action make(maxline:pos,indent:pos) returns (res:this) = {
	res.maxline := maxline;
	res.indent := indent;
	res.whitespace := " ";
	res.space := maxline;
	res.stack := res.stack.append(maxline);
    }

    action do_indent (self:this) returns (self:this) = {
	self.output := self.output.append(10);  # newline
	self.output := self.output.resize(self.output.end+(self.maxline-self.space),32);  # spaces
    }

    action print (self:this,tok:token) returns (self:this) = {
	if tok.pair {
	    if tok.second <= self.space | self.space = self.maxline {
                self.output := self.output.extend(tok.first);
                self.space := self.space - tok.first.end
	    } else {
                self.space := self.maxline - tok.tdepth * self.indent;
                self := self.do_indent
	    }
	} else {
            self.output := self.output.extend(tok.first);
            self.space := self.space - tok.first.end
	}
    }

    action print_tokens (self:this) returns (self:this) = {
	var idx := self.tokens.begin;
	while idx < self.tokens.end {
	    self := self.print(self.tokens.value(idx));
	    idx := idx.next
	};
	self.tokens := vector[token].empty;
    }

    action add_length(self:this, len:pos, at:vector[token].domain) returns (self:this) = {
        if at > self.st.begin {
            var prev := self.tokens.value(at.prev);
            if prev.pair {
		var newtok := prev;
		newtok.second := newtok.second + len;
                self.tokens := self.tokens.set(at.prev,newtok)
	    }
	};
    }
	
    action extend(self:this, string:str) returns (self:this) = {
	var tok : token;
	tok.pair := false;
        tok.tdepth := self.depth;
	tok.first := string;
	if true & string = self.whitespace {   # true = breakable
	    tok.pair := true;
	    tok.second := string.end;
	} else {
	    self := add_length(self,string.end,self.tokens.end)
	};
        self.tokens := self.tokens.append(tok);
	self.st.total := self.st.total + string.end
    }    

    action newline(self:this) returns (self:this) = {
	var tok : token;
	tok.pair := true;
        tok.tdepth := self.depth;
        tok.second := self.maxline + 1;
        self.tokens := self.tokens.append(tok);
    }        
        

    action nest(self:this) returns (self:this) = {
        self.stack := self.stack.append(self.space);
	self.states := self.states.append(self.st);
        self.st.total := 0;
	self.st.begin := self.tokens.end;
        self.depth := self.depth + 1
    }

    action unnest(self:this) returns (self:this) = {
	var oldst := self.st;
	# Tricky: don't count any terminal white space in length of scope
#	if self.tokens.end > oldst.begin & self.tokens.back.pair {
#	    oldst.total := oldst.total - self.tokens.back.second;
#            self.tokens.end > oldst.begin & self.tokens.back.pair
#	};
	self.stack := self.stack.pop_back;
	self.st := self.states.back;
	self.states := self.states.pop_back;
	self := self.add_length(oldst.total,oldst.begin);
	self.st.total := self.st.total + oldst.total;
        self.depth := self.depth - 1
    }

}

object str = { ...
    action encode(s:this,b:pretty) returns (b:pretty) = {
	b := b.extend(s)
    }    
}

action lex(b:str,p:pos) returns (tok:str,p:pos) = {
    while p < b.end & b.value(p) = 32 {
	p := p.next
    };
    var start := p;
    var last : char := 32;
    while p < b.end & b.value(p) ~= 32 & (last = 32 | (char.kind(b.value(p)) = char.kind(last))) & char.kind(last) ~= char.bracket {
	last := b.value(p);
	p := p.next;
    };
    tok := b.segment(start,p);
}

object pstate = {
    type this = struct {
	b:str,
	p:pos,
	tok:str,
	ok:bool
    }
    action consume(st:pstate) returns(st:pstate) = {
	(st.tok,st.p) := lex(st.b,st.p);
    }	
}

action start_state(s:str) returns (st:pstate) = {
    st.b := s;
    st.p := s.begin;
    st.ok := true;
}

type verb
function str_to_verb(X:str) : verb
function verb_to_prio(X:verb) : verb

after init {
    str_to_verb(X) := 0
}


module genbinop(expr,arg) = {
    variant this of expr = struct {
	lhs : arg,
	rhs : arg
    }

    action make(x:arg,y:arg) returns (res:expr) = {
        var s:this;
        s.lhs := x;
        s.rhs := y;
        res := s;
    }
}

module binop (expr,optok,vrb,prio) = {

    instantiate genbinop(expr,expr)
    
    after init {
        str_to_verb(optok) := vrb;
        verb_to_prio(vrb) := prio
    }

    action encode(s:this,b:pretty,prio:verb) returns (b:pretty) = {
	if vrb < prio {
	    b := b.nest;
	    b := b.extend("(");
	};	    
	b := s.lhs.encode(b,vrb);
	b := b.extend(" ");
	b := b.extend(optok);
	b := b.extend(" ");
	b := s.rhs.encode(b,vrb+1);
	if vrb < prio {
	    b := b.extend(")");
	    b := b.unnest
	}	    
    }
}

module parse_intf(expr) = {

    action encode(e:expr,b:pretty,prio:verb) returns (b:pretty)

    action enc(e:expr) returns (s:str) = {
        var p := pretty.make(15,4);
        p := e.encode(p,0);
        p := p.print_tokens;
        s := p.output
    }

    action dec(s:str) returns (e:expr) = {
        var st := start_state(s);
        st := st.consume;
        (st,e) := expr.parse(st,0);
        if ~st.ok | st.tok.end ~= 0 {
            call parse_error(st.p,st.tok);
        }
    }

    action encdec(s:str) returns (res:str) = {
        var e := dec(s);
        res := enc(e)
    }
}


object expr = {
    type this
    instantiate parse_intf(expr)
}

    
object symbol = {
    variant this of expr = struct {
	name : str
    }
    action make(name:str) returns (res:expr) = {
        var s:symbol;
        s.name := name;
        res := s
    }
    action encode(s:symbol,b:pretty,prio:verb) returns (b:pretty) = {
	b := s.name.encode(b);
    }
    action parse(st : pstate) returns(st : pstate, res:expr) = {
        if st.ok & st.tok.end ~= 0 {
	    var s : symbol;
	    s.name := st.tok;
	    res := s;
	    st := st.consume;
        }
        else {
	    st.ok := false;
        }
    }
}


instance plus : binop(expr,"+",1,1)
instance times : binop(expr,"*",2,2)


object expr = { ...

    action parse(st : pstate, prio:verb) returns(st : pstate, res:expr) = {
        if st.tok = "(" {
            st := st.consume;
            (st,res) := parse(st,0);
            if st.ok & st.tok = ")" {
                st := st.consume;
            } else {
                st.ok := false;
            }
        } else {
            (st,res) := symbol.parse(st);
        };
        var vrb := str_to_verb(st.tok);
        while st.ok & vrb > 0 & prio < verb_to_prio(vrb) {
            st := st.consume;
            var arg : expr;
            (st,arg) := parse(st,vrb);
            if st.ok {
                if vrb = 1 {
                    res := plus.make(res,arg);
                }
                else if vrb = 2 {
                    res := times.make(res,arg);
                }                
            };
            vrb := str_to_verb(st.tok);
        }
    }
}



object stmt = {
    type this
    instantiate parse_intf(stmt)
}

object asgn = {
    instantiate genbinop(stmt,expr)

    action encode(s:this,b:pretty,prio:verb) returns (b:pretty) = {
        b := b.nest;
	b := s.lhs.encode(b,0);
	b := b.extend(" ");
	b := b.extend(":=");
	b := b.extend(" ");
	b := s.rhs.encode(b,0);
	b := b.extend(";");
        b := b.unnest;
    }
}

object sequence = {
    instantiate genbinop(stmt,stmt)

    action encode(s:this,b:pretty,prio:verb) returns (b:pretty) = {
	if 0 < prio {
	    b := b.nest;
	    b := b.extend("{");
            b := b.newline;
	};	    
	b := s.lhs.encode(b,1);
        b := b.newline;
#	b := b.extend(" ");
	b := s.rhs.encode(b,0);
	if 0 < prio {
	    b := b.unnest;
            b := b.newline;
	    b := b.extend("}");
	}	    
    }
}

object stmt = { ...
    action parse(st : pstate, prio:verb) returns(st : pstate, res:stmt) = {
        if st.tok = "{" {
            st := st.consume;
            (st,res) := parse(st,0);
            if st.ok & st.tok = "}" {
                st := st.consume;
            } else {
                st.ok := false;
            }
        } else {
            var s : asgn;
            (st,s.lhs) := expr.parse(st,3);
            if st.ok & st.tok = ":=" {
                st := st.consume;
                (st,s.rhs) := expr.parse(st,0);
                if st.ok & st.tok = ";" {
                    st := st.consume;
                } else {
                    st.ok := st.tok = "}";  # allow to omit final semicolon
                }
            } else {
                st.ok := false;
            };
            res := s;
        };
        if st.ok & st.tok.end > 0 & st.tok ~= "}" {
            var sq : sequence;
            sq.lhs := res;
            (st,sq.rhs) := stmt.parse(st,0);
            res := sq;
        }
    }
}



action parse_error(p:pos,tok:str)

export expr.enc
export expr.dec
export expr.encdec
export stmt.enc
export stmt.dec
export stmt.encdec
import parse_error


export pretty.make
export pretty.extend
export pretty.print_tokens

action pr(max:pos,s:str) returns (res:str) = {
    var p := pretty.make(max,4);
    var st := start_state(s);
    st := st.consume;
    while st.tok.end > 0 {
	if st.tok = "(" {
	    p := p.nest
	};
	p := p.extend(st.tok);
	if st.tok = ")" {
	    p := p.unnest
	};
#	call show_pretty(p);
	if st.b.value(st.p) = 32 {
	    p := p.extend(" ");
#	    call show_pretty(p);
	};
	st := st.consume
    };

    p := p.print_tokens;
    res := p.output
}

export pr

# after init {

#     var p := pretty.make(11,4);
#     var st := start_state("fooooooo + (bar + baaaaaz)");
#     st := st.consume;
#     while st.tok.end > 0 {
# 	if st.tok = "(" {
# 	    p := p.nest
# 	};
# 	p := p.extend(st.tok);
# 	if st.tok = ")" {
# 	    p := p.unnest
# 	};
# 	call show_pretty(p);
# 	if st.b.value(st.p) = 32 {
# 	    p := p.extend(" ");
# 	    call show_pretty(p);
# 	};
# 	st := st.consume
#     };

#     p := p.print_tokens;
#     call show_pretty(p);
    
# }

import action show_pretty(p:pretty)
