#lang ivy1.7

include order
include string
include collections

instance pos : unbounded_sequence

object char = {
    type this
    type kinds = {alphanum,bracket,other}
    function is_alphanum(X:char) = (48 <= X & X < 58) | (65 <= X & X < 91) | (97 <= X & X < 123)
    function kind(X:char) = alphanum if is_alphanum(X:char)
                            else (bracket if (X = 40 | X = 41) else other)
}
    
instance str : string(pos,char)

object pretty = {

    type token = struct {
	pair : bool,
        tdepth : pos,
	first : str,
	second : pos
    }

    var foo : vector[token]

    type state = struct {
	begin : vector[token].domain,
	total : pos
    }
    

    type this = struct {
        tokens : vector[token],
	st : state,
        maxline : pos,
	indent : pos,
	whitespace : str,
	states : vector[state],
	stack : vector[pos],
	output : str,
	space : pos,
        depth : pos
    }
    
    action make(maxline:pos,indent:pos) returns (res:this) = {
	res.maxline := maxline;
	res.indent := indent;
	res.whitespace := " ";
	res.space := maxline;
	res.stack := res.stack.append(maxline);
    }

    action do_indent (self:this) returns (self:this) = {
	self.output := self.output.append(10);  # newline
	self.output := self.output.resize(self.output.end+(self.maxline-self.space),32);  # spaces
    }

    action print (self:this,tok:token) returns (self:this) = {
	if tok.pair {
	    if tok.second <= self.space | self.space = self.maxline {
                self.output := self.output.extend(tok.first);
                self.space := self.space - tok.first.end
	    } else {
                self.space := self.maxline - tok.tdepth * self.indent;
                self := self.do_indent
	    }
	} else {
            self.output := self.output.extend(tok.first);
            self.space := self.space - tok.first.end
	}
    }

    action print_tokens (self:this) returns (self:this) = {
	var idx := self.tokens.begin;
	while idx < self.tokens.end {
	    self := self.print(self.tokens.value(idx));
	    idx := idx.next
	};
	self.tokens := vector[token].empty;
    }

    action add_length(self:this, len:pos, at:vector[token].domain) returns (self:this) = {
        if at > self.st.begin {
            var prev := self.tokens.value(at.prev);
            if prev.pair {
		var newtok := prev;
		newtok.second := newtok.second + len;
                self.tokens := self.tokens.set(at.prev,newtok)
	    }
	};
    }
	
    action extend(self:this, string:str) returns (self:this) = {
	var tok : token;
	tok.pair := false;
        tok.tdepth := self.depth;
	tok.first := string;
	if true & string = self.whitespace {   # true = breakable
	    tok.pair := true;
	    tok.second := string.end;
	} else {
	    self := add_length(self,string.end,self.tokens.end)
	};
        self.tokens := self.tokens.append(tok);
	self.st.total := self.st.total + string.end
    }    

    action nest(self:this) returns (self:this) = {
        self.stack := self.stack.append(self.space);
	self.states := self.states.append(self.st);
        self.st.total := 0;
	self.st.begin := self.tokens.end;
        self.depth := self.depth + 1
    }

    action unnest(self:this) returns (self:this) = {
	var oldst := self.st;
	# Tricky: don't count any terminal white space in length of scope
#	if self.tokens.end > oldst.begin & self.tokens.back.pair {
#	    oldst.total := oldst.total - self.tokens.back.second;
#            self.tokens.end > oldst.begin & self.tokens.back.pair
#	};
	self.stack := self.stack.pop_back;
	self.st := self.states.back;
	self.states := self.states.pop_back;
	self := self.add_length(oldst.total,oldst.begin);
	self.st.total := self.st.total + oldst.total;
        self.depth := self.depth - 1
    }

}

object str = { ...
    action encode(s:this,b:pretty) returns (b:pretty) = {
	b := b.extend(s)
    }    
}

type expr

object symbol = {
    variant this of expr = struct {
	name : str
    }
}

object plus = {
    variant this of expr = struct {
	lhs : expr,
	rhs : expr
    }
}

action sym(name:str) returns (res:expr) = {
    var s:symbol;
    s.name := name;
    res := s
}

action add(x:expr,y:expr) returns (res:expr) = {
    var s:plus;
    s.lhs := x;
    s.rhs := y;
    res := s;
}

type verb

action encode(e:expr,b:pretty,prio:verb) returns (b:pretty)

object symbol = { ...    
    action encode(s:symbol,b:pretty,prio:verb) returns (b:pretty) = {
	b := s.name.encode(b);
    }
}

object plus = { ...    
    action encode(s:plus,b:pretty,prio:verb) returns (b:pretty) = {
	if 0 < prio {
	    b := b.nest;
	    b := b.extend("(");
	};	    
	b := s.lhs.encode(b,0);
	b := b.extend(" ");
	b := b.extend("+");
	b := b.extend(" ");
	b := s.rhs.encode(b,1);
	if 0 < prio {
	    b := b.extend(")");
	    b := b.unnest
	}	    
    }
}

action enc(e:expr) returns (s:str) = {
    var p := pretty.make(15,4);
    p := e.encode(p,0);
    p := p.print_tokens;
    s := p.output
}


action lex(b:str,p:pos) returns (tok:str,p:pos) = {
    while p < b.end & b.value(p) = 32 {
	p := p.next
    };
    var start := p;
    var last : char := 32;
    while p < b.end & b.value(p) ~= 32 & (last = 32 | (char.kind(b.value(p)) = char.kind(last))) & char.kind(last) ~= char.bracket {
	last := b.value(p);
	p := p.next;
    };
    tok := b.segment(start,p);
}

object pstate = {
    type this = struct {
	b:str,
	p:pos,
	tok:str,
	ok:bool
    }
    action consume(st:pstate) returns(st:pstate) = {
	(st.tok,st.p) := lex(st.b,st.p);
    }	
}

action parse_symbol(st : pstate) returns(st : pstate, res:expr) = {
    if st.ok & st.tok.end ~= 0 {
	var s : symbol;
	s.name := st.tok;
	res := s;
	st := st.consume;
    }
    else {
	st.ok := false;
    }
}


action parse_expr(st : pstate, prio:verb) returns(st : pstate, res:expr) = {
    if st.tok = "(" {
	st := st.consume;
	(st,res) := parse_expr(st,0);
	if st.tok = ")" {
	    st := st.consume;
	} else {
	    st.ok := false;
	}
    } else {
	(st,res) := parse_symbol(st);
    };
    while st.ok & st.tok = "+" & prio < 1 {
	st := st.consume;
	var arg : expr;
	(st,arg) := parse_expr(st,1);
	if st.ok {
	    res := add(res,arg);
	}
    }
}

action start_state(s:str) returns (st:pstate) = {
    st.b := s;
    st.p := s.begin;
    st.ok := true;
}

action dec(s:str) returns (e:expr) = {
    var st := start_state(s);
    st := st.consume;
    (st,e) := parse_expr(st,0);
    if ~st.ok | st.tok.end ~= 0 {
	call parse_error(st.p,st.tok);
    }
}

action encdec(s:str) returns (res:str) = {
    var e := dec(s);
    res := enc(e)
}

action parse_error(p:pos,tok:str)

export sym
export add
export enc
export dec
export encdec
import parse_error


export pretty.make
export pretty.extend
export pretty.print_tokens

action pr(max:pos,s:str) returns (res:str) = {
    var p := pretty.make(max,4);
    var st := start_state(s);
    st := st.consume;
    while st.tok.end > 0 {
	if st.tok = "(" {
	    p := p.nest
	};
	p := p.extend(st.tok);
	if st.tok = ")" {
	    p := p.unnest
	};
#	call show_pretty(p);
	if st.b.value(st.p) = 32 {
	    p := p.extend(" ");
#	    call show_pretty(p);
	};
	st := st.consume
    };

    p := p.print_tokens;
    res := p.output
}

export pr

# after init {

#     var p := pretty.make(11,4);
#     var st := start_state("fooooooo + (bar + baaaaaz)");
#     st := st.consume;
#     while st.tok.end > 0 {
# 	if st.tok = "(" {
# 	    p := p.nest
# 	};
# 	p := p.extend(st.tok);
# 	if st.tok = ")" {
# 	    p := p.unnest
# 	};
# 	call show_pretty(p);
# 	if st.b.value(st.p) = 32 {
# 	    p := p.extend(" ");
# 	    call show_pretty(p);
# 	};
# 	st := st.consume
#     };

#     p := p.print_tokens;
#     call show_pretty(p);
    
# }

import action show_pretty(p:pretty)
