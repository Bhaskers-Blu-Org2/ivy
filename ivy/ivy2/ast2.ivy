#lang ivy1.7

include order
include string
include collections

instance pos : unbounded_sequence

object char = {
    type this
    type kinds = {alphanum,bracket,other}
    function is_alphanum(X:char) = (48 <= X & X < 58) | (65 <= X & X < 91) | (97 <= X & X < 123)
    function kind(X:char) = alphanum if is_alphanum(X:char)
                            else (bracket if (X = 40 | X = 41) else other)
}
    
instance str : string(pos,char)

object str = { ...
    action encode(s:this,b:str) returns (b:str) = {
	b := b.extend(s)
    }    
}

type expr

object symbol = {
    variant this of expr = struct {
	name : str
    }
}

object plus = {
    variant this of expr = struct {
	lhs : expr,
	rhs : expr
    }
}

action sym(name:str) returns (res:expr) = {
    var s:symbol;
    s.name := name;
    res := s
}

action add(x:expr,y:expr) returns (res:expr) = {
    var s:plus;
    s.lhs := x;
    s.rhs := y;
    res := s;
}

type verb

action encode(e:expr,b:str,prio:verb) returns (b:str)

object symbol = { ...    
    action encode(s:symbol,b:str,prio:verb) returns (b:str) = {
	b := s.name.encode(b);
    }
}

object plus = { ...    
    action encode(s:plus,b:str,prio:verb) returns (b:str) = {
	if 0 < prio {
	    b := b.extend("(");
	};	    
	b := s.lhs.encode(b,0);
	b := b.extend(" + ");
	b := s.rhs.encode(b,1);
	if 0 < prio {
	    b := b.extend(")");
	}	    
    }
}

action enc(e:expr) returns (s:str) = {
    s := e.encode(s,0);
}


action lex(b:str,p:pos) returns (tok:str,p:pos) = {
    while p < b.end & b.value(p) = 32 {
	p := p.next
    };
    var start := p;
    var last : char := 32;
    while p < b.end & b.value(p) ~= 32 & (last = 32 | (char.kind(b.value(p)) = char.kind(last))) & char.kind(last) ~= char.bracket {
	last := b.value(p);
	p := p.next;
    };
    tok := b.segment(start,p);
}

object pstate = {
    type this = struct {
	b:str,
	p:pos,
	tok:str,
	ok:bool
    }
    action consume(st:pstate) returns(st:pstate) = {
	(st.tok,st.p) := lex(st.b,st.p);
    }	
}

action parse_symbol(st : pstate) returns(st : pstate, res:expr) = {
    if st.ok & st.tok.end ~= 0 {
	var s : symbol;
	s.name := st.tok;
	res := s;
	st := st.consume;
    }
    else {
	st.ok := false;
    }
}


action parse_expr(st : pstate, prio:verb) returns(st : pstate, res:expr) = {
    if st.tok = "(" {
	st := st.consume;
	(st,res) := parse_expr(st,0);
	if st.tok = ")" {
	    st := st.consume;
	} else {
	    st.ok := false;
	}
    } else {
	(st,res) := parse_symbol(st);
    };
    while st.ok & st.tok = "+" & prio < 1 {
	st := st.consume;
	var arg : expr;
	(st,arg) := parse_expr(st,1);
	if st.ok {
	    res := add(res,arg);
	}
    }
}

action start_state(s:str) returns (st:pstate) = {
    st.b := s;
    st.p := s.begin;
    st.ok := true;
}

action dec(s:str) returns (e:expr) = {
    var st := start_state(s);
    st := st.consume;
    (st,e) := parse_expr(st,0);
    if ~st.ok | st.tok.end ~= 0 {
	call parse_error(st.p,st.tok);
    }
}

action encdec(s:str) returns (res:str) = {
    var e := dec(s);
    res := enc(e)
}

action parse_error(p:pos,tok:str)

export sym
export add
export enc
export dec
export encdec
import parse_error

object pretty = {

    type token = struct {
	pair : bool,
	first : str,
	second : pos
    }

    type state = struct {
        tokens : vector[token],
	total : pos
    }
    

    type this = struct {
	st : state,
        maxline : pos,
	indent : pos,
	whitespace : str,
	begins : vector[char],
	ends : vector[char],
	states : vector[state],
	stack : vector[pos],
	output : str,
	space : pos
    }
    
    action make(maxline:pos,indent:pos) returns (res:this) = {
	res.maxline := maxline;
	res.indent := indent;
	res.whitespace := " ";
	res.begins := res.begins.append(40);
	res.ends := res.ends.append(41);
	res.space := maxline;
	res.stack := res.stack.append(maxline);
    }

    action do_indent (self:this) returns (self:this) = {
	self.output := self.output.append(10);  # newline
	self.output := self.output.resize(self.output.end+(self.maxline-self.space),32);  # spaces
    }

    action print (self:this,tok:token) returns (self:this) = {
	if tok.pair {
	    if tok.second <= self.space | self.space = self.maxline {
                self.output := self.output.extend(tok.first);
                self.space := self.space - tok.first.end
	    } else {
                self.space := self.stack.back - self.indent;
                self := self.do_indent
	    }
	} else {
            self.output := self.output.extend(tok.first);
            self.space := self.space - tok.first.end
	}
    }

    action print_tokens (self:this) returns (self:this) = {
	var idx := self.st.tokens.begin;
	while idx < self.st.tokens.end {
	    self := self.print(self.st.tokens.value(idx));
	    idx := idx.next
	};
	self.st.tokens := vector[token].empty;
    }

    action append(self:this, tok:token, l:pos) returns (self:this) = {
        if self.st.tokens.end > 0 {
            var prev := self.st.tokens.value(self.st.tokens.end.prev);
            if prev.pair {
		var newtok := prev;
		newtok.second := newtok.second + l;
                self.st.tokens := self.st.tokens.set(self.st.tokens.end.prev,newtok)
	    }
	};
	if tok.pair {
	    self := self.print_tokens
	};
        self.st.tokens := self.st.tokens.append(tok);
        self.st.total := self.st.total + l
    }

    action write(self:this, string:str) returns (self:this) = {
	var tok : token;
	tok.pair := false;
	tok.first := string;
	if true & string = self.whitespace {   # true = breakable
	    tok.pair := true;
	    tok.second := string.end;
	};
        self := self.append(tok,string.end)
    }    

    action nest(self:this) returns (self:this) = {
	self := self.print_tokens;
        self.stack := self.stack.append(self.space);
	self.states := self.states.append(self.st);
        self.st.total := 0
    }

    action unnest(self:this) returns (self:this) = {
        if self.st.tokens.end > 0 & self.st.tokens.back.pair {
	    var last_tok := self.st.tokens.back;
	    self.st.tokens := self.st.tokens.pop_back;
	    self := self.print_tokens;
	    self.stack := self.stack.pop_back;
	    self.st := self.states.back;
	    self.states := self.states.pop_back;
	    self := self.append(last_tok,last_tok.second);
	} else {
	    self := self.print_tokens;
	    self.stack := self.stack.pop_back;
	    self.st := self.states.back;
	    self.states := self.states.pop_back;
	}	    
    }

}

export pretty.make
export pretty.write
export pretty.print_tokens

after init {

    var p := pretty.make(11,4);
    var st := start_state("(fooooooo + (bar + baaaaaz))");
    st := st.consume;
    while st.tok.end > 0 {
	if st.tok = "(" {
	    p := p.nest
	};
	p := p.write(st.tok);
	if st.tok = ")" {
	    p := p.unnest
	};
	call show_pretty(p);
	if st.b.value(st.p) = 32 {
	    p := p.write(" ");
	    call show_pretty(p);
	};
	st := st.consume
    };

    p := p.print_tokens;
    call show_pretty(p);
    
}

import action show_pretty(p:pretty)
