#lang ivy1.7

include order
include string

instance pos : unbounded_sequence

object char = {
    type this
    type kinds = {alphanum,bracket,other}
    function is_alphanum(X:char) = (48 <= X & X < 58) | (65 <= X & X < 91) | (97 <= X & X < 123)
    function kind(X:char) = alphanum if is_alphanum(X:char)
                            else (bracket if (X = 40 | X = 41) else other)
}
    
instance str : string(pos,char)

object str = { ...
    action encode(s:this,b:str) returns (b:str) = {
	b := b.extend(s)
    }    
}

type expr

object symbol = {
    variant this of expr = struct {
	name : str
    }
}

object plus = {
    variant this of expr = struct {
	lhs : expr,
	rhs : expr
    }
}

action sym(name:str) returns (res:expr) = {
    var s:symbol;
    s.name := name;
    res := s
}

action add(x:expr,y:expr) returns (res:expr) = {
    var s:plus;
    s.lhs := x;
    s.rhs := y;
    res := s;
}

type verb

action encode(e:expr,b:str,prio:verb) returns (b:str)

object symbol = { ...    
    action encode(s:symbol,b:str,prio:verb) returns (b:str) = {
	b := s.name.encode(b);
    }
}

object plus = { ...    
    action encode(s:plus,b:str,prio:verb) returns (b:str) = {
	if 0 < prio {
	    b := b.extend("(");
	};	    
	b := s.lhs.encode(b,0);
	b := b.extend(" + ");
	b := s.rhs.encode(b,1);
	if 0 < prio {
	    b := b.extend(")");
	}	    
    }
}

action enc(e:expr) returns (s:str) = {
    s := e.encode(s,0);
}


action lex(b:str,p:pos) returns (tok:str,p:pos) = {
    while p < b.end & b.value(p) = 32 {
	p := p.next
    };
    var start := p;
    var last : char := 32;
    while p < b.end & b.value(p) ~= 32 & (last = 32 | (char.kind(b.value(p)) = char.kind(last))) & char.kind(last) ~= char.bracket {
	last := b.value(p);
	p := p.next;
    };
    tok := b.segment(start,p);
}

object pstate = {
    type this = struct {
	b:str,
	p:pos,
	tok:str,
	ok:bool
    }
    action consume(st:pstate) returns(st:pstate) = {
	(st.tok,st.p) := lex(st.b,st.p);
    }	
}

action parse_symbol(st : pstate) returns(st : pstate, res:expr) = {
    if st.ok & st.tok.end ~= 0 {
	var s : symbol;
	s.name := st.tok;
	res := s;
	st := st.consume;
    }
    else {
	st.ok := false;
    }
}


action parse_expr(st : pstate, prio:verb) returns(st : pstate, res:expr) = {
    if st.tok = "(" {
	st := st.consume;
	(st,res) := parse_expr(st,0);
	if st.tok = ")" {
	    st := st.consume;
	} else {
	    st.ok := false;
	}
    } else {
	(st,res) := parse_symbol(st);
    };
    while st.ok & st.tok = "+" & prio < 1 {
	st := st.consume;
	var arg : expr;
	(st,arg) := parse_expr(st,1);
	if st.ok {
	    res := add(res,arg);
	}
    }
}

action start_state(s:str) returns (st:pstate) = {
    st.b := s;
    st.p := s.begin;
    st.ok := true;
}

action dec(s:str) returns (e:expr) = {
    var st := start_state(s);
    st := st.consume;
    (st,e) := parse_expr(st,0);
    if ~st.ok | st.tok.end ~= 0 {
	call parse_error(st.p,st.tok);
    }
}

action encdec(s:str) returns (res:str) = {
    var e := dec(s);
    res := enc(e)
}

action parse_error(p:pos,tok:str)

export sym
export add
export enc
export dec
export encdec
import parse_error
