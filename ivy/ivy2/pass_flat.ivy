#lang ivy1.7

# The flattening pass lowers module instantiations and
# and `.` operators.

include ivylang
include logic


module generic_flat(ivytype,ivyclass) = {
    action flat(s:ivytype,st:flatst) returns (st:flatst) = {
        var t : ivytype;
        (t,st) := s.flat_int(st);
        t.ann := s.ann;
        st.decls := st.decls.append(t);
    }
}

# A `def_map` is a map from identifiers to a range type. I has the same
# interface as `hash_map`, plus an action `get_def` that looks up the value of
# an identifier and reports an error if it is not found.

module def_map(range) = {
    instantiate hash_map(ident,range)
    action get_def(m:this,x:ident,ann:annot) returns (y:range) = {
        if ~m.mem(x) {
            call report_error(undefined.make(x),ann);
        } else {
            y := m.get(x,y)
        }
    }
}

object ivy = { ...


    instance ident_to_moduledc : def_map(moduledc)
    
    object flatst = {
        type this = struct {

            # Accumulated declarations

            decls : vector[decl],

            # The module parameter valuations

            prmvals : symeval,

            # The module declarations, by name

            moddecls : ident_to_moduledc

        }
    }

    action prm_map(fml:vector[expr],act:vector[expr],ann:annot) returns (res:symeval) = {
        if fml.end ~= act.end {
            call report_error(wrong_number_params.make(fml.end),ann);
        } else {
            var idx := fml.begin;
            while idx < fml.end {
                res := res.set(fml.value(idx).get_name,act.value(idx));
                idx := idx.next;
            }
        }
    }

    object expr = { ...
        action flat(s:this,st:flatst) returns (s:expr,st:flatst)
    }

    action applydot(arg:expr,member:ident) returns (res:expr) = {
        var name := dotident.make(arg.get_name,member.to_str);
        res := symbol.make(name,arg.get_ann);
    }
    
    object symbol = { ...
        action flat(s:this,st:flatst) returns (res:expr,st:flatst) = {
            var dflt : expr := s;  # workaround
            res := st.prmvals.get(s.get_name,dflt);
        }
    }

    object app = { ...
        action flat(s:this,st:flatst) returns (res:expr,st:flatst) = {
            var arg0 : expr;
            (arg0,st) := s.args.value(0).flat(st);
            if s.is(verb.dot) & (s.args.value(0) isa symbol) & (s.args.value(1) isa symbol) {
                res := applydot(arg0,s.args.value(1).get_name)
            } else {
                var arg1 : expr;
                (arg1,st) := s.args.value(1).flat(st);
                res := app.make2(s.func,arg0,arg1,s.ann);
            }
        }
    }

    object stmt = { ...
        action flat(s:this,st:flatst) returns (s:this,st:flatst)
    }
    
    object decl = { ...
        action flat(s:decl,st:flatst) returns (st:flatst)
    }

    action flat_exprvec(es:vector[expr],st:flatst) returns (es:vector[expr],st:flatst) = {
        var idx := es.begin;
        while idx < es.end {
            var e : expr;
            (e,st) := es.value(idx).flat(st);
            es := es.set(idx,e);
            idx := idx.next;
        }
    }

    object actdc = { ...
        instantiate generic_flat(this,decl)
        action flat_int(s:actdc,st:flatst) returns (res:this,st:flatst) = {
            (res.name,st) := s.name.flat(st);
            (res.inputs,st) := flat_exprvec(s.inputs,st);
            (res.outputs,st) := flat_exprvec(s.outputs,st);
	    res.has_body := s.has_body;
            (res.body,st) := s.body.flat(st);
        }
    }

    object typedc = { ...
        instantiate generic_flat(this,decl)
	action flat_int(s:this,st:flatst) returns (res:this,st:flatst) = {
            (res.sort,st) := s.sort.flat(st);
	}
    }
	
    object vardc = { ...
        instantiate generic_flat(this,decl)
	action flat_int(s:this,st:flatst) returns (res:this,st:flatst) = {
            res.is_destructor := s.is_destructor;
            (res.typing,st) := s.typing.flat(st);
	}
    }

    object header = { ...
        instantiate generic_flat(this,decl)
	action flat_int(s:this,st:flatst) returns (res:this,st:flatst) = {
            res.filename := s.filename;
	}
    }

    object interpdc = { ...
        instantiate generic_flat(this,decl)
	action flat_int(s:this,st:flatst) returns (res:this,st:flatst) = {
            (res.itype,st) := s.itype.flat(st);
            (res.ctype,st) := s.ctype.flat(st);
	}
    }

    object moduledc = { ...
        action flat(s:this,st:flatst) returns (st:flatst) = {
            st.moddecls := st.moddecls.set(s.name.get_name,s);
	}
    }

    object instantiatedc = { ...
        action flat(s:this,st:flatst) returns (st:flatst) = {
            var name : expr;
            var prms : vector[expr];
            (name,st) := s.name.flat(st);
            (prms,st) := flat_exprvec(s.prms,st);
            var mod := st.moddecls.get_def(name.get_name,s.ann);
            var old_prmvals := st.prmvals;
            st.prmvals := prm_map(mod.prms,prms,s.ann);
            st := mod.body.flat(st);
            st.prmvals := old_prmvals;
        }
    }

    object groupdc = { ...
	action flat(s:this,st:flatst) returns (st:flatst) = {
            var idx := s.decls.begin;
            var decls : vector[decl];
            while idx < s.decls.end {
                st := s.decls.value(idx).flat(st);
                idx := idx.next;
            };
        }
    }

    object prog = { ...
        action flat(p:prog,st:flatst) returns (p:prog,st:flatst) = {
            var idx := p.decls.begin;
            while idx < p.decls.end {
                st := p.decls.value(idx).flat(st);
                idx := idx.next;
            };
            p.decls := st.decls;
        }
    }
}
