#lang ivy1.7

# The flattening pass lowers module instantiations and
# and `.` operators.

include ivylang
include logic
include error

module generic_flat(ivytype,ivyclass) = {
    action flat(s:ivytype,st:flatst) returns (st:flatst) = {
        var t : ivytype;
        (t,st) := s.flat_int(st);
        t.ann := s.ann;
        st.decls := st.decls.append(t);
    }
}

module generic_flat_stmt(ivytype,ivyclass) = {
    action flat(s:ivytype,st:flatst) returns (res:ivyclass,st:flatst) = {
        var t : ivytype;
        (t,st) := s.flat_int(st);
        t.ann := s.ann;
        res := t;
    }
}

# A `def_map` is a map from identifiers to a range type. I has the same
# interface as `hash_map`, plus an action `get_def` that looks up the value of
# an identifier and reports an error if it is not found.

module def_map(range) = {
    instantiate hash_map(ident,range)
    action get_def(m:this,x:ident,ann:annot) returns (y:range) = {
        if ~m.mem(x) {
            call report_error(undefined.make(x),ann);
        } else {
            y := m.get(x,y)
        }
    }
}

object ivy = { ...


    instance ident_to_moduledc : def_map(moduledc)
    instance ident_to_ident : hash_map(ident,ident)
    instance ident_set : hash_map(ident,bool)
    
    object flatst = {
        type this = struct {

            # Accumulated declarations

            decls : vector[decl],

            # The module parameter valuations

            prmvals : ident_to_ident,

            # The module declarations, by name

            moddecls : ident_to_moduledc,

            # The set of defined identifiers

            defs : ident_set,
            
            # True if the hierarchy root is set

            has_root : bool,

            # The current hierarchy root

            root : ident,

            # The current local variables

            locals : ident_set,

            # True if we are defining an identifier

            defining : bool,

            # True if we are on an absolute identifier

            absolute : bool,

            # True if we are on rhs of a dot operator

            dot_rhs : bool

        }
    }

    action prm_map(fml:vector[expr],act:vector[expr],ann:annot) returns (res:ident_to_ident) = {
        if fml.end ~= act.end {
            call report_error(wrong_number_params.make(fml.end),ann);
        } else {
            var idx := fml.begin;
            while idx < fml.end {
                res := res.set(fml.value(idx).get_name,act.value(idx).get_name);
                idx := idx.next;
            }
        }
    }

    object expr = { ...
        action flat(s:this,st:flatst) returns (s:expr,st:flatst)
    }

    # A dot operator has two possible interpretations: it indicates a
    # member of an object, or an application of a destructor or member
    # action. When defining a name, it is always the former. When not
    # defining, we check whether the lhs of the dot is defined. If it is,
    # we treat the dot as an object member reference.

    action applydot(arg:expr,member:ident,ann:annot,st:flatst) returns (res:expr) = {
        var name := member.prefix(arg.get_name);
        if st.absolute | st.defining | st.defs.get(arg.get_name,false) {
            res := symbol.make(name,ann);
        } else {
            res := dot.make(arg,symbol.make(member,ann),ann);
        }
    }
    
    action find_ident(root:ident,s:ident,st:flatst) returns (s:ident) = {
        var cand := s.prefix(root);
        if st.defs.mem(cand) {
            s := cand
        } else if root isa dotident {
            s := find_ident(root.get_namesp,s,st)
        }
    }

    object ident = { ...
        action prefix(s:this,pref:ident) returns (res:ident) = {
            res := s
        }
        action flat(s:this,rhs:bool,st:flatst) returns (res:ident) = {
            res := s
        }
    }

    object strident = { ...
        action prefix(s:this,pref:ident) returns (res:ident) = {
            res := dotident.make(pref,s);
        }
        action flat(s:this,rhs:bool,st:flatst) returns (res:ident) = {
            var s2 := s;  # workaround
            var idx := s2.subscrs.begin;
            while idx < s2.subscrs.end {
                var t := s2.subscrs.value(idx);
                t := t.flat(false,st);
                s2.subscrs := s2.subscrs.set(idx,t);
                idx := idx.next
            };         
            if st.has_root & s2.val = "this" & s2.subscrs.end = 0 {
                res := st.root
            } else {
                res := s2;
                if ~rhs {
                    res := st.prmvals.get(res,res);
                    if st.has_root {
                        if st.defining {
                            res := res.prefix(st.root)
                        } else {
                            res := find_ident(st.root,res,st);
                        }
                    }
                }
            }
        }
    }

    object dotident = { ...
        action prefix(s:this,pref:ident) returns (res:ident) = {
            res := dotident.make(s.namesp.prefix(pref),s.member);
        }
        action flat(s:this,rhs:bool,st:flatst) returns (res:ident) = {
            res := dotident.make(s.namesp.flat(rhs,st),s.member);
        }
    } 

    object subsident = { ...
        action prefix(s:this,pref:ident) returns (res:ident) = {
            res := subsident.make(s.namesp.prefix(pref),s.subscrs);
        }
        action flat(s:this,rhs:bool,st:flatst) returns (res:ident) = {
            var f := s;
            f.namesp := f.namesp.flat(rhs,st);
            var idx := f.subscrs.begin;
            while idx < f.subscrs.end {
                var s := f.subscrs.value(idx);
                s := s.flat(false,st);
                f.subscrs := f.subscrs.set(idx,s);
                idx := idx.next
            };         
            res := f
        }
    } 

    object expr = { ...
        action prefix(s:this,pref:ident) returns (res:expr)
    }

    object symbol = { ...
        action prefix(s:this,pref:ident) returns (res:expr) = {
            res := symbol.make(s.get_name.prefix(pref),s.get_ann);
        }
    }
        
    action add_def(s:expr,st:flatst) returns (st:flatst) = {
        st.defining := true;
        var id := s.get_name.flat(false,st);
        st.defining := false;
        st.defs := st.defs.set(id,true);
    }

    object symbol = { ...
        action flat(s:this,st:flatst) returns (res:expr,st:flatst) = {
            var f := s;
            if ~st.locals.get(f.name,false) {
                f.name := f.name.flat(false,st);
            };
            res := f
        }
    }

    object app = { ...
        action flat(s:this,st:flatst) returns (res:expr,st:flatst) = {
            var arg0 : expr;
            (arg0,st) := s.args.value(0).flat(st);
            if s.is(verb.dot) & (arg0 isa symbol) & (s.args.value(1) isa symbol) {
                res := applydot(arg0,s.args.value(1).get_name.flat(true,st),s.ann,st)
            } else {
                var args : vector[expr];
                args := args.append(arg0);
                var idx := s.args.begin.next;
                while idx < s.args.end {
                    var arg : expr;
                    (arg,st) := s.args.value(idx).flat(st);
                    args := args.append(arg);
                    idx := idx.next
                };
                var func : expr;
                (func,st) := s.func.flat(st);
                res := app.make(func,args,s.ann);
            }
        }
    }

    object stmt = { ...
        action flat(s:this,st:flatst) returns (res:this,st:flatst) = {
            res := s
        }
        action get_ident(s:this) returns (res:ident)
    }

    object asgn = { ...
        instantiate generic_flat_stmt(this,stmt)
        action flat_int(s:this,st:flatst) returns (res:this,st:flatst) = {
            res := s;
            (res.lhs,st) := res.lhs.flat(st);
            (res.rhs,st) := res.rhs.flat(st);
        }
    }

    object sequence = { ...
        instantiate generic_flat_stmt(this,stmt)
        action flat_int(s:this,st:flatst) returns (res:this,st:flatst) = {
            res := s;
            (res.lhs,st) := res.lhs.flat(st);
            if res.lhs isa varst {
                var id := res.lhs.get_ident;
                var old_local := st.locals.get(id,false);
                st.locals := st.locals.set(id,true);
                (res.rhs,st) := res.rhs.flat(st);
                st.locals := st.locals.set(id,old_local);
            } else {
                (res.rhs,st) := res.rhs.flat(st);
            }
        }
    }

    object ifst = { ...
        instantiate generic_flat_stmt(this,stmt)
        action flat_int(s:this,st:flatst) returns (res:this,st:flatst) = {
            res := s;
            (res.cond,st) := res.cond.flat(st);
            (res.thenst,st) := res.thenst.flat(st);
            (res.elsest,st) := res.elsest.flat(st);
        }
    }

    action flat_formal(s:expr,st:flatst) returns (res:expr,st:flatst) = {
        res := s;
        if res.is(verb.colon) {
            var ty : expr;
            (ty,st) := res.get_arg(1).flat(st);
            res := colon.make(res.get_arg(0),ty,res.get_ann)
        }
    }
    
    action formal_ident(s:expr) returns (res:ident) = {
        res := s.get_arg(0).get_name if (s.is(verb.colon)) else s.get_name
    }

    object varst = { ...
        instantiate generic_flat_stmt(this,stmt)
        action flat_int(s:this,st:flatst) returns (res:this,st:flatst) = {
            res := s;
            (res.name,st) := flat_formal(res.name,st);
        }
        action get_ident(s:this) returns (res:ident) = {
            res := formal_ident(s.name)
        }
    }

    object decl = { ...
        action flat(s:this,st:flatst) returns (st:flatst)
        action defd(s:this,st:flatst) returns (st:flatst)
    }

    action flat_exprvec(es:vector[expr],st:flatst) returns (es:vector[expr],st:flatst) = {
        var idx := es.begin;
        while idx < es.end {
            var e := es.value(idx);
            (e,st) := e.flat(st);
            es := es.set(idx,e);
            idx := idx.next;
        }
    }

    action flat_formalvec(es:vector[expr],st:flatst) returns (es:vector[expr],st:flatst) = {
        var idx := es.begin;
        while idx < es.end {
            var e := es.value(idx);
            (e,st) := flat_formal(e,st);
            es := es.set(idx,e);
            idx := idx.next;
        }
    }

    action local_vec(es:vector[expr],val:bool,st:flatst) returns (st:flatst) = {
        var idx := es.begin;
        while idx < es.end {
            var e := es.value(idx);
            st.locals := st.locals.set(formal_ident(e),val);
            idx := idx.next;
        }
    }


    object actdc = { ...
        instantiate generic_flat(this,decl)
        action flat_int(s:actdc,st:flatst) returns (res:this,st:flatst) = {
            (res.name,st) := s.name.flat(st);
            res.kind := s.kind;
            (res.inputs,st) := flat_formalvec(s.inputs,st);
            (res.outputs,st) := flat_formalvec(s.outputs,st);
            st := local_vec(res.inputs,true,st);
            st := local_vec(res.outputs,true,st);
	    res.has_body := s.has_body;
            (res.body,st) := s.body.flat(st);
            st := local_vec(res.inputs,false,st);
            st := local_vec(res.outputs,false,st);
        }
        action defd(s:this,st:flatst) returns (st:flatst) = {
            st := add_def(s.name,st);
        }
    }

    object initdc = { ...
        instantiate generic_flat(this,decl)
        action flat_int(s:this,st:flatst) returns (res:this,st:flatst) = {
            (res.body,st) := s.body.flat(st);
        }
    }

    object typedc = { ...
        instantiate generic_flat(this,decl)
	action flat_int(s:this,st:flatst) returns (res:this,st:flatst) = {
            (res.sort,st) := s.sort.flat(st);
            res.has_super := s.has_super;
            if res.has_super {
                (res.super,st) := s.super.flat(st);
            }
	}
        action defd(s:this,st:flatst) returns (st:flatst) = {
            st := add_def(s.sort,st);
        }
    }
	
    object vardc = { ...
        instantiate generic_flat(this,decl)
	action flat_int(s:this,st:flatst) returns (res:this,st:flatst) = {
            res.is_destructor := s.is_destructor;
            (res.typing,st) := s.typing.flat(st);
	}
        action defd(s:this,st:flatst) returns (st:flatst) = {
            st := add_def(s.typing.get_arg(0),st);
        }
    }

    object header = { ...
        instantiate generic_flat(this,decl)
	action flat_int(s:this,st:flatst) returns (res:this,st:flatst) = {
            res.filename := s.filename;
	}
    }

    import action show_ctype(e:expr)

    object interpdc = { ...
        instantiate generic_flat(this,decl)
	action flat_int(s:this,st:flatst) returns (res:this,st:flatst) = {
            (res.itype,st) := s.itype.flat(st);
	    st.absolute := true;
            (res.ctype,st) := s.ctype.flat(st);
	    st.absolute := false;
	    call show_ctype(res.ctype);
	}
    }

    object moduledc = { ...
        action defd(s:this,st:flatst) returns (st:flatst) = {
            st.moddecls := st.moddecls.set(s.name.get_name,s);
            st := add_def(s.name,st);
        }
    }

    object instantiatedc = { ...
        action setup(s:this,st:flatst) returns (mod:moduledc,st:flatst) = {
            var name : expr;
            var prms : vector[expr];
            (name,st) := s.name.flat(st);
            (prms,st) := flat_exprvec(s.prms,st);
            mod := st.moddecls.get_def(name.get_name,s.ann);
            st.prmvals := prm_map(mod.prms,prms,s.ann);
        }

        action flat(s:this,st:flatst) returns (st:flatst) = {
            var mod : moduledc;
            var old_prmvals := st.prmvals;
            (mod,st) := s.setup(st);
            st := mod.body.flat(st);
            st.prmvals := old_prmvals;
        }
        action defd(s:this,st:flatst) returns (st:flatst) = {
            var mod : moduledc;
            var old_prmvals := st.prmvals;
            (mod,st) := s.setup(st);
            st := mod.body.defd(st);
            st.prmvals := old_prmvals;
        }
    }

    action set_root(st:flatst,s:expr) returns (st:flatst) = {
        st.root := s.get_name.prefix(st.root) if st.has_root else s.get_name;
        st.has_root := true;
    }

    object objectdc = { ...
        action flat(s:this,st:flatst) returns (st:flatst) = {
            var old_has_root := st.has_root;
            var old_root := st.root;
            st := set_root(st,s.name);
            var odc : objectdc;
            odc.name := symbol.make(st.root,s.name.get_ann);
            odc.ann := s.ann;
            st.decls := st.decls.append(odc);
            st := s.body.flat(st);
            st.has_root := old_has_root;
            st.root := old_root;
        }
        action defd(s:this,st:flatst) returns (st:flatst) = {
            st := add_def(s.name,st);
            var old_has_root := st.has_root;
            var old_root := st.root;
            st := set_root(st,s.name);
            st := s.body.defd(st);
            st.has_root := old_has_root;
            st.root := old_root;
        }
    }

    object instancedc = { ...
        action desugar(s:this) returns (res:decl) = {
            var body := instantiatedc.make(s.modname,s.prms,s.ann);
            res := objectdc.make(s.objname,body,s.ann);
        }
        
        action flat(s:this,st:flatst) returns (st:flatst) = {
            var ds := desugar(s);  # workaround
            st := ds.flat(st);
        }
        action defd(s:this,st:flatst) returns (st:flatst) = {
            var ds := desugar(s);  # workaround
            st := ds.defd(st);
        }
    }

    object groupdc = { ...
	action flat(s:this,st:flatst) returns (st:flatst) = {
            var idx := s.decls.begin;
            while idx < s.decls.end {
                st := s.decls.value(idx).flat(st);
                idx := idx.next;
            };
        }
        action defd(s:this,st:flatst) returns (st:flatst) = {
            var idx := s.decls.begin;
            while idx < s.decls.end {
                st := s.decls.value(idx).defd(st);
                idx := idx.next;
            };
        }
    }

    import action show_defs(d:ident_set)

    object prog = { ...
        

        action flat(p:prog) returns (p:prog) = {
            var st:flatst;

            # A pass to record all the defined identifiers, We need to
            # know which identifiers are defined to determine the
            # scope of an object reference and to disambiguate
            # hierarchical names from "dot" operators.
            
            var idx := p.decls.begin;
            while idx < p.decls.end {
                st := p.decls.value(idx).defd(st);
                idx := idx.next;
            };

            # A pass to flatten. This pass expands module
            # instantiations and expands hieracharical names of object
            # members, so that all declarations are in global scope.
            # Object declarations remain, but their bodies are empty.

            idx := p.decls.begin;
            while idx < p.decls.end {
                st := p.decls.value(idx).flat(st);
                idx := idx.next;
            };
            p.decls := st.decls;
        }
    }
}
