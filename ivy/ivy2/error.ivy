#lang ivy1.7

#
# Here we have a collection of type variants indicating different
# sorts of errors. Each variant has an action to print itself. We collect them
# here for reference.
#

include ivylang

object ivy = { ...
    
    object error = {
        type this
        action encode(e:this,b:pretty) returns (b:pretty) = {
            b := b.extend("unknown error")
        }
    }

    # - Error `type_clash(e,t1,t2)` indicates that in sub-expression `e`,
    #   types `t1` and `t2` could not be unified.

    object type_clash = {
        variant this of error = struct {
            e : expr,
            t1 : expr,
            t2 : expr
        }
        action make(e:expr,t1:expr,t2:expr) returns (res:this) = {
            res.e := e;
            res.t1 := t1;
            res.t2 := t2;
        }
        action encode(e:this,b:pretty) returns (b:pretty) = {
            b := b.extend("Cannot unify types");
            b := b.extend(" ");
            b := e.t1.encode(b,0);
            b := b.extend(" ");
            b := e.t2.encode(b,0);
            b := b.extend(" ");
            b := b.extend("when typing this expression:");
            b := b.newline;
            b := e.e.encode(b,0);
        }
    }

    # - Error `untyped(e,t1)` indicates that subexpression `e` could not be
    #   fully typed, and gives a partial type for `e` containing
    #   undetermined type variables.

    object untyped = {
        variant this of error = struct {
            e : expr,
            t1 : expr,
            t2 : expr
        }
        action make(e:expr,t1:expr) returns (res:this) = {
            res.e := e;
            res.t1 := t1;
        }
        action encode(e:this,b:pretty) returns (b:pretty) = {
            b := b.extend("Cannot infer the type of this term:");
            b := b.newline;
            b := e.e.encode(b,0);
            b := b.newline;
            b := b.extend("Incomplete type:");
            b := b.extend(" ");
            b := e.t1.encode(b,0);
        }
    }


}
