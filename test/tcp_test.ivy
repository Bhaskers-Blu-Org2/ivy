#lang ivy1.7

module tcp_network(addr,pkt) = {

    type socket

# calls

    action close(self:addr,s:socket)

    action connect(self:addr,other:addr) returns (s:socket)

    action send(self:addr,s:socket,p:pkt)

# callbacks

    action accept(self:addr,s:socket,other:addr)

    action recv(self:addr,s:socket,p:pkt)

    action failed(self:addr,s:socket)

    action connected(self:addr,s:socket)
    
    specification {

        var open(A:addr,S:socket) : bool
        var req(A1:addr,S1:socket,A2:addr) : bool
        var ack(A1:addr,S1:socket) : bool
        var conn(A1:addr,S1:socket,A2:addr,S2:socket) : bool
        var sent_to(A:addr,S:socket,P:pkt) : bool
        
        after init {
            open(A,S) := false;
            req(A,S,A1) := false;
            ack(A,S) := false;
            conn(A1,S1,A2,S2) := false;
            sent_to(A,S,P) := false;
        }


        after connect {
            ensure ~open(self,s) & ~req(self,s,A) & ~ack(self,s); # can't return socket in use
            req(self,s,other) := true;
        }

        around accept {
            require exists S. req(other,S,self);
            require ~open(self,s) & ~req(self,s,A) & ~ack(self,s); # can't return socket in use
            ...
            open(self,s) := true;
            if some (s2 : socket) req(other,s2,self) {
                conn(self,s,other,s2) := true;
                conn(other,s2,self,s) := true;
                req(other,s2,self) := false;
                ack(other,s2) := true
            }
        }

        around connected {
            require ack(self,s);
            ...
            open(self,s) := true;
            ack(self,s) := false;
        }

        around send {
            require open(self,s);
            ...
            if some (other:addr,s2:socket) conn(self,s,other,s2) {
                sent_to(other,s2,p) := true
            }
        }

        before recv {
            require open(self,s);
            require sent_to(self,s,p);
        }            

        around close {
            require open(self,s);
            ...
            open(self,s) := false;
            sent_to(self,s,P) := false;
            conn(A,S,self,s) := false;
        }

        around failed {
            require exists A. req(self,s,A) | ack(self,s) | open(self,s);
            ...
            open(self,s) := false;
            req(self,s,A) := false;
            ack(self,s) := false;
            sent_to(self,s,P) := false;
            conn(A,S,self,s) := false;
        }
        
        invariant ~(open(A,S) & (req(A,S,A1) | ack(A,S))) & ~(req(A,S,A1) & ack(A,S))
        invariant req(A,S,A1) & req(A,S,A2) -> A1 = A2
        invariant (conn(A,S,A1,S1) | sent_to(A1,S1,P)) -> (open(A1,S1) | ack(A1,S1))
        invariant conn(A1,S1,A,S) -> (open(A1,S1) | ack(A1,S1))
    }

    
    implementation {
    
        object impl(self:addr) = {


    <<< header
	class tcp_reader;

        class tcp_config {
	public:
	    virtual void get(int id, unsigned long &inetaddr, unsigned long &inetport);
        };
    >>>

    <<< impl
        void tcp_config::get(int id, unsigned long &inetaddr, unsigned long &inetport) {
#ifdef _WIN32
	        inetaddr = ntohl(inet_addr("127.0.0.1")); // can't send to INADDR_ANY in windows
#else
	        inetaddr = INADDR_ANY;
#endif
	        inetport = `port_base`+ id;
        }

        struct tcp_callbacks {
	    %`handle_accept` acb;
	    %`handle_recv` rcb;
	    %`handle_fail` fcb;
	    %`handle_connected` ccb;
        }

        class tcp_task : public reader {
	    int sock;
	    int my_id;
            tcp_callbacks cb;
	    ivy_class *ivy;
	    tcp_config *conf;
          public:
            tcp_task(int my_id, int sock, const tcp_callbacks &cb, ivy_class *ivy)
              : my_id(_my_id), sock(sock), cb(cb), ivy(ivy), conf(0) {} 

            tcp_config *get_conf() {
	        if (!conf) {
	            conf = ivy -> get_tcp_config();
                }
                return conf;
            }

	    virtual void get_addr(int my_id, sockaddr_in &myaddr) {
		memset((char *)&myaddr, 0, sizeof(myaddr));
		unsigned long inetaddr;
		unsigned long inetport;
		get_conf() -> get(my_id,inetaddr,inetport);
		myaddr.sin_family = AF_INET;
		myaddr.sin_addr.s_addr = htonl(inetaddr);
		myaddr.sin_port = htons(inetport);
	    }

            virtual int get_id(const sockaddr_in &myaddr) {
               return get_conf() -> rev(ntohl(other_addr.sin_addr.s_addr), ntohs(other_addr.addr.sin_port));
            }

	    virtual int fdes() {
		return sock;
	    }


        };

        class tcp_listener : public tcp_task {
	  public:
	    tcp_listener(int _my_id, const tcp_callbacks &cb, ivy_class *ivy)
	        : tcp_task(my_id,0,cb,ivy) {
		sock = ::socket(AF_INET, SOCK_STREAM, 0);
		if (sock < 0)
		    { std::cerr << "cannot create socket\n"; exit(1); }
            }

	    virtual void bind() {
	        ivy -> __lock();  // can be asynchronous, so must lock ivy!
                struct sockaddr_in myaddr;
                get_addr(my_id,myaddr);
//                    std::cout << "binding id: " << my_id << " port: " << ntohs(myaddr.sin_port) << std::endl;
                if (::bind(sock, (struct sockaddr *)&myaddr, sizeof(myaddr)) < 0)
                    { std::cerr << "bind failed\n"; exit(1); }
                if (listen(sock,2) < 0) 
                    { std::cerr << "cannot listen on socket\n"; exit(1); }
	        ivy -> __unlock();
	    }

	    virtual ~tcp_listener() {
#ifdef _WIN32
                closesocket(sock);
#else
	        close(sock);
#endif
	    }

	    virtual void read() {
		std::cout << "ACCEPTING\n";
                sockaddr_in other_addr;
                socklen_t addrlen = sizeof(other_addr);    
                int new_sock = accept(sock, &other_addr, &addrlen);
                if (new_sock < 0)
	            { perror("accept failed"); exit(1); }
		int other = get_id(other_addr);
		ivy->__lock();
		acb(new_sock,other);
		ivy->__unlock();
	        install_reader(new tcp_reader(my_id,new_sock,other,rcb,fcb,ivy));
            }
	};

        class tcp_connector: public tcp_task {

            int other;
	    std::vector<char> buf;  // holds left-over bytes from last read

	  public:

	    tcp_reader(int _my_id, int sock, const tcp_callbacks &cb, ivy_class *ivy)
	        : tcp_task(my_id,0,cb,ivy), other(other) {
            }

	    virtual void read() {
		std::cout << "CONNECTING\n";
	        `pkt` pkt;
		ivy_socket_deser ds(sock,buf);
                buf.clear();
	        try {
		    __deser(ds,pkt);
                } catch (deser_err &) {
                    if (ds.pos > 0)
		        std::cout << "BAD PACKET RECEIVED\n";
                    else
		        std::cout << "EOF ON SOCKET\n";
                    cb.fcb(sock);
                    close(sock);
                    sock = -1;
		    return;
		}
                buf.resize(ds.inp.size()-ds.pos);  // capture the unused bytes
                std::copy(ds.inp.begin()+ds.pos,ds.inp.end(),buf.begin())
		ivy->__lock();
		rcb(pkt);
		ivy->__unlock();
	    }
	    virtual void write(int dst, `pkt` pkt) {
	        bind_int();
		struct sockaddr_in dstaddr;
		get_addr(dst,dstaddr);
		ivy_binary_ser sr;
	        __ser(sr,pkt);
		//std::cout << "SENDING\n";
		if (sendto(sock,&sr.res[0],sr.res.size(),0,(sockaddr *)&dstaddr,sizeof(sockaddr_in)) < 0) 
#ifdef _WIN32
		     { std::cerr << "sendto failed " << WSAGetLastError() << "\n"; exit(1); }
#else
		     { std::cerr << "sendto failed\n"; exit(1); }
#endif
	    }
	};

	class tcp_reader : public reader {
	    int sock;
	    int my_id;
            int other;
	    %`handle_recv` rcb;
	    %`handle_fail` fcb;
	    ivy_class *ivy;
	    std::vector<char> buf;
	  public:
	    tcp_reader(int _my_id, int sock, int other, %`handle_recv` rcb, %`handle_fail` fcb, ivy_class *ivy)
	        : my_id(_my_id), sock(sock), other(other), rcb(rcb), fcb(fcb), ivy(ivy)  {
            }
	    virtual int fdes() {
		return sock;
	    }
	    virtual void read() {
		std::cout << "RECEIVING\n";
	        `pkt` pkt;
		ivy_socket_deser ds(sock,buf);
	        try {
                    buf.clear();
		    __deser(ds,pkt);
                    buf.resize(ds.inp.size()-ds.pos);
                    std::copy(ds.inp.begin()+ds.pos,ds.inp.end(),buf.begin())
                } catch (deser_err &){
                    if (ds.pos > 0)
		        std::cout << "BAD PACKET RECEIVED\n";
                    else
		        std::cout << "EOF ON SOCKET\n";
                    fcb(sock);
                    close(sock);
                    sock = -1;
		    return;
		}
		ivy->__lock();
		rcb(pkt);
		ivy->__unlock();
	    }
	    virtual void write(int dst, `pkt` pkt) {
	        bind_int();
		struct sockaddr_in dstaddr;
		get_addr(dst,dstaddr);
		ivy_binary_ser sr;
	        __ser(sr,pkt);
		//std::cout << "SENDING\n";
		if (sendto(sock,&sr.res[0],sr.res.size(),0,(sockaddr *)&dstaddr,sizeof(sockaddr_in)) < 0) 
#ifdef _WIN32
		     { std::cerr << "sendto failed " << WSAGetLastError() << "\n"; exit(1); }
#else
		     { std::cerr << "sendto failed\n"; exit(1); }
#endif
	    }
	};


    >>>
    <<< member
	tcp_reader *`rdr`;

        tcp_config *the_tcp_config;        

        tcp_config *get_tcp_config() {
	    if (!the_tcp_config) 
	        the_tcp_config = new tcp_config();
	    return the_tcp_config; 
	}

        void set_tcp_config(tcp_config *conf) {
	    the_tcp_config = conf;
        }
    >>>
    <<< init
        the_tcp_config = 0;
	install_reader(`rdr` = new tcp_reader(`me`,`handle_recv`, this));
    >>>

    action handle_recv(x:pkt) = {
	call recv(me,x)
    }

    implement send(dst:addr,x:pkt) {
	<<< impure
	    `rdr`->write(`dst`,`x`);
	>>>
    }

        }

    }


    isolate iso = this
}

module simple_tcp(addr,pkt) = {

    action recv(dst:addr,v:pkt)
    action send(src:addr,dst:addr,v:pkt)

    specification {

        relation sent(V:pkt, N:addr)

        after init {
	    sent(V, N) := false
	}
    
	before send {
	    sent(v,dst) := true
	}

	before recv {
	    assert sent(v,dst)
	}

    }

    implementation {

        instance tcp : tcp_network(addr,pkt)

        object proc(self:addr) = {

            relation isup(A:addr)
            function sock(A:addr) : tcp.socket
            relation pend(A:addr)
            
            after init {
                isup(A) := false;
                pend(A) := false;
#                var foo := self;
 #               call tcp.listen(foo);
            }

            implement send(dst:addr,v:pkt) {
                if ~isup(dst) {
                    if ~pend(dst) {
                        sock(dst) := tcp.connect(self,dst);
                        pend(dst) := true
                    }
                } else {
                    call tcp.send(self,sock(dst),v)
                }
            }

            implement tcp.recv(s:tcp.socket,v:pkt) {
                call recv(self,v)
            }

            implement tcp.connected(s:tcp.socket) {
                if some(other:addr) pend(other) & sock(other) = s {
                    pend(other) := false;
                    isup(other) := true;
                }
            }

            implement tcp.accept(s:tcp.socket,other:addr) {
                # we ignore accept events
            }

            implement tcp.failed(s:tcp.socket) {
                if some(other:addr) (isup(other) | pend(other)) & sock(other) = s {
                    isup(other) := false;
                    pend(other) := true;
                    sock(other) := tcp.connect(self,other);
                }
            }

            invariant isup(A) -> tcp.open(self,sock(A))
            invariant pend(A) -> (isup(A) | tcp.req(self,sock(A),A) | tcp.ack(self,sock(A)))
#            invariant tcp.conn(self,S,A1,S1) -> S = sock(A1) & (isup(A1) | tcp.ack(self,S) & pend(A1))
            invariant (isup(A) | pend(A)) & tcp.conn(self,sock(A),A1,S1) -> A = A1
            invariant (isup(A) | pend(A)) & (isup(A1) | pend(A1)) & sock(A) = sock(A1) -> A = A1
            invariant tcp.sent_to(A,S,V) -> sent(V,A)

        }
    }

   isolate iso = this
}

type addr
type pkt

instance net : simple_tcp(addr,pkt)

export net.send
export net.tcp.recv
export net.tcp.connected
export net.tcp.accept
export net.tcp.failed

import net.recv

# instance net : tcp_network(addr,pkt)


# export net.listen

# export net.close

# export net.connect

# export net.send


# export net.accept

# export net.recv

# export net.failed

# export net.connected

