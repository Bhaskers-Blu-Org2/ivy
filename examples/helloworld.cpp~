#include "helloworld.h"

#include <sstream>
#include <fstream>
#include <algorithm>

#include <iostream>
#include <stdlib.h>
#include <sys/types.h>          /* See NOTES */
#include <sys/stat.h>
#include <fcntl.h>
#ifdef _WIN32
#include <winsock2.h>
#include <io.h>
#define isatty _isatty
#else
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h> 
#include <sys/select.h>
#include <unistd.h>
#endif
#include <string.h>
#include <stdio.h>
#include <string>
typedef helloworld ivy_class;
std::ifstream __in;
std::ofstream __out;

/*++
Copyright (c) Microsoft Corporation

This string hash function is borrowed from Microsoft Z3
(https://github.com/Z3Prover/z3). 

--*/


#define mix(a,b,c)              \
{                               \
  a -= b; a -= c; a ^= (c>>13); \
  b -= c; b -= a; b ^= (a<<8);  \
  c -= a; c -= b; c ^= (b>>13); \
  a -= b; a -= c; a ^= (c>>12); \
  b -= c; b -= a; b ^= (a<<16); \
  c -= a; c -= b; c ^= (b>>5);  \
  a -= b; a -= c; a ^= (c>>3);  \
  b -= c; b -= a; b ^= (a<<10); \
  c -= a; c -= b; c ^= (b>>15); \
}

#ifndef __fallthrough
#define __fallthrough
#endif

namespace hash_space {

// I'm using Bob Jenkin's hash function.
// http://burtleburtle.net/bob/hash/doobs.html
unsigned string_hash(const char * str, unsigned length, unsigned init_value) {
    register unsigned a, b, c, len;

    /* Set up the internal state */
    len = length;
    a = b = 0x9e3779b9;  /* the golden ratio; an arbitrary value */
    c = init_value;      /* the previous hash value */

    /*---------------------------------------- handle most of the key */
    while (len >= 12) {
        a += reinterpret_cast<const unsigned *>(str)[0];
        b += reinterpret_cast<const unsigned *>(str)[1];
        c += reinterpret_cast<const unsigned *>(str)[2];
        mix(a,b,c);
        str += 12; len -= 12;
    }

    /*------------------------------------- handle the last 11 bytes */
    c += length;
    switch(len) {        /* all the case statements fall through */
    case 11: 
        c+=((unsigned)str[10]<<24);
        __fallthrough;
    case 10: 
        c+=((unsigned)str[9]<<16);
        __fallthrough;
    case 9 : 
        c+=((unsigned)str[8]<<8);
        __fallthrough;
        /* the first byte of c is reserved for the length */
    case 8 : 
        b+=((unsigned)str[7]<<24);
        __fallthrough;
    case 7 : 
        b+=((unsigned)str[6]<<16);
        __fallthrough;
    case 6 : 
        b+=((unsigned)str[5]<<8);
        __fallthrough;
    case 5 : 
        b+=str[4];
        __fallthrough;
    case 4 : 
        a+=((unsigned)str[3]<<24);
        __fallthrough;
    case 3 : 
        a+=((unsigned)str[2]<<16);
        __fallthrough;
    case 2 : 
        a+=((unsigned)str[1]<<8);
        __fallthrough;
    case 1 : 
        a+=str[0];
        __fallthrough;
        /* case 0: nothing left to add */
    }
    mix(a,b,c);
    /*-------------------------------------------- report the result */
    return c;
}

}


class reader {
public:
    virtual int fdes() = 0;
    virtual void read() = 0;
};
void install_reader(reader *);
class timer {
public:
    virtual int ms_delay() = 0;
    virtual void timeout(int) = 0;
};
void install_timer(timer *);
struct ivy_value {
    int pos;
    std::string atom;
    std::vector<ivy_value> fields;
    bool is_member() const {
        return atom.size() && fields.size();
    }
};
struct ivy_ser {
    virtual void  set(int) = 0;
    virtual void  set(bool) = 0;
    virtual void  set(const std::string &) = 0;
    virtual void  open_list(int len) = 0;
    virtual void  close_list() = 0;
    virtual void  open_list_elem() = 0;
    virtual void  close_list_elem() = 0;
    virtual void  open_struct() = 0;
    virtual void  close_struct() = 0;
    virtual void  open_field(const std::string &) = 0;
    virtual void  close_field() = 0;
    virtual ~ivy_ser(){}
};
struct ivy_binary_ser : public ivy_ser {
    std::vector<char> res;
    void set(int inp) {
        for (int i = sizeof(int)-1; i >= 0 ; i--)
            res.push_back((inp>>(8*i))&0xff);
    }
    void set(bool inp) {
        set((int)inp);
    }
    void set(const std::string &inp) {
        for (unsigned i = 0; i < inp.size(); i++)
            res.push_back(inp[i]);
        res.push_back(0);
    }
    void open_list(int len) {
        set(len);
    }
    void close_list() {}
    void open_list_elem() {}
    void close_list_elem() {}
    void open_struct() {}
    void close_struct() {}
    void open_field() {}
    void close_field() {}
};

struct ivy_deser {
    virtual void  get(int&) = 0;
    virtual void  get(std::string &) = 0;
    virtual void  open_list() = 0;
    virtual void  close_list() = 0;
    virtual bool  open_list_elem() = 0;
    virtual void  close_list_elem() = 0;
    virtual void  open_struct() = 0;
    virtual void  close_struct() = 0;
    virtual void  open_field(const std::string &) = 0;
    virtual void  close_field() = 0;
    virtual void  end() = 0;
    virtual ~ivy_deser(){}
};

struct deser_err {
};

struct ivy_binary_deser : public ivy_deser {
    std::vector<char> inp;
    int pos;
    std::vector<int> lenstack;
    ivy_binary_deser(const std::vector<char> &inp) : inp(inp),pos(0) {}
    void get(int &res) {
        if (inp.size() < pos + sizeof(int))
            throw deser_err();
        res = 0;
        for (int i = 0; i < sizeof(int); i++)
            res = (res << 8) | (((int)inp[pos++]) & 0xff);
    }
    void get(std::string &res) {
        while (pos < inp.size() && inp[pos]) {
            if (inp[pos] == '"')
                throw deser_err();
        }
        res.push_back(inp[pos++]);
    }
    void open_list() {
        int len;
        get(len);
        lenstack.push_back(len);
    }
    void close_list() {
        lenstack.pop_back();
    }
    bool open_list_elem() {
        return lenstack.back();
    }
    void close_list_elem() {
        lenstack.back()--;
    }
    void open_struct() {}
    void close_struct() {}
    void open_field() {}
    void close_field() {}
    void end() {
        if (pos != inp.size())
            throw deser_err();
    }
};
struct out_of_bounds {
    std::string txt;
    int pos;
    out_of_bounds(int _idx, int pos = 0) : pos(pos){
        std::ostringstream os;
        os << "argument " << _idx+1;
        txt = os.str();
    }
    out_of_bounds(const std::string &s, int pos = 0) : txt(s), pos(pos) {}
};

template <class T> T _arg(std::vector<ivy_value> &args, unsigned idx, int bound);

template <>
int _arg<int>(std::vector<ivy_value> &args, unsigned idx, int bound) {
    int res = atoi(args[idx].atom.c_str());
    if (bound && (res < 0 || res >= bound) || args[idx].fields.size())
        throw out_of_bounds(idx,args[idx].pos);
    return res;
}

std::ostream &operator <<(std::ostream &s, const __strlit &t){
    s << "\"" << t.c_str() << "\"";
    return s;
}

template <>
__strlit _arg<__strlit>(std::vector<ivy_value> &args, unsigned idx, int bound) {
    if (args[idx].fields.size())
        throw out_of_bounds(idx,args[idx].pos);
    return args[idx].atom;
}

template <class T> void __ser(ivy_ser &res, const T &inp);

template <>
void __ser<int>(ivy_ser &res, const int &inp) {
    res.set(inp);
}

template <>
void __ser<bool>(ivy_ser &res, const bool &inp) {
    res.set(inp);
}

template <>
void __ser<__strlit>(ivy_ser &res, const __strlit &inp) {
    res.set(inp);
}

template <class T> void __deser(ivy_deser &inp, T &res);

template <>
void __deser<int>(ivy_deser &inp, int &res) {
    inp.get(res);
}

template <>
void __deser<__strlit>(ivy_deser &inp, __strlit &res) {
    inp.get(res);
}

template <>
void __deser<bool>(ivy_deser &inp, bool &res) {
    int thing;
    inp.get(thing);
    res = thing;
}

class gen;

int helloworld::___ivy_choose(int rng,const char *name,int id) {
        return 0;
    }
void helloworld::world(){
    ___ivy_stack.push_back(2);
    imp__world();
    ___ivy_stack.pop_back();
}
void helloworld::imp__world(){
    {
    }
}
void helloworld::hello(){
    ___ivy_stack.push_back(1);
    world();
    ___ivy_stack.pop_back();
}
void helloworld::__init(){
    {
    }
}
void helloworld::__tick(int __timeout){
}
helloworld::helloworld(){
#ifdef _WIN32
mutex = CreateMutex(NULL,FALSE,NULL);
#endif
{
}
}


int ask_ret(int bound) {
    int res;
    while(true) {
        __out << "? ";
        std::cin >> res;
        if (res >= 0 && res < bound) 
            return res;
        std::cerr << "value out of range" << std::endl;
    }
}



    class helloworld_repl : public helloworld {

    public:

    virtual void ivy_assert(bool truth,const char *msg){
        if (!truth) {
            std::cerr << msg << ": assertion failed\n";
            exit(1);
        }
    }
    virtual void ivy_assume(bool truth,const char *msg){
        if (!truth) {
            std::cerr << msg << ": assumption failed\n";
            exit(1);
        }
    }
    helloworld_repl() : helloworld(){}
    virtual void imp__world(){
    __out << "< world" << std::endl;
}

    };

// Override methods to implement low-level network service

bool is_white(int c) {
    return (c == ' ' || c == '\t' || c == '\n' || c == '\r');
}

bool is_ident(int c) {
    return c == '_' || c == '.' || (c >= 'A' &&  c <= 'Z')
        || (c >= 'a' &&  c <= 'z')
        || (c >= '0' &&  c <= '9');
}

void skip_white(const std::string& str, int &pos){
    while (pos < str.size() && is_white(str[pos]))
        pos++;
}

struct syntax_error {
    int pos;
    syntax_error(int pos) : pos(pos) {}
};

void throw_syntax(int pos){
    throw syntax_error(pos);
}

std::string get_ident(const std::string& str, int &pos) {
    std::string res = "";
    while (pos < str.size() && is_ident(str[pos])) {
        res.push_back(str[pos]);
        pos++;
    }
    if (res.size() == 0)
        throw_syntax(pos);
    return res;
}

ivy_value parse_value(const std::string& cmd, int &pos) {
    ivy_value res;
    res.pos = pos;
    skip_white(cmd,pos);
    if (pos < cmd.size() && cmd[pos] == '[') {
        while (true) {
            pos++;
            skip_white(cmd,pos);
            if (pos < cmd.size() && cmd[pos] == ']')
                break;
            res.fields.push_back(parse_value(cmd,pos));
            skip_white(cmd,pos);
            if (pos < cmd.size() && cmd[pos] == ']')
                break;
            if (!(pos < cmd.size() && cmd[pos] == ','))
                throw_syntax(pos);
        }
        pos++;
    }
    else if (pos < cmd.size() && cmd[pos] == '{') {
        while (true) {
            ivy_value field;
            pos++;
            skip_white(cmd,pos);
            field.atom = get_ident(cmd,pos);
            skip_white(cmd,pos);
            if (!(pos < cmd.size() && cmd[pos] == ':'))
                 throw_syntax(pos);
            pos++;
            skip_white(cmd,pos);
            field.fields.push_back(parse_value(cmd,pos));
            res.fields.push_back(field);
            skip_white(cmd,pos);
            if (pos < cmd.size() && cmd[pos] == '}')
                break;
            if (!(pos < cmd.size() && cmd[pos] == ','))
                throw_syntax(pos);
        }
        pos++;
    }
    else if (pos < cmd.size() && cmd[pos] == '"') {
        pos++;
        res.atom = "";
        while (pos < cmd.size() && cmd[pos] != '"')
            res.atom.push_back(cmd[pos++]);
        if(pos == cmd.size())
            throw_syntax(pos);
        pos++;
    }
    else 
        res.atom = get_ident(cmd,pos);
    return res;
}

void parse_command(const std::string &cmd, std::string &action, std::vector<ivy_value> &args) {
    int pos = 0;
    skip_white(cmd,pos);
    action = get_ident(cmd,pos);
    skip_white(cmd,pos);
    if (pos < cmd.size() && cmd[pos] == '(') {
        pos++;
        skip_white(cmd,pos);
        args.push_back(parse_value(cmd,pos));
        while(true) {
            skip_white(cmd,pos);
            if (!(pos < cmd.size() && cmd[pos] == ','))
                break;
            pos++;
            args.push_back(parse_value(cmd,pos));
        }
        if (!(pos < cmd.size() && cmd[pos] == ')'))
            throw_syntax(pos);
        pos++;
    }
    skip_white(cmd,pos);
    if (pos != cmd.size())
        throw_syntax(pos);
}

struct bad_arity {
    std::string action;
    int num;
    bad_arity(std::string &_action, unsigned _num) : action(_action), num(_num) {}
};

void check_arity(std::vector<ivy_value> &args, unsigned num, std::string &action) {
    if (args.size() != num)
        throw bad_arity(action,num);
}

template <>
bool _arg<bool>(std::vector<ivy_value> &args, unsigned idx, int bound) {
    if (!(args[idx].atom == "true" || args[idx].atom == "false") || args[idx].fields.size())
        throw out_of_bounds(idx,args[idx].pos);
    return args[idx].atom == "true";
}



class stdin_reader: public reader {
    std::string buf;
    std::string eof_flag;

public:
    bool eof(){
      return eof_flag.size();
    }
    virtual int fdes(){
        return 0;
    }
    virtual void read() {
        char tmp[257];
        int chars = ::read(0,tmp,256);
        if (chars == 0) {  // EOF
            if (buf.size())
                process(buf);
            eof_flag = "eof";
        }
        tmp[chars] = 0;
        buf += std::string(tmp);
        size_t pos;
        while ((pos = buf.find('\n')) != std::string::npos) {
            std::string line = buf.substr(0,pos+1);
            buf.erase(0,pos+1);
            process(line);
        }
    }
    virtual void process(const std::string &line) {
        __out << line;
    }
};

class cmd_reader: public stdin_reader {
    int lineno;
public:
    helloworld_repl &ivy;    

    cmd_reader(helloworld_repl &_ivy) : ivy(_ivy) {
        lineno = 1;
        if (isatty(fdes()))
            __out << "> "; __out.flush();
    }

    virtual void process(const std::string &cmd) {
        std::string action;
        std::vector<ivy_value> args;
        try {
            parse_command(cmd,action,args);

                if (action == "hello") {
                    check_arity(args,0,action);
                    ivy.hello();
                }
                else
    
            {
                std::cerr << "undefined action: " << action << std::endl;
            }
        }
        catch (syntax_error& err) {
            std::cerr << "line " << lineno << ":" << err.pos << ": syntax error" << std::endl;
        }
        catch (out_of_bounds &err) {
            std::cerr << "line " << lineno << ":" << err.pos << ": " << err.txt << " bad value" << std::endl;
        }
        catch (bad_arity &err) {
            std::cerr << "action " << err.action << " takes " << err.num  << " input parameters" << std::endl;
        }
        if (isatty(fdes()))
            __out << "> "; __out.flush();
        lineno++;
    }
};


std::vector<reader *> readers;

void install_reader(reader *r){
    readers.push_back(r);
}

std::vector<timer *> timers;

void install_timer(timer *r){
    timers.push_back(r);
}
int main(int argc, char **argv){
        int test_iters = 1000;

    std::vector<char *> pargs; // positional args
    pargs.push_back(argv[0]);
    for (int i = 1; i < argc; i++) {
        std::string arg = argv[i];
        size_t p = arg.find('=');
        if (p == std::string::npos)
            pargs.push_back(argv[i]);
        else {
            std::string param = arg.substr(0,p);
            std::string value = arg.substr(p);
            if (param == "out") {
                __out.open(value.c_str());
                if (!__out) {
                    std::cerr << "cannot open to write: " << value << std::endl;
                    return 1;
                }
            }
            else if (param == "out") {
                test_iters = atoi(value.c_str());
            }
            else {
                std::cerr << "unknown option: " << param << std::endl;
                return 1;
            }
        }
    }
    if (!__out)
        __out.basic_ios<char>::rdbuf(std::cout.rdbuf());
    argc = pargs.size();
    argv = &pargs[0];
    if (argc == 2){
        argc--;
        __in.open(argv[argc]);
        if (__in){
            std::cerr << "cannot open to read: " << argv[argc] << "\n";
            exit(1);
        }
    }

    if (!__in)
        __in.basic_ios<char>::rdbuf(std::cin.rdbuf());
    if (argc != 1){
        std::cerr << "usage: helloworld \n";
        exit(1);
    }
    std::vector<std::string> args;
    std::vector<ivy_value> arg_values(1);
    for(int i = 1; i < argc;i++){args.push_back(argv[i]);}
    helloworld_repl ivy;


#ifdef _WIN32
    // Boilerplate from windows docs

    {
        WORD wVersionRequested;
        WSADATA wsaData;
        int err;

    /* Use the MAKEWORD(lowbyte, highbyte) macro declared in Windef.h */
        wVersionRequested = MAKEWORD(2, 2);

        err = WSAStartup(wVersionRequested, &wsaData);
        if (err != 0) {
            /* Tell the user that we could not find a usable */
            /* Winsock DLL.                                  */
            printf("WSAStartup failed with error: %d\n", err);
            return 1;
        }

    /* Confirm that the WinSock DLL supports 2.2.*/
    /* Note that if the DLL supports versions greater    */
    /* than 2.2 in addition to 2.2, it will still return */
    /* 2.2 in wVersion since that is the version we      */
    /* requested.                                        */

        if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2) {
            /* Tell the user that we could not find a usable */
            /* WinSock DLL.                                  */
            printf("Could not find a usable version of Winsock.dll\n");
            WSACleanup();
            return 1;
        }
    }
#endif



    cmd_reader *cr = new cmd_reader(ivy);
    install_reader(cr);

#ifdef _WIN32
    // TODO: Windows can't do asynchronous console I/O. This will have to be handled with
    // threads at some future time. For now, just read from the console unitl EOF.
    while (!cr->eof())
        cr->read();
    return 0;
#endif

    while(true) {

        fd_set rdfds;
        FD_ZERO(&rdfds);
        int maxfds = 0;

        if (cr->eof())
            return 0;

        int foo;

        int timer_min = 1000;
        for (unsigned i = 0; i < timers.size(); i++){
            int t = timers[i]->ms_delay();
            if (t < timer_min) 
                timer_min = t;
        }

#if 0
        {
            std::vector<WSAEVENT> handles;

            for (unsigned i = 0; i < readers.size(); i++) {
                reader *r = readers[i];
                int fds = r->fdes();
                WSAEVENT ev = WSACreateEvent();
                if (ev == WSA_INVALID_EVENT)
                { 
                    printf("WSACreateEvent() failed with error %d\n", WSAGetLastError());
                    return 1;
                }
                if (WSAEventSelect(fds, ev, FD_READ) == SOCKET_ERROR)
                {
                     printf("WSAEventSelect() failed with error %d\n", WSAGetLastError());
                     return 1;
                }
                // HANDLE h = (HANDLE)_get_osfhandle(fds);
                handles.push_back(ev);
            }

            int timer_min = 1000;
            for (unsigned i = 0; i < timers.size(); i++){
                int t = timers[i]->ms_delay();
                if (t < timer_min) 
                    timer_min = t;
            }

            struct timeval timeout;
            timeout.tv_sec = timer_min/1000;
            timeout.tv_usec = 1000 * (timer_min % 1000);

            DWORD res = WaitForMultipleObjectsEx(handles.size(),&handles[0],false,timer_min,false);

            if (res == WAIT_FAILED)
            {
                printf("select failed with error: %d\n", GetLastError());
                exit(1);
            }

            foo = res != WAIT_TIMEOUT;
    
            if (foo) {
                int idx = res - WSA_WAIT_EVENT_0;

            } 

        }
#else
        for (unsigned i = 0; i < readers.size(); i++) {
            reader *r = readers[i];
            int fds = r->fdes();
            FD_SET(fds,&rdfds);
            if (fds > maxfds)
                maxfds = fds;
        }


        struct timeval timeout;
        timeout.tv_sec = timer_min/1000;
        timeout.tv_usec = 1000 * (timer_min % 1000);

        foo = select(maxfds+1,&rdfds,0,0,&timeout);

        if (foo < 0)
        {
            perror("select failed"); 
            exit(1);
        }
#endif        
        if (foo == 0){
            // std::cout << "TIMEOUT\n";            
           for (unsigned i = 0; i < timers.size(); i++)
               timers[i]->timeout(timer_min);
        }
        else {
            for (unsigned i = 0; i < readers.size(); i++) {
                reader *r = readers[i];
                if (FD_ISSET(r->fdes(),&rdfds))
                    r->read();
            }
        }            
    }
}
