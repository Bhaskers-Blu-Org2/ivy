#include "udp_test.h"

#include <sstream>
#include <algorithm>

#include <iostream>
#include <stdlib.h>
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h> 
#include <sys/select.h>
#include <string.h>
#include <stdio.h>
#include <string>
#include <unistd.h>
typedef udp_test ivy_class;
struct thunk__foo__impl__handle_recv{
    udp_test *__ivy;
    int X;
    thunk__foo__impl__handle_recv(udp_test *__ivy, int X): __ivy(__ivy),X(X){}
    void operator()(int x) const {
        __ivy->foo__impl__handle_recv(X,x);
    }
};

class reader {
public:
    virtual int fdes() = 0;
    virtual void read() = 0;
};
void install_reader(reader *);
class timer {
public:
    virtual int ms_delay() = 0;
    virtual void timeout() = 0;
};
void install_timer(timer *);
struct ivy_value {
    std::string atom;
    std::vector<ivy_value> fields;
    bool is_member() const {
        return atom.size() && fields.size();
    }
};
struct out_of_bounds {
    int idx;
    out_of_bounds(int _idx) : idx(_idx) {}
};

template <class T> T _arg(std::vector<ivy_value> &args, unsigned idx, int bound);

template <>
int _arg<int>(std::vector<ivy_value> &args, unsigned idx, int bound) {
    int res = atoi(args[idx].atom.c_str());
    if (bound && (res < 0 || res >= bound) || args[idx].fields.size())
        throw out_of_bounds(idx);
    return res;
}

template <class T> void __ser(std::vector<char> &res, const T &inp);

template <>
void __ser<int>(std::vector<char> &res, const int &inp) {
    for (int i = sizeof(int)-1; i >= 0 ; i--)
        res.push_back((inp>>(8*i))&0xff);
}

template <>
void __ser<bool>(std::vector<char> &res, const bool &inp) {
        res.push_back(inp);
}

struct deser_err {
};

template <class T> void __deser(const std::vector<char> &inp, unsigned &pos, T &res);

template <>
void __deser<int>(const std::vector<char> &inp, unsigned &pos, int &res) {
    if (inp.size() < pos + sizeof(int))
        throw deser_err();
    res = 0;
    for (int i = 0; i < sizeof(int); i++)
        res = (res << 8) | (((int)inp[pos++]) & 0xff);
}

template <>
void __deser<bool>(const std::vector<char> &inp, unsigned &pos, bool &res) {
    if (inp.size() < pos + 1)
        throw deser_err();
    res = inp[pos++] ? true : false;
}

	class udp_reader : public reader {
	    int sock;
	    int my_id;
	    thunk__foo__impl__handle_recv rcb;
	  public:
	    udp_reader(int _my_id, thunk__foo__impl__handle_recv rcb)
	        : my_id(_my_id), rcb(rcb) {
		sock = socket(AF_INET, SOCK_DGRAM, 0);
		if (sock < 0)
		    { std::cerr << "cannot create socket\n"; exit(1); }

		struct sockaddr_in myaddr;
		memset((char *)&myaddr, 0, sizeof(myaddr));
		myaddr.sin_family = AF_INET;
		myaddr.sin_addr.s_addr = htonl(INADDR_ANY);
		myaddr.sin_port = htons(4990+my_id);
		if (bind(sock, (struct sockaddr *)&myaddr, sizeof(myaddr)) < 0)
		    { std::cerr << "bind failed\n"; exit(1); }

	    }

	    virtual int fdes() {
		return sock;
	    }
	    virtual void read() {
		//std::cout << "RECEIVING\n";
	        int len;
                socklen_t lenlen;
	        if (getsockopt(sock,SOL_SOCKET,SO_RCVBUF,&len,&lenlen))
	            { std::cerr << "getsockopt failed\n"; exit(1); }
	        std::vector<char> buf(len);
		if (recvfrom(sock,&buf[0],sizeof(int),0,0,0) < 0)
		    { std::cerr << "recvfrom failed\n"; exit(1); }
	        int pkt;
	        try {
	            unsigned pos = 0;
		    __deser(buf,pos,pkt);
	            if (pos < buf.size())
	                throw deser_err();
                } catch (deser_err &){
		    std::cout << "BAD PACKET RECEIVED\n";
		    return;
		}
		rcb(pkt);
	    }
	    virtual void write(int dst, int pkt) {
		struct sockaddr_in dstaddr;
		memset((char *)&dstaddr, 0, sizeof(dstaddr));
		dstaddr.sin_family = AF_INET;
		dstaddr.sin_addr.s_addr = htonl(INADDR_ANY);
		dstaddr.sin_port = htons(4990+dst);

	        std::vector<char> buf;
	        __ser(buf,pkt);
		//std::cout << "SENDING\n";
		if (sendto(sock,&buf[0],buf.size(),0,(sockaddr *)&dstaddr,sizeof(sockaddr_in)) < 0) 
		     { std::cerr << "sendto failed\n"; exit(1); }
	    }
	};
    int udp_test::___ivy_choose(int rng,const char *name,int id) {
        return 0;
    }
void udp_test::ext__imp__foo__recv(int dst, int v){
    {
    }
}
void udp_test::imp__foo__recv(int dst, int v){
    {
    }
}
void udp_test::ext__foo__send(int src, int dst, int v){
    {

        foo__impl__rdr[src]->write(dst,v);
    }
}
void udp_test::foo__impl__handle_recv(int X, int x){
    ___ivy_stack.push_back(14);
    ext__foo__recv(X, x);
    ___ivy_stack.pop_back();
}
void udp_test::foo__spec__recv__before__(int dst, int v){
    {
    }
}
void udp_test::ext__foo__impl__handle_recv(int X, int x){
    ___ivy_stack.push_back(15);
    ext__foo__recv(X, x);
    ___ivy_stack.pop_back();
}
void udp_test::foo__spec__send__before__(int src, int dst, int v){
    {
    }
}
void udp_test::ext__foo__recv(int dst, int v){
    ___ivy_stack.push_back(16);
    imp__foo__recv(dst, v);
    ___ivy_stack.pop_back();
}
void udp_test::ext__foo__spec__send__before__(int src, int dst, int v){
    {
    }
}
void udp_test::__init(){
    {
    }
}
void udp_test::foo__send(int src, int dst, int v){
    {

        foo__impl__rdr[src]->write(dst,v);
    }
}
void udp_test::ext__foo__spec__recv__before__(int dst, int v){
    {
    }
}
void udp_test::foo__recv(int dst, int v){
    ___ivy_stack.push_back(17);
    imp__foo__recv(dst, v);
    ___ivy_stack.pop_back();
}
void udp_test::ext__foo__impl__send__implement__(int X, int dst, int x){

    foo__impl__rdr[X]->write(dst,x);
}
void udp_test::foo__impl__send__implement__(int X, int dst, int x){

    foo__impl__rdr[X]->write(dst,x);
}
void udp_test::__tick(int __timeout){
}
udp_test::udp_test(){
    __CARD__a = 2;
    __CARD__p = 65536;
{
}
    for (int X = 0; X < 2; X++) {
        install_reader(foo__impl__rdr[X] = new udp_reader(X,thunk__foo__impl__handle_recv(this, X)));
    }
}


int ask_ret(int bound) {
    int res;
    while(true) {
        std::cout << "? ";
        std::cin >> res;
        if (res >= 0 && res < bound) 
            return res;
        std::cout << "value out of range" << std::endl;
    }
}



    class udp_test_repl : public udp_test {

    public:

    virtual void ivy_assert(bool truth,const char *msg){
        if (!truth) {
            std::cerr << msg << ": assertion failed\n";
            exit(1);
        }
    }
    virtual void ivy_assume(bool truth,const char *msg){
        if (!truth) {
            std::cerr << msg << ": assumption failed\n";
            exit(1);
        }
    }
    udp_test_repl() : udp_test(){}
    virtual void imp__foo__recv(int dst, int v){
    std::cout << "foo.recv" << "(" << dst << "," << v << ")" << std::endl;
}

    };

// Override methods to implement low-level network service

bool is_white(int c) {
    return (c == ' ' || c == '\t' || c == '\n');
}

bool is_ident(int c) {
    return c == '_' || c == '.' || (c >= 'A' &&  c <= 'Z')
        || (c >= 'a' &&  c <= 'z')
        || (c >= '0' &&  c <= '9');
}

void skip_white(const std::string& str, int &pos){
    while (pos < str.size() && is_white(str[pos]))
        pos++;
}

struct syntax_error {
};

std::string get_ident(const std::string& str, int &pos) {
    std::string res = "";
    while (pos < str.size() && is_ident(str[pos])) {
        res.push_back(str[pos]);
        pos++;
    }
    if (res.size() == 0)
        throw syntax_error();
    return res;
}

ivy_value parse_value(const std::string& cmd, int &pos) {
    ivy_value res;
    skip_white(cmd,pos);
    if (pos < cmd.size() && cmd[pos] == '[') {
        while (true) {
            pos++;
            skip_white(cmd,pos);
            res.fields.push_back(parse_value(cmd,pos));
            skip_white(cmd,pos);
            if (pos < cmd.size() && cmd[pos] == ']')
                break;
            if (!(pos < cmd.size() && cmd[pos] == ','))
                throw syntax_error();
        }
        pos++;
    }
    else if (pos < cmd.size() && cmd[pos] == '{') {
        while (true) {
            ivy_value field;
            pos++;
            skip_white(cmd,pos);
            field.atom = get_ident(cmd,pos);
            skip_white(cmd,pos);
            if (!(pos < cmd.size() && cmd[pos] == ':'))
                 throw syntax_error();
            pos++;
            skip_white(cmd,pos);
            field.fields.push_back(parse_value(cmd,pos));
            res.fields.push_back(field);
            skip_white(cmd,pos);
            if (pos < cmd.size() && cmd[pos] == '}')
                break;
            if (!(pos < cmd.size() && cmd[pos] == ','))
                throw syntax_error();
        }
        pos++;
    }
    else 
        res.atom = get_ident(cmd,pos);
    return res;
}

void parse_command(const std::string &cmd, std::string &action, std::vector<ivy_value> &args) {
    int pos = 0;
    skip_white(cmd,pos);
    action = get_ident(cmd,pos);
    skip_white(cmd,pos);
    if (pos < cmd.size() && cmd[pos] == '(') {
        pos++;
        skip_white(cmd,pos);
        args.push_back(parse_value(cmd,pos));
        while(true) {
            skip_white(cmd,pos);
            if (!(pos < cmd.size() && cmd[pos] == ','))
                break;
            pos++;
            args.push_back(parse_value(cmd,pos));
        }
        if (!(pos < cmd.size() && cmd[pos] == ')'))
            throw syntax_error();
        pos++;
    }
    skip_white(cmd,pos);
    if (pos != cmd.size())
        throw syntax_error();
}

struct bad_arity {
    std::string action;
    int num;
    bad_arity(std::string &_action, unsigned _num) : action(_action), num(_num) {}
};

void check_arity(std::vector<ivy_value> &args, unsigned num, std::string &action) {
    if (args.size() != num)
        throw bad_arity(action,num);
}

template <>
bool _arg<bool>(std::vector<ivy_value> &args, unsigned idx, int bound) {
    if (!(args[idx].atom == "true" || args[idx].atom == "false") || args[idx].fields.size())
        throw out_of_bounds(idx);
    return args[idx].atom == "true";
}



class stdin_reader: public reader {
    std::string buf;

    virtual int fdes(){
        return 0;
    }
    virtual void read() {
        char tmp[257];
        int chars = ::read(0,tmp,256);
        tmp[chars] = 0;
        buf += std::string(tmp);
        size_t pos;
        while ((pos = buf.find('\n')) != std::string::npos) {
            std::string line = buf.substr(0,pos+1);
            buf.erase(0,pos+1);
            process(line);
        }
    }
    virtual void process(const std::string &line) {
        std::cout << line;
    }
};

class cmd_reader: public stdin_reader {

public:
    udp_test_repl &ivy;    

    cmd_reader(udp_test_repl &_ivy) : ivy(_ivy) {
        std::cout << "> "; std::cout.flush();
    }

    virtual void process(const std::string &cmd) {
        std::string action;
        std::vector<ivy_value> args;
        try {
            parse_command(cmd,action,args);

            if (action == "foo.send") {
                check_arity(args,3,action);
                ivy.ext__foo__send(_arg<int>(args,0,2),_arg<int>(args,1,2),_arg<int>(args,2,65536));
            }
            else

            {
                std::cout << "undefined action: " << action << std::endl;
            }
        }
        catch (syntax_error&) {
            std::cout << "syntax error" << std::endl;
        }
        catch (out_of_bounds &err) {
            std::cout << "argument " << err.idx + 1 << " out of bounds" << std::endl;
        }
        catch (bad_arity &err) {
            std::cout << "action " << err.action << " takes " << err.num  << " input parameters" << std::endl;
        }
        std::cout << "> "; std::cout.flush();
    }
};


std::vector<reader *> readers;

void install_reader(reader *r){
    readers.push_back(r);
}

std::vector<timer *> timers;

void install_timer(timer *r){
    timers.push_back(r);
}
int main(int argc, char **argv){
    if (argc != 1){
        std::cerr << "usage: udp_test \n";
        exit(1);
    }
    std::vector<std::string> args;
    std::vector<ivy_value> arg_values(1);
    for(int i = 1; i < argc;i++){args.push_back(argv[i]);}
    udp_test_repl ivy;

    install_reader(new cmd_reader(ivy));

    while(true) {

        fd_set rdfds;
        FD_ZERO(&rdfds);
        int maxfds = 0;

        for (unsigned i = 0; i < readers.size(); i++) {
            reader *r = readers[i];
            int fds = r->fdes();
            FD_SET(fds,&rdfds);
            if (fds > maxfds)
                maxfds = fds;
        }

        struct timeval timeout;
        timeout.tv_sec = 1;
        timeout.tv_usec = 0;

        int foo = select(maxfds+1,&rdfds,0,0,&timeout);

        if (foo < 0)
            {perror("select failed"); exit(1);}
        
        if (foo == 0){
            // std::cout << "TIMEOUT\n";            
           for (unsigned i = 0; i < timers.size(); i++)
               timers[i]->timeout();
        }
        else {
            for (unsigned i = 0; i < readers.size(); i++) {
                reader *r = readers[i];
                if (FD_ISSET(r->fdes(),&rdfds))
                    r->read();
            }
        }            
    }
}
