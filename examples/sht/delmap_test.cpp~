#include "delmap_test.h"

#include <sstream>
#include <algorithm>

#include <iostream>
#include <stdlib.h>
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h> 
#include <sys/select.h>
#include <string.h>
#include <stdio.h>
#include <string>
#include <unistd.h>
typedef delmap_test ivy_class;

#include <string>
#include <vector>
#include <sstream>
#include <cstdlib>
#include "z3++.h"


using namespace hash_space;

class gen : public ivy_gen {

public:
    z3::context ctx;
protected:
    z3::solver slvr;
    z3::model model;

    gen(): slvr(ctx), model(ctx,(Z3_model)0) {}

    hash_map<std::string, z3::sort> enum_sorts;
    hash_map<Z3_sort, z3::func_decl_vector> enum_values;
    hash_map<std::string, z3::func_decl> decls_by_name;
    hash_map<Z3_symbol,int> enum_to_int;
    std::vector<Z3_symbol> sort_names;
    std::vector<Z3_sort> sorts;
    std::vector<Z3_symbol> decl_names;
    std::vector<Z3_func_decl> decls;
    std::vector<z3::expr> alits;


public:
    virtual bool generate(delmap_test& obj)=0;
    virtual bool execute(delmap_test& obj)=0;
    virtual ~gen(){}

    z3::expr mk_apply_expr(const char *decl_name, unsigned num_args, const int *args){
        z3::func_decl decl = decls_by_name.find(decl_name)->second;
        std::vector<z3::expr> expr_args;
        unsigned arity = decl.arity();
        assert(arity == num_args);
        for(unsigned i = 0; i < arity; i ++) {
            z3::sort sort = decl.domain(i);
            expr_args.push_back(int_to_z3(sort,args[i]));
        }
        return decl(arity,&expr_args[0]);
    }

    int eval(const z3::expr &apply_expr) {
        try {
            z3::expr foo = model.eval(apply_expr,true);
            if (foo.is_bv()) {
                assert(foo.is_numeral());
                int v;
                if (Z3_get_numeral_int(ctx,foo,&v) != Z3_TRUE)
                    assert(false && "bit vector value too large for machine int");
                return v;
            }
            assert(foo.is_app());
            if (foo.is_bool())
                return (foo.decl().decl_kind() == Z3_OP_TRUE) ? 1 : 0;
            return enum_to_int[foo.decl().name()];
        }
        catch (const z3::exception &e) {
            std::cout << e << std::endl;
            throw e;
        }
    }

    int eval_apply(const char *decl_name, unsigned num_args, const int *args) {
        z3::expr apply_expr = mk_apply_expr(decl_name,num_args,args);
        //        std::cout << "apply_expr: " << apply_expr << std::endl;
        try {
            z3::expr foo = model.eval(apply_expr,true);
            if (foo.is_bv()) {
                assert(foo.is_numeral());
                int v;
                if (Z3_get_numeral_int(ctx,foo,&v) != Z3_TRUE)
                    assert(false && "bit vector value too large for machine int");
                return v;
            }
            assert(foo.is_app());
            if (foo.is_bool())
                return (foo.decl().decl_kind() == Z3_OP_TRUE) ? 1 : 0;
            return enum_to_int[foo.decl().name()];
        }
        catch (const z3::exception &e) {
            std::cout << e << std::endl;
            throw e;
        }
    }

    int eval_apply(const char *decl_name) {
        return eval_apply(decl_name,0,(int *)0);
    }

    int eval_apply(const char *decl_name, int arg0) {
        return eval_apply(decl_name,1,&arg0);
    }
    
    int eval_apply(const char *decl_name, int arg0, int arg1) {
        int args[2] = {arg0,arg1};
        return eval_apply(decl_name,2,args);
    }

    int eval_apply(const char *decl_name, int arg0, int arg1, int arg2) {
        int args[3] = {arg0,arg1,arg2};
        return eval_apply(decl_name,3,args);
    }

    z3::expr apply(const char *decl_name, std::vector<z3::expr> &expr_args) {
        z3::func_decl decl = decls_by_name.find(decl_name)->second;
        unsigned arity = decl.arity();
        assert(arity == expr_args.size());
        return decl(arity,&expr_args[0]);
    }

    z3::expr apply(const char *decl_name) {
        std::vector<z3::expr> a;
        return apply(decl_name,a);
    }

    z3::expr apply(const char *decl_name, z3::expr arg0) {
        std::vector<z3::expr> a;
        a.push_back(arg0);
        return apply(decl_name,a);
    }
    
    z3::expr apply(const char *decl_name, z3::expr arg0, z3::expr arg1) {
        std::vector<z3::expr> a;
        a.push_back(arg0);
        a.push_back(arg1);
        return apply(decl_name,a);
    }
    
    z3::expr apply(const char *decl_name, z3::expr arg0, z3::expr arg1, z3::expr arg2) {
        std::vector<z3::expr> a;
        a.push_back(arg0);
        a.push_back(arg1);
        a.push_back(arg2);
        return apply(decl_name,a);
    }

    z3::expr int_to_z3(const z3::sort &range, int value) {
        if (range.is_bool())
            return ctx.bool_val(value);
        if (range.is_bv())
            return ctx.bv_val(value,range.bv_size());
        if (range.is_int())
            return ctx.int_val(value);
        return enum_values.find(range)->second[value]();
    }

    unsigned sort_card(const z3::sort &range) {
        if (range.is_bool())
            return 2;
        if (range.is_bv())
            return 1 << range.bv_size();
        if (range.is_int())
            return 1;  // bogus -- we need a good way to randomize ints
        return enum_values.find(range)->second.size();
    }

    int set(const char *decl_name, unsigned num_args, const int *args, int value) {
        z3::func_decl decl = decls_by_name.find(decl_name)->second;
        std::vector<z3::expr> expr_args;
        unsigned arity = decl.arity();
        assert(arity == num_args);
        for(unsigned i = 0; i < arity; i ++) {
            z3::sort sort = decl.domain(i);
            expr_args.push_back(int_to_z3(sort,args[i]));
        }
        z3::expr apply_expr = decl(arity,&expr_args[0]);
        z3::sort range = decl.range();
        z3::expr val_expr = int_to_z3(range,value);
        z3::expr pred = apply_expr == val_expr;
        //        std::cout << "pred: " << pred << std::endl;
        slvr.add(pred);
    }

    int set(const char *decl_name, int value) {
        return set(decl_name,0,(int *)0,value);
    }

    int set(const char *decl_name, int arg0, int value) {
        return set(decl_name,1,&arg0,value);
    }
    
    int set(const char *decl_name, int arg0, int arg1, int value) {
        int args[2] = {arg0,arg1};
        return set(decl_name,2,args,value);
    }

    int set(const char *decl_name, int arg0, int arg1, int arg2, int value) {
        int args[3] = {arg0,arg1,arg2};
        return set(decl_name,3,args,value);
    }

    void randomize(const z3::expr &apply_expr) {
        z3::sort range = apply_expr.get_sort();
        unsigned card = sort_card(range);
        int value = rand() % card;
        z3::expr val_expr = int_to_z3(range,value);
        z3::expr pred = apply_expr == val_expr;
        // std::cout << "pred: " << pred << std::endl;
        std::ostringstream ss;
        ss << "alit:" << alits.size();
        z3::expr alit = ctx.bool_const(ss.str().c_str());
        alits.push_back(alit);
        slvr.add(!alit || pred);
    }

    void randomize(const char *decl_name, unsigned num_args, const int *args) {
        z3::func_decl decl = decls_by_name.find(decl_name)->second;
        z3::expr apply_expr = mk_apply_expr(decl_name,num_args,args);
        z3::sort range = decl.range();
        unsigned card = sort_card(range);
        int value = rand() % card;
        z3::expr val_expr = int_to_z3(range,value);
        z3::expr pred = apply_expr == val_expr;
        // std::cout << "pred: " << pred << std::endl;
        std::ostringstream ss;
        ss << "alit:" << alits.size();
        z3::expr alit = ctx.bool_const(ss.str().c_str());
        alits.push_back(alit);
        slvr.add(!alit || pred);
    }

    void randomize(const char *decl_name) {
        randomize(decl_name,0,(int *)0);
    }

    void randomize(const char *decl_name, int arg0) {
        randomize(decl_name,1,&arg0);
    }
    
    void randomize(const char *decl_name, int arg0, int arg1) {
        int args[2] = {arg0,arg1};
        randomize(decl_name,2,args);
    }

    void randomize(const char *decl_name, int arg0, int arg1, int arg2) {
        int args[3] = {arg0,arg1,arg2};
        randomize(decl_name,3,args);
    }

    void push(){
        slvr.push();
    }

    void pop(){
        slvr.pop();
    }

    z3::sort sort(const char *name) {
        if (std::string("bool") == name)
            return ctx.bool_sort();
        return enum_sorts.find(name)->second;
    }

    void mk_enum(const char *sort_name, unsigned num_values, char const * const * value_names) {
        z3::func_decl_vector cs(ctx), ts(ctx);
        z3::sort sort = ctx.enumeration_sort(sort_name, num_values, value_names, cs, ts);
        // can't use operator[] here because the value classes don't have nullary constructors
        enum_sorts.insert(std::pair<std::string, z3::sort>(sort_name,sort));
        enum_values.insert(std::pair<Z3_sort, z3::func_decl_vector>(sort,cs));
        sort_names.push_back(Z3_mk_string_symbol(ctx,sort_name));
        sorts.push_back(sort);
        for(unsigned i = 0; i < num_values; i++){
            Z3_symbol sym = Z3_mk_string_symbol(ctx,value_names[i]);
            decl_names.push_back(sym);
            decls.push_back(cs[i]);
            enum_to_int[sym] = i;
        }
    }

    void mk_bv(const char *sort_name, unsigned width) {
        z3::sort sort = ctx.bv_sort(width);
        // can't use operator[] here because the value classes don't have nullary constructors
        enum_sorts.insert(std::pair<std::string, z3::sort>(sort_name,sort));
    }

    void mk_int(const char *sort_name) {
        z3::sort sort = ctx.int_sort();
        // can't use operator[] here because the value classes don't have nullary constructors
        enum_sorts.insert(std::pair<std::string, z3::sort>(sort_name,sort));
    }

    void mk_sort(const char *sort_name) {
        Z3_symbol symb = Z3_mk_string_symbol(ctx,sort_name);
        z3::sort sort(ctx,Z3_mk_uninterpreted_sort(ctx, symb));
//        z3::sort sort = ctx.uninterpreted_sort(sort_name);
        // can't use operator[] here because the value classes don't have nullary constructors
        enum_sorts.insert(std::pair<std::string, z3::sort>(sort_name,sort));
    }

    void mk_decl(const char *decl_name, unsigned arity, const char **domain_names, const char *range_name) {
        std::vector<z3::sort> domain;
        for (unsigned i = 0; i < arity; i++)
            domain.push_back(enum_sorts.find(domain_names[i])->second);
        std::string bool_name("Bool");
        z3::sort range = (range_name == bool_name) ? ctx.bool_sort() : enum_sorts.find(range_name)->second;   
        z3::func_decl decl = ctx.function(decl_name,arity,&domain[0],range);
        decl_names.push_back(Z3_mk_string_symbol(ctx,decl_name));
        decls.push_back(decl);
        decls_by_name.insert(std::pair<std::string, z3::func_decl>(decl_name,decl));
    }

    void mk_const(const char *const_name, const char *sort_name) {
        mk_decl(const_name,0,0,sort_name);
    }

    void add(const std::string &z3inp) {
        z3::expr fmla(ctx,Z3_parse_smtlib2_string(ctx, z3inp.c_str(), sort_names.size(), &sort_names[0], &sorts[0], decl_names.size(), &decl_names[0], &decls[0]));
        ctx.check_error();

        slvr.add(fmla);
    }

    bool solve() {
        // std::cout << alits.size();
        while(true){
            z3::check_result res = slvr.check(alits.size(),&alits[0]);
            if (res != z3::unsat)
                break;
            z3::expr_vector core = slvr.unsat_core();
            if (core.size() == 0)
                return false;
            unsigned idx = rand() % core.size();
            z3::expr to_delete = core[idx];
            for (unsigned i = 0; i < alits.size(); i++)
                if (z3::eq(alits[i],to_delete)) {
                    alits[i] = alits.back();
                    alits.pop_back();
                    break;
                }
        }
        model = slvr.get_model();
        alits.clear();
        //        std::cout << model;
        return true;
    }

    int choose(int rng, const char *name){
        if (decls_by_name.find(name) == decls_by_name.end())
            return 0;
        return eval_apply(name);
    }
};

/*++
Copyright (c) Microsoft Corporation

This string hash function is borrowed from Microsoft Z3
(https://github.com/Z3Prover/z3). 

--*/


#define mix(a,b,c)              \
{                               \
  a -= b; a -= c; a ^= (c>>13); \
  b -= c; b -= a; b ^= (a<<8);  \
  c -= a; c -= b; c ^= (b>>13); \
  a -= b; a -= c; a ^= (c>>12); \
  b -= c; b -= a; b ^= (a<<16); \
  c -= a; c -= b; c ^= (b>>5);  \
  a -= b; a -= c; a ^= (c>>3);  \
  b -= c; b -= a; b ^= (a<<10); \
  c -= a; c -= b; c ^= (b>>15); \
}

#define __fallthrough

namespace hash_space {

// I'm using Bob Jenkin's hash function.
// http://burtleburtle.net/bob/hash/doobs.html
unsigned string_hash(const char * str, unsigned length, unsigned init_value) {
    register unsigned a, b, c, len;

    /* Set up the internal state */
    len = length;
    a = b = 0x9e3779b9;  /* the golden ratio; an arbitrary value */
    c = init_value;      /* the previous hash value */

    /*---------------------------------------- handle most of the key */
    while (len >= 12) {
        a += reinterpret_cast<const unsigned *>(str)[0];
        b += reinterpret_cast<const unsigned *>(str)[1];
        c += reinterpret_cast<const unsigned *>(str)[2];
        mix(a,b,c);
        str += 12; len -= 12;
    }

    /*------------------------------------- handle the last 11 bytes */
    c += length;
    switch(len) {        /* all the case statements fall through */
    case 11: 
        c+=((unsigned)str[10]<<24);
        __fallthrough;
    case 10: 
        c+=((unsigned)str[9]<<16);
        __fallthrough;
    case 9 : 
        c+=((unsigned)str[8]<<8);
        __fallthrough;
        /* the first byte of c is reserved for the length */
    case 8 : 
        b+=((unsigned)str[7]<<24);
        __fallthrough;
    case 7 : 
        b+=((unsigned)str[6]<<16);
        __fallthrough;
    case 6 : 
        b+=((unsigned)str[5]<<8);
        __fallthrough;
    case 5 : 
        b+=str[4];
        __fallthrough;
    case 4 : 
        a+=((unsigned)str[3]<<24);
        __fallthrough;
    case 3 : 
        a+=((unsigned)str[2]<<16);
        __fallthrough;
    case 2 : 
        a+=((unsigned)str[1]<<8);
        __fallthrough;
    case 1 : 
        a+=str[0];
        __fallthrough;
        /* case 0: nothing left to add */
    }
    mix(a,b,c);
    /*-------------------------------------------- report the result */
    return c;
}

}


class reader {
public:
    virtual int fdes() = 0;
    virtual void read() = 0;
};
void install_reader(reader *);
class timer {
public:
    virtual int ms_delay() = 0;
    virtual void timeout(int) = 0;
};
void install_timer(timer *);
struct ivy_value {
    std::string atom;
    std::vector<ivy_value> fields;
    bool is_member() const {
        return atom.size() && fields.size();
    }
};
struct out_of_bounds {
    std::string txt;
    out_of_bounds(int _idx) {
        std::ostringstream os;
        os << "argument " << _idx+1;
        txt = os.str();
    }
    out_of_bounds(const std::string &s) : txt(s) {}
};

template <class T> T _arg(std::vector<ivy_value> &args, unsigned idx, int bound);

template <>
int _arg<int>(std::vector<ivy_value> &args, unsigned idx, int bound) {
    int res = atoi(args[idx].atom.c_str());
    if (bound && (res < 0 || res >= bound) || args[idx].fields.size())
        throw out_of_bounds(idx);
    return res;
}

std::ostream &operator <<(std::ostream &s, const __strlit &t){
    s << "\"" << t.c_str() << "\"";
}

template <>
__strlit _arg<__strlit>(std::vector<ivy_value> &args, unsigned idx, int bound) {
    if (args[idx].fields.size())
        throw out_of_bounds(idx);
    return args[idx].atom;
}

template <class T> void __ser(std::vector<char> &res, const T &inp);

template <>
void __ser<int>(std::vector<char> &res, const int &inp) {
    for (int i = sizeof(int)-1; i >= 0 ; i--)
        res.push_back((inp>>(8*i))&0xff);
}

template <>
void __ser<bool>(std::vector<char> &res, const bool &inp) {
        res.push_back(inp);
}

template <>
void __ser<__strlit>(std::vector<char> &res, const __strlit &inp) {
    __ser(res,(int)inp.size());
    for (unsigned i = 0; i < inp.size(); i++)
        res.push_back(inp[i]);
}

struct deser_err {
};

template <class T> void __deser(const std::vector<char> &inp, unsigned &pos, T &res);

template <>
void __deser<int>(const std::vector<char> &inp, unsigned &pos, int &res) {
    if (inp.size() < pos + sizeof(int))
        throw deser_err();
    res = 0;
    for (int i = 0; i < sizeof(int); i++)
        res = (res << 8) | (((int)inp[pos++]) & 0xff);
}

template <>
void __deser<__strlit>(const std::vector<char> &inp, unsigned &pos, __strlit &res) {
    int siz;
    __deser(inp,pos,siz);
    if (inp.size() < pos + siz)
        throw deser_err();
    res = "";
    for (int i = 0; i < siz; i++){
        char c = inp[pos++];
        if (c == 0 || c == '"')
            throw deser_err();
        res.push_back(inp[pos++]);
    }
}

template <>
void __deser<bool>(const std::vector<char> &inp, unsigned &pos, bool &res) {
    if (inp.size() < pos + 1)
        throw deser_err();
    res = inp[pos++] ? true : false;
}

class gen;


template <class T> void __from_solver( gen &g, const  z3::expr &v, T &res);

template <>
void __from_solver<int>( gen &g, const  z3::expr &v, int &res) {
    res = g.eval(v);
}

template <>
void __from_solver<bool>( gen &g, const  z3::expr &v, bool &res) {
    res = g.eval(v);
}

template <class T>
class to_solver_class {
};

template <class T> z3::expr __to_solver( gen &g, const  z3::expr &v, T &val) {
    return to_solver_class<T>()(g,v,val);
}


template <>
z3::expr __to_solver<int>( gen &g, const  z3::expr &v, int &val) {
    return v == g.int_to_z3(v.get_sort(),val);
}

template <>
z3::expr __to_solver<bool>( gen &g, const  z3::expr &v, bool &val) {
    return v == g.int_to_z3(v.get_sort(),val);
}

template <class T> void __randomize( gen &g, const  z3::expr &v);

template <>
void __randomize<int>( gen &g, const  z3::expr &v) {
    g.randomize(v);
}

template <>
void __randomize<bool>( gen &g, const  z3::expr &v) {
    g.randomize(v);
}

template<typename D, typename R>
class z3_thunk : public thunk<D,R> {
    public:
       virtual z3::expr to_z3(gen &g, const  z3::expr &v) = 0;
};

std::ostream &operator <<(std::ostream &s, const delmap_test::key__iter__t &t);
template <>
delmap_test::key__iter__t _arg<delmap_test::key__iter__t>(std::vector<ivy_value> &args, unsigned idx, int bound);
template <>
void  __ser<delmap_test::key__iter__t>(std::vector<char> &res, const delmap_test::key__iter__t&);
template <>
void  __deser<delmap_test::key__iter__t>(const std::vector<char> &inp, unsigned &pos, delmap_test::key__iter__t &res);
template <>
void __from_solver<delmap_test::key__iter__t>( gen &g, const  z3::expr &v, delmap_test::key__iter__t &res);
template <>
z3::expr __to_solver<delmap_test::key__iter__t>( gen &g, const  z3::expr &v, delmap_test::key__iter__t &val);
template <>
void __randomize<delmap_test::key__iter__t>( gen &g, const  z3::expr &v);
int delmap_test::___ivy_choose(int rng,const char *name,int id) {
        std::ostringstream ss;
        ss << name << ':' << id;;
        for (unsigned i = 0; i < ___ivy_stack.size(); i++)
            ss << ':' << ___ivy_stack[i];
        return ___ivy_gen->choose(rng,ss.str().c_str());
    }
bool delmap_test::__lt(key__iter__t X, key__iter__t Y){
    bool val;
    val = (bool)___ivy_choose(2,"ret:val",0);
    val = (((X.val < Y.val) && !X.is_end && !Y.is_end) || (Y.is_end && !X.is_end));
    return val;
}
delmap_test::key__iter__t delmap_test::key__iter__end(){
    key__iter__t y;
    y.is_end = (bool)___ivy_choose(2,"fml:y",0);
    y.val = (int)___ivy_choose(65536,"fml:y",0);
    {
        y.is_end = true;
        y.val = (0 & 65535);
    }
    return y;
}
delmap_test::key__iter__t delmap_test::key__iter__impl__create__implement__(int x){
    key__iter__t y;
    y.is_end = (bool)___ivy_choose(2,"fml:y",0);
    y.val = (int)___ivy_choose(65536,"fml:y",0);
    {
        y.is_end = false;
        y.val = x;
    }
    return y;
}
void delmap_test::dmap__impl__imap__impl__erase__implement__(key__iter__t lo, key__iter__t hi){

    dmap__impl__imap__impl__s.erase(lo.is_end ? dmap__impl__imap__impl__s.end() : dmap__impl__imap__impl__s.lower_bound(lo.val),
              hi.is_end ? dmap__impl__imap__impl__s.end() : dmap__impl__imap__impl__s.upper_bound(hi.val));
}
void delmap_test::ext__dmap__impl__imap__spec__set__after__(int nkey, int v){
    {
    }
}
delmap_test::key__iter__t delmap_test::ext__dmap__impl__imap__spec__next__before__(key__iter__t it){
    key__iter__t res;
    res.is_end = (bool)___ivy_choose(2,"fml:res",0);
    res.val = (int)___ivy_choose(65536,"fml:res",0);
    {
    }
    return res;
}
delmap_test::key__iter__t delmap_test::ext__dmap__impl__imap__impl__lub__implement__(key__iter__t it){
    key__iter__t res;
    res.is_end = (bool)___ivy_choose(2,"fml:res",0);
    res.val = (int)___ivy_choose(65536,"fml:res",0);

    if (it.is_end) {
        res.is_end = true;
        res.val = 0;
    } else {
        std::map<int,int>::iterator __it = dmap__impl__imap__impl__s.lower_bound(it.val);
        if (__it == dmap__impl__imap__impl__s.end()) {
            res.is_end = true;
            res.val = 0;
        } else {
            res.is_end = false;
            res.val = __it->first;
        }
    }
    return res;
}
void delmap_test::ext__dmap__impl__imap__spec__set__before__(int nkey, int v){
    {
    }
}
delmap_test::key__iter__t delmap_test::dmap__impl__imap__impl__glb__implement__(key__iter__t it){
    key__iter__t res;
    res.is_end = (bool)___ivy_choose(2,"fml:res",0);
    res.val = (int)___ivy_choose(65536,"fml:res",0);

    std::map<int,int>::iterator __it = it.is_end ? dmap__impl__imap__impl__s.end() : dmap__impl__imap__impl__s.upper_bound(it.val);
    res.is_end = false;
    res.val = (--__it)->first;
    return res;
}
delmap_test::key__iter__t delmap_test::dmap__impl__imap__impl__next__implement__(key__iter__t inp){
    key__iter__t res;
    res.is_end = (bool)___ivy_choose(2,"fml:res",0);
    res.val = (int)___ivy_choose(65536,"fml:res",0);

    std::map<int,int>::iterator __it = dmap__impl__imap__impl__s.upper_bound(inp.val);
    if (__it == dmap__impl__imap__impl__s.end()) {
        res.is_end = true;
        res.val = 0;
    } else {
        res.is_end = false;
        res.val = __it->first;
    }
    return res;
}
int delmap_test::dmap__impl__imap__get(int k, int def){
    int v;
    v = (int)___ivy_choose(2,"fml:v",0);
    {

        std::map<int,int>::iterator it = dmap__impl__imap__impl__s.find(k);
        if (it == dmap__impl__imap__impl__s.end()) {
            v = def;
        } else {
            v = it->second;
        }
    }
    return v;
}
delmap_test::key__iter__t delmap_test::dmap__impl__imap__spec__next__before__(key__iter__t it){
    key__iter__t res;
    res.is_end = (bool)___ivy_choose(2,"fml:res",0);
    res.val = (int)___ivy_choose(65536,"fml:res",0);
    {
    }
    return res;
}
delmap_test::key__iter__t delmap_test::dmap__impl__imap__spec__glb__after__(key__iter__t it){
    key__iter__t res;
    res.is_end = (bool)___ivy_choose(2,"fml:res",0);
    res.val = (int)___ivy_choose(65536,"fml:res",0);
    {
    }
    return res;
}
void delmap_test::dmap__impl__imap__spec__erase__after__(key__iter__t lo, key__iter__t hi){
    {
    }
}
void delmap_test::ext__dmap__impl__imap__impl__erase__implement__(key__iter__t lo, key__iter__t hi){

    dmap__impl__imap__impl__s.erase(lo.is_end ? dmap__impl__imap__impl__s.end() : dmap__impl__imap__impl__s.lower_bound(lo.val),
              hi.is_end ? dmap__impl__imap__impl__s.end() : dmap__impl__imap__impl__s.upper_bound(hi.val));
}
delmap_test::key__iter__t delmap_test::key__iter__create(int x){
    key__iter__t y;
    y.is_end = (bool)___ivy_choose(2,"fml:y",0);
    y.val = (int)___ivy_choose(65536,"fml:y",0);
    {
        y.is_end = false;
        y.val = x;
    }
    return y;
}
delmap_test::key__iter__t delmap_test::ext__dmap__impl__imap__lub(key__iter__t it){
    key__iter__t res;
    res.is_end = (bool)___ivy_choose(2,"fml:res",0);
    res.val = (int)___ivy_choose(65536,"fml:res",0);
    {

        if (it.is_end) {
            res.is_end = true;
            res.val = 0;
        } else {
            std::map<int,int>::iterator __it = dmap__impl__imap__impl__s.lower_bound(it.val);
            if (__it == dmap__impl__imap__impl__s.end()) {
                res.is_end = true;
                res.val = 0;
            } else {
                res.is_end = false;
                res.val = __it->first;
            }
        }
    }
    return res;
}
void delmap_test::dmap__impl__imap__spec__set__after__(int nkey, int v){
    {
    }
}
delmap_test::key__iter__t delmap_test::dmap__impl__imap__next(key__iter__t it){
    key__iter__t res;
    res.is_end = (bool)___ivy_choose(2,"fml:res",0);
    res.val = (int)___ivy_choose(65536,"fml:res",0);
    {

        std::map<int,int>::iterator __it = dmap__impl__imap__impl__s.upper_bound(it.val);
        if (__it == dmap__impl__imap__impl__s.end()) {
            res.is_end = true;
            res.val = 0;
        } else {
            res.is_end = false;
            res.val = __it->first;
        }
    }
    return res;
}
delmap_test::key__iter__t delmap_test::ext__dmap__impl__imap__spec__glb__after__(key__iter__t it){
    key__iter__t res;
    res.is_end = (bool)___ivy_choose(2,"fml:res",0);
    res.val = (int)___ivy_choose(65536,"fml:res",0);
    {
    }
    return res;
}
void delmap_test::dmap__set(key__iter__t lo, key__iter__t hi, int dst){
    {
        if(__lt(lo,hi)){
            {
                if(!hi.is_end){
                    {
                        int loc__nid;
    loc__nid = (int)___ivy_choose(2,"loc:nid",47);
                        {
                            {
                                key__iter__t loc__0;
    loc__0.is_end = (bool)___ivy_choose(2,"loc:0",46);
    loc__0.val = (int)___ivy_choose(65536,"loc:0",46);
                                int loc__1;
    loc__1 = (int)___ivy_choose(2,"loc:1",46);
                                {
                                    ___ivy_stack.push_back(130);
                                    loc__0 = ext__dmap__impl__imap__glb(hi);
                                    ___ivy_stack.pop_back();
                                    ___ivy_stack.push_back(131);
                                    loc__1 = ext__dmap__impl__imap__get(loc__0.val, (0 & 1));
                                    ___ivy_stack.pop_back();
                                    loc__nid = loc__1;
                                }
                            }
                            ___ivy_stack.push_back(132);
                            ext__dmap__impl__imap__set(hi.val, loc__nid);
                            ___ivy_stack.pop_back();
                        }
                    }
                }
                ___ivy_stack.push_back(133);
                ext__dmap__impl__imap__erase(lo, hi);
                ___ivy_stack.pop_back();
                ___ivy_stack.push_back(134);
                ext__dmap__impl__imap__set(lo.val, dst);
                ___ivy_stack.pop_back();
            }
        }
    }
}
bool delmap_test::ext__dmap__impl__imap__present(int k){
    bool ans;
    ans = (bool)___ivy_choose(2,"fml:ans",0);
    {
    }
    return ans;
}
void delmap_test::ext__dmap__impl__imap__spec__erase__before__(key__iter__t lo, key__iter__t hi){
    {
    }
}
delmap_test::key__iter__t delmap_test::ext__key__iter__create(int x){
    key__iter__t y;
    y.is_end = (bool)___ivy_choose(2,"fml:y",0);
    y.val = (int)___ivy_choose(65536,"fml:y",0);
    {
        y.is_end = false;
        y.val = x;
    }
    return y;
}
void delmap_test::ext__dmap__impl__set__implement__(key__iter__t lo, key__iter__t hi, int dst){
    if(__lt(lo,hi)){
        {
            if(!hi.is_end){
                {
                    int loc__nid;
    loc__nid = (int)___ivy_choose(2,"loc:nid",49);
                    {
                        {
                            key__iter__t loc__0;
    loc__0.is_end = (bool)___ivy_choose(2,"loc:0",48);
    loc__0.val = (int)___ivy_choose(65536,"loc:0",48);
                            int loc__1;
    loc__1 = (int)___ivy_choose(2,"loc:1",48);
                            {
                                ___ivy_stack.push_back(135);
                                loc__0 = ext__dmap__impl__imap__glb(hi);
                                ___ivy_stack.pop_back();
                                ___ivy_stack.push_back(136);
                                loc__1 = ext__dmap__impl__imap__get(loc__0.val, (0 & 1));
                                ___ivy_stack.pop_back();
                                loc__nid = loc__1;
                            }
                        }
                        ___ivy_stack.push_back(137);
                        ext__dmap__impl__imap__set(hi.val, loc__nid);
                        ___ivy_stack.pop_back();
                    }
                }
            }
            ___ivy_stack.push_back(138);
            ext__dmap__impl__imap__erase(lo, hi);
            ___ivy_stack.pop_back();
            ___ivy_stack.push_back(139);
            ext__dmap__impl__imap__set(lo.val, dst);
            ___ivy_stack.pop_back();
        }
    }
}
int delmap_test::dmap__spec__get__after__(int k){
    int val;
    val = (int)___ivy_choose(2,"fml:val",0);
    {
    }
    return val;
}
delmap_test::key__iter__t delmap_test::ext__dmap__impl__imap__spec__lub__after__(key__iter__t it){
    key__iter__t res;
    res.is_end = (bool)___ivy_choose(2,"fml:res",0);
    res.val = (int)___ivy_choose(65536,"fml:res",0);
    {
    }
    return res;
}
delmap_test::key__iter__t delmap_test::dmap__impl__imap__spec__lub__after__(key__iter__t it){
    key__iter__t res;
    res.is_end = (bool)___ivy_choose(2,"fml:res",0);
    res.val = (int)___ivy_choose(65536,"fml:res",0);
    {
    }
    return res;
}
delmap_test::key__iter__t delmap_test::dmap__impl__imap__lub(key__iter__t it){
    key__iter__t res;
    res.is_end = (bool)___ivy_choose(2,"fml:res",0);
    res.val = (int)___ivy_choose(65536,"fml:res",0);
    {

        if (it.is_end) {
            res.is_end = true;
            res.val = 0;
        } else {
            std::map<int,int>::iterator __it = dmap__impl__imap__impl__s.lower_bound(it.val);
            if (__it == dmap__impl__imap__impl__s.end()) {
                res.is_end = true;
                res.val = 0;
            } else {
                res.is_end = false;
                res.val = __it->first;
            }
        }
    }
    return res;
}
delmap_test::key__iter__t delmap_test::ext__dmap__impl__imap__impl__glb__implement__(key__iter__t it){
    key__iter__t res;
    res.is_end = (bool)___ivy_choose(2,"fml:res",0);
    res.val = (int)___ivy_choose(65536,"fml:res",0);

    std::map<int,int>::iterator __it = it.is_end ? dmap__impl__imap__impl__s.end() : dmap__impl__imap__impl__s.upper_bound(it.val);
    res.is_end = false;
    res.val = (--__it)->first;
    return res;
}
int delmap_test::dmap__get(int k){
    int val;
    val = (int)___ivy_choose(2,"fml:val",0);
    {
        {
            key__iter__t loc__0;
    loc__0.is_end = (bool)___ivy_choose(2,"loc:0",50);
    loc__0.val = (int)___ivy_choose(65536,"loc:0",50);
            key__iter__t loc__1;
    loc__1.is_end = (bool)___ivy_choose(2,"loc:1",50);
    loc__1.val = (int)___ivy_choose(65536,"loc:1",50);
            int loc__2;
    loc__2 = (int)___ivy_choose(2,"loc:2",50);
            {
                ___ivy_stack.push_back(140);
                loc__0 = ext__key__iter__create(k);
                ___ivy_stack.pop_back();
                ___ivy_stack.push_back(141);
                loc__1 = ext__dmap__impl__imap__glb(loc__0);
                ___ivy_stack.pop_back();
                ___ivy_stack.push_back(142);
                loc__2 = ext__dmap__impl__imap__get(loc__1.val, (0 & 1));
                ___ivy_stack.pop_back();
                val = loc__2;
            }
        }
    }
    return val;
}
delmap_test::key__iter__t delmap_test::ext__dmap__impl__imap__next(key__iter__t it){
    key__iter__t res;
    res.is_end = (bool)___ivy_choose(2,"fml:res",0);
    res.val = (int)___ivy_choose(65536,"fml:res",0);
    {

        std::map<int,int>::iterator __it = dmap__impl__imap__impl__s.upper_bound(it.val);
        if (__it == dmap__impl__imap__impl__s.end()) {
            res.is_end = true;
            res.val = 0;
        } else {
            res.is_end = false;
            res.val = __it->first;
        }
    }
    return res;
}
void delmap_test::dmap__impl__imap__spec__set__before__(int nkey, int v){
    {
    }
}
void delmap_test::dmap__impl__imap__set(int nkey, int v){
    {

        dmap__impl__imap__impl__s[nkey] = v;
    }
}
delmap_test::key__iter__t delmap_test::ext__dmap__impl__imap__spec__glb__before__(key__iter__t it){
    key__iter__t res;
    res.is_end = (bool)___ivy_choose(2,"fml:res",0);
    res.val = (int)___ivy_choose(65536,"fml:res",0);
    {
    }
    return res;
}
delmap_test::key__iter__t delmap_test::ext__dmap__impl__imap__glb(key__iter__t it){
    key__iter__t res;
    res.is_end = (bool)___ivy_choose(2,"fml:res",0);
    res.val = (int)___ivy_choose(65536,"fml:res",0);
    {

        std::map<int,int>::iterator __it = it.is_end ? dmap__impl__imap__impl__s.end() : dmap__impl__imap__impl__s.upper_bound(it.val);
        res.is_end = false;
        res.val = (--__it)->first;
    }
    return res;
}
delmap_test::key__iter__t delmap_test::dmap__impl__imap__glb(key__iter__t it){
    key__iter__t res;
    res.is_end = (bool)___ivy_choose(2,"fml:res",0);
    res.val = (int)___ivy_choose(65536,"fml:res",0);
    {

        std::map<int,int>::iterator __it = it.is_end ? dmap__impl__imap__impl__s.end() : dmap__impl__imap__impl__s.upper_bound(it.val);
        res.is_end = false;
        res.val = (--__it)->first;
    }
    return res;
}
void delmap_test::dmap__impl__imap__spec__erase__before__(key__iter__t lo, key__iter__t hi){
    {
    }
}
void delmap_test::ext__dmap__impl__imap__spec__erase__after__(key__iter__t lo, key__iter__t hi){
    {
    }
}
void delmap_test::ext__dmap__set(key__iter__t lo, key__iter__t hi, int dst){
    {
        if(__lt(lo,hi)){
            {
                if(!hi.is_end){
                    {
                        int loc__nid;
    loc__nid = (int)___ivy_choose(2,"loc:nid",52);
                        {
                            {
                                key__iter__t loc__0;
    loc__0.is_end = (bool)___ivy_choose(2,"loc:0",51);
    loc__0.val = (int)___ivy_choose(65536,"loc:0",51);
                                int loc__1;
    loc__1 = (int)___ivy_choose(2,"loc:1",51);
                                {
                                    ___ivy_stack.push_back(143);
                                    loc__0 = ext__dmap__impl__imap__glb(hi);
                                    ___ivy_stack.pop_back();
                                    ___ivy_stack.push_back(144);
                                    loc__1 = ext__dmap__impl__imap__get(loc__0.val, (0 & 1));
                                    ___ivy_stack.pop_back();
                                    loc__nid = loc__1;
                                }
                            }
                            ___ivy_stack.push_back(145);
                            ext__dmap__impl__imap__set(hi.val, loc__nid);
                            ___ivy_stack.pop_back();
                        }
                    }
                }
                ___ivy_stack.push_back(146);
                ext__dmap__impl__imap__erase(lo, hi);
                ___ivy_stack.pop_back();
                ___ivy_stack.push_back(147);
                ext__dmap__impl__imap__set(lo.val, dst);
                ___ivy_stack.pop_back();
            }
        }
    }
}
int delmap_test::dmap__impl__imap__spec__get__after__(int k, int def){
    int v;
    v = (int)___ivy_choose(2,"fml:v",0);
    {
    }
    return v;
}
void delmap_test::dmap__impl__set__implement__(key__iter__t lo, key__iter__t hi, int dst){
    if(__lt(lo,hi)){
        {
            if(!hi.is_end){
                {
                    int loc__nid;
    loc__nid = (int)___ivy_choose(2,"loc:nid",54);
                    {
                        {
                            key__iter__t loc__0;
    loc__0.is_end = (bool)___ivy_choose(2,"loc:0",53);
    loc__0.val = (int)___ivy_choose(65536,"loc:0",53);
                            int loc__1;
    loc__1 = (int)___ivy_choose(2,"loc:1",53);
                            {
                                ___ivy_stack.push_back(148);
                                loc__0 = ext__dmap__impl__imap__glb(hi);
                                ___ivy_stack.pop_back();
                                ___ivy_stack.push_back(149);
                                loc__1 = ext__dmap__impl__imap__get(loc__0.val, (0 & 1));
                                ___ivy_stack.pop_back();
                                loc__nid = loc__1;
                            }
                        }
                        ___ivy_stack.push_back(150);
                        ext__dmap__impl__imap__set(hi.val, loc__nid);
                        ___ivy_stack.pop_back();
                    }
                }
            }
            ___ivy_stack.push_back(151);
            ext__dmap__impl__imap__erase(lo, hi);
            ___ivy_stack.pop_back();
            ___ivy_stack.push_back(152);
            ext__dmap__impl__imap__set(lo.val, dst);
            ___ivy_stack.pop_back();
        }
    }
}
delmap_test::key__iter__t delmap_test::key__iter__spec__create__after__(int x){
    key__iter__t y;
    y.is_end = (bool)___ivy_choose(2,"fml:y",0);
    y.val = (int)___ivy_choose(65536,"fml:y",0);
    {
    }
    return y;
}
delmap_test::key__iter__t delmap_test::dmap__impl__imap__spec__next__after__(key__iter__t it){
    key__iter__t res;
    res.is_end = (bool)___ivy_choose(2,"fml:res",0);
    res.val = (int)___ivy_choose(65536,"fml:res",0);
    {
    }
    return res;
}
delmap_test::key__iter__t delmap_test::ext__key__iter__impl__create__implement__(int x){
    key__iter__t y;
    y.is_end = (bool)___ivy_choose(2,"fml:y",0);
    y.val = (int)___ivy_choose(65536,"fml:y",0);
    {
        y.is_end = false;
        y.val = x;
    }
    return y;
}
int delmap_test::dmap__impl__get__implement__(int k){
    int val;
    val = (int)___ivy_choose(2,"fml:val",0);
    {
        key__iter__t loc__0;
    loc__0.is_end = (bool)___ivy_choose(2,"loc:0",55);
    loc__0.val = (int)___ivy_choose(65536,"loc:0",55);
        key__iter__t loc__1;
    loc__1.is_end = (bool)___ivy_choose(2,"loc:1",55);
    loc__1.val = (int)___ivy_choose(65536,"loc:1",55);
        int loc__2;
    loc__2 = (int)___ivy_choose(2,"loc:2",55);
        {
            ___ivy_stack.push_back(153);
            loc__0 = ext__key__iter__create(k);
            ___ivy_stack.pop_back();
            ___ivy_stack.push_back(154);
            loc__1 = ext__dmap__impl__imap__glb(loc__0);
            ___ivy_stack.pop_back();
            ___ivy_stack.push_back(155);
            loc__2 = ext__dmap__impl__imap__get(loc__1.val, (0 & 1));
            ___ivy_stack.pop_back();
            val = loc__2;
        }
    }
    return val;
}
bool delmap_test::dmap__impl__imap__present(int k){
    bool ans;
    ans = (bool)___ivy_choose(2,"fml:ans",0);
    {
    }
    return ans;
}
delmap_test::key__iter__t delmap_test::key__iter__impl__end__implement__(){
    key__iter__t y;
    y.is_end = (bool)___ivy_choose(2,"fml:y",0);
    y.val = (int)___ivy_choose(65536,"fml:y",0);
    {
        y.is_end = true;
        y.val = (0 & 65535);
    }
    return y;
}
delmap_test::key__iter__t delmap_test::ext__key__iter__spec__create__after__(int x){
    key__iter__t y;
    y.is_end = (bool)___ivy_choose(2,"fml:y",0);
    y.val = (int)___ivy_choose(65536,"fml:y",0);
    {
    }
    return y;
}
int delmap_test::ext__dmap__spec__get__after__(int k){
    int val;
    val = (int)___ivy_choose(2,"fml:val",0);
    {
    }
    return val;
}
void delmap_test::__init(){
    {
        int __tmp0;
        __tmp0 = 1;
        for (int T = 0; T < 65536; T++) {
            int __tmp1;
            __tmp1 = 1;
            for (int U = (T)+1; U < 65536; U++) {
                int __tmp2;
                __tmp2 = 1;
                for (int V = (U)+1; V < (T)-1; V++) {
                    if (!(!((T < U) && (U < V)) || (T < V))) __tmp2 = 0;
                }
                if (!__tmp2) __tmp1 = 0;
            }
            if (!__tmp1) __tmp0 = 0;
        }
        ivy_assert(__tmp0, "/home/mcmillan/projects/ivy/ivy/include/order.ivy: line 4: ");
        int __tmp3;
        __tmp3 = 1;
        for (int T = 0; T < 65536; T++) {
            int __tmp4;
            __tmp4 = 1;
            for (int U = (T)+1; U < T; U++) {
                if (!!((T < U) && (U < T))) __tmp4 = 0;
            }
            if (!__tmp4) __tmp3 = 0;
        }
        ivy_assert(__tmp3, "/home/mcmillan/projects/ivy/ivy/include/order.ivy: line 5: ");
        int __tmp5;
        __tmp5 = 1;
        for (int T = 0; T < 65536; T++) {
            int __tmp6;
            __tmp6 = 1;
            for (int U = T; U < (T)-1; U++) {
                if (!((T < U) || (U < T) || (T == U))) __tmp6 = 0;
            }
            if (!__tmp6) __tmp5 = 0;
        }
        ivy_assert(__tmp5, "/home/mcmillan/projects/ivy/ivy/include/order.ivy: line 6: ");
        int __tmp7;
        __tmp7 = 1;
        for (int X = 0; X < (0 & 65535); X++) {
            if (!(((0 & 65535) < X) || ((0 & 65535) == X))) __tmp7 = 0;
        }
        ivy_assert(__tmp7, "");
        int __tmp8;
        __tmp8 = 1;
        for (int T = 0; T < 65536; T++) {
            int __tmp9;
            __tmp9 = 1;
            for (int U = (T)+1; U < 65536; U++) {
                int __tmp10;
                __tmp10 = 1;
                for (int V = (U)+1; V < (T)-1; V++) {
                    if (!(!((T < U) && (U < V)) || (T < V))) __tmp10 = 0;
                }
                if (!__tmp10) __tmp9 = 0;
            }
            if (!__tmp9) __tmp8 = 0;
        }
        ivy_assert(__tmp8, "/home/mcmillan/projects/ivy/ivy/include/order.ivy: line 4: ");
        int __tmp11;
        __tmp11 = 1;
        for (int T = 0; T < 65536; T++) {
            int __tmp12;
            __tmp12 = 1;
            for (int U = (T)+1; U < T; U++) {
                if (!!((T < U) && (U < T))) __tmp12 = 0;
            }
            if (!__tmp12) __tmp11 = 0;
        }
        ivy_assert(__tmp11, "/home/mcmillan/projects/ivy/ivy/include/order.ivy: line 5: ");
        int __tmp13;
        __tmp13 = 1;
        for (int T = 0; T < 65536; T++) {
            int __tmp14;
            __tmp14 = 1;
            for (int U = T; U < (T)-1; U++) {
                if (!((T < U) || (U < T) || (T == U))) __tmp14 = 0;
            }
            if (!__tmp14) __tmp13 = 0;
        }
        ivy_assert(__tmp13, "/home/mcmillan/projects/ivy/ivy/include/order.ivy: line 6: ");
        ___ivy_stack.push_back(163);
        ext__dmap__impl__imap__set((0 & 65535), (0 & 1));
        ___ivy_stack.pop_back();
    }
}
delmap_test::key__iter__t delmap_test::dmap__impl__imap__impl__lub__implement__(key__iter__t it){
    key__iter__t res;
    res.is_end = (bool)___ivy_choose(2,"fml:res",0);
    res.val = (int)___ivy_choose(65536,"fml:res",0);

    if (it.is_end) {
        res.is_end = true;
        res.val = 0;
    } else {
        std::map<int,int>::iterator __it = dmap__impl__imap__impl__s.lower_bound(it.val);
        if (__it == dmap__impl__imap__impl__s.end()) {
            res.is_end = true;
            res.val = 0;
        } else {
            res.is_end = false;
            res.val = __it->first;
        }
    }
    return res;
}
delmap_test::key__iter__t delmap_test::key__iter__spec__end__after__(){
    key__iter__t y;
    y.is_end = (bool)___ivy_choose(2,"fml:y",0);
    y.val = (int)___ivy_choose(65536,"fml:y",0);
    {
    }
    return y;
}
int delmap_test::dmap__impl__imap__impl__get__implement__(int x, int def){
    int y;
    y = (int)___ivy_choose(2,"fml:y",0);

    std::map<int,int>::iterator it = dmap__impl__imap__impl__s.find(x);
    if (it == dmap__impl__imap__impl__s.end()) {
        y = def;
    } else {
        y = it->second;
    }
    return y;
}
void delmap_test::dmap__impl__imap__erase(key__iter__t lo, key__iter__t hi){
    {

        dmap__impl__imap__impl__s.erase(lo.is_end ? dmap__impl__imap__impl__s.end() : dmap__impl__imap__impl__s.lower_bound(lo.val),
                  hi.is_end ? dmap__impl__imap__impl__s.end() : dmap__impl__imap__impl__s.upper_bound(hi.val));
    }
}
int delmap_test::ext__dmap__impl__get__implement__(int k){
    int val;
    val = (int)___ivy_choose(2,"fml:val",0);
    {
        key__iter__t loc__0;
    loc__0.is_end = (bool)___ivy_choose(2,"loc:0",56);
    loc__0.val = (int)___ivy_choose(65536,"loc:0",56);
        key__iter__t loc__1;
    loc__1.is_end = (bool)___ivy_choose(2,"loc:1",56);
    loc__1.val = (int)___ivy_choose(65536,"loc:1",56);
        int loc__2;
    loc__2 = (int)___ivy_choose(2,"loc:2",56);
        {
            ___ivy_stack.push_back(156);
            loc__0 = ext__key__iter__create(k);
            ___ivy_stack.pop_back();
            ___ivy_stack.push_back(157);
            loc__1 = ext__dmap__impl__imap__glb(loc__0);
            ___ivy_stack.pop_back();
            ___ivy_stack.push_back(158);
            loc__2 = ext__dmap__impl__imap__get(loc__1.val, (0 & 1));
            ___ivy_stack.pop_back();
            val = loc__2;
        }
    }
    return val;
}
delmap_test::key__iter__t delmap_test::ext__key__iter__spec__end__after__(){
    key__iter__t y;
    y.is_end = (bool)___ivy_choose(2,"fml:y",0);
    y.val = (int)___ivy_choose(65536,"fml:y",0);
    {
    }
    return y;
}
delmap_test::key__iter__t delmap_test::ext__dmap__impl__imap__impl__next__implement__(key__iter__t inp){
    key__iter__t res;
    res.is_end = (bool)___ivy_choose(2,"fml:res",0);
    res.val = (int)___ivy_choose(65536,"fml:res",0);

    std::map<int,int>::iterator __it = dmap__impl__imap__impl__s.upper_bound(inp.val);
    if (__it == dmap__impl__imap__impl__s.end()) {
        res.is_end = true;
        res.val = 0;
    } else {
        res.is_end = false;
        res.val = __it->first;
    }
    return res;
}
void delmap_test::ext__dmap__impl__imap__erase(key__iter__t lo, key__iter__t hi){
    {

        dmap__impl__imap__impl__s.erase(lo.is_end ? dmap__impl__imap__impl__s.end() : dmap__impl__imap__impl__s.lower_bound(lo.val),
                  hi.is_end ? dmap__impl__imap__impl__s.end() : dmap__impl__imap__impl__s.upper_bound(hi.val));
    }
}
void delmap_test::dmap__spec__set__before__(key__iter__t lo, key__iter__t hi, int dst){
    {
    }
}
int delmap_test::ext__dmap__impl__imap__impl__get__implement__(int x, int def){
    int y;
    y = (int)___ivy_choose(2,"fml:y",0);

    std::map<int,int>::iterator it = dmap__impl__imap__impl__s.find(x);
    if (it == dmap__impl__imap__impl__s.end()) {
        y = def;
    } else {
        y = it->second;
    }
    return y;
}
void delmap_test::ext__dmap__spec__set__before__(key__iter__t lo, key__iter__t hi, int dst){
    {
    }
}
int delmap_test::ext__dmap__impl__imap__spec__get__after__(int k, int def){
    int v;
    v = (int)___ivy_choose(2,"fml:v",0);
    {
    }
    return v;
}
int delmap_test::ext__dmap__get(int k){
    int val;
    val = (int)___ivy_choose(2,"fml:val",0);
    {
        {
            key__iter__t loc__0;
    loc__0.is_end = (bool)___ivy_choose(2,"loc:0",57);
    loc__0.val = (int)___ivy_choose(65536,"loc:0",57);
            key__iter__t loc__1;
    loc__1.is_end = (bool)___ivy_choose(2,"loc:1",57);
    loc__1.val = (int)___ivy_choose(65536,"loc:1",57);
            int loc__2;
    loc__2 = (int)___ivy_choose(2,"loc:2",57);
            {
                ___ivy_stack.push_back(159);
                loc__0 = ext__key__iter__create(k);
                ___ivy_stack.pop_back();
                ___ivy_stack.push_back(160);
                loc__1 = ext__dmap__impl__imap__glb(loc__0);
                ___ivy_stack.pop_back();
                ___ivy_stack.push_back(161);
                loc__2 = ext__dmap__impl__imap__get(loc__1.val, (0 & 1));
                ___ivy_stack.pop_back();
                val = loc__2;
            }
        }
    }
    return val;
}
void delmap_test::dmap__impl__imap__impl__set__implement__(int x, int y){

    dmap__impl__imap__impl__s[x] = y;
}
delmap_test::key__iter__t delmap_test::ext__key__iter__end(){
    key__iter__t y;
    y.is_end = (bool)___ivy_choose(2,"fml:y",0);
    y.val = (int)___ivy_choose(65536,"fml:y",0);
    {
        y.is_end = true;
        y.val = (0 & 65535);
    }
    return y;
}
int delmap_test::ext__dmap__impl__imap__get(int k, int def){
    int v;
    v = (int)___ivy_choose(2,"fml:v",0);
    {

        std::map<int,int>::iterator it = dmap__impl__imap__impl__s.find(k);
        if (it == dmap__impl__imap__impl__s.end()) {
            v = def;
        } else {
            v = it->second;
        }
    }
    return v;
}
delmap_test::key__iter__t delmap_test::ext__dmap__impl__imap__spec__next__after__(key__iter__t it){
    key__iter__t res;
    res.is_end = (bool)___ivy_choose(2,"fml:res",0);
    res.val = (int)___ivy_choose(65536,"fml:res",0);
    {
    }
    return res;
}
delmap_test::key__iter__t delmap_test::dmap__impl__imap__spec__glb__before__(key__iter__t it){
    key__iter__t res;
    res.is_end = (bool)___ivy_choose(2,"fml:res",0);
    res.val = (int)___ivy_choose(65536,"fml:res",0);
    {
    }
    return res;
}
void delmap_test::ext__dmap__impl__imap__impl__set__implement__(int x, int y){

    dmap__impl__imap__impl__s[x] = y;
}
void delmap_test::ext__dmap__impl__imap__set(int nkey, int v){
    {

        dmap__impl__imap__impl__s[nkey] = v;
    }
}
delmap_test::key__iter__t delmap_test::ext__key__iter__impl__end__implement__(){
    key__iter__t y;
    y.is_end = (bool)___ivy_choose(2,"fml:y",0);
    y.val = (int)___ivy_choose(65536,"fml:y",0);
    {
        y.is_end = true;
        y.val = (0 & 65535);
    }
    return y;
}
void delmap_test::__tick(int __timeout){
}
delmap_test::delmap_test(){
    __CARD__key__t = 65536;
    __CARD__id = 2;
    
}

class init_gen : public gen {
public:
    init_gen();
    bool generate(delmap_test&);
    bool execute(delmap_test&){}
};
init_gen::init_gen(){
    mk_bv("key.t",16);
mk_sort("key.iter.t");
    mk_bv("id",1);
    const char *key__iter__val_domain[1] = {"key.iter.t"};
    mk_decl("key.iter.val",1,key__iter__val_domain,"key.t");
    const char *__lt_domain[2] = {"key.iter.t","key.iter.t"};
    mk_decl("<:key.iter.t",2,__lt_domain,"Bool");
    const char *key__iter__is_end_domain[1] = {"key.iter.t"};
    mk_decl("key.iter.is_end",1,key__iter__is_end_domain,"Bool");
    add("(assert (and\
      and\
      (forall ((|T:key.t| (_ BitVec 16))          (|U:key.t| (_ BitVec 16))          (|V:key.t| (_ BitVec 16)))   (=> (and (bvult |T:key.t| |U:key.t|) (bvult |U:key.t| |V:key.t|))       (bvult |T:key.t| |V:key.t|)))\
      (forall ((|T:key.t| (_ BitVec 16)) (|U:key.t| (_ BitVec 16)))   (not (and (bvult |T:key.t| |U:key.t|) (bvult |U:key.t| |T:key.t|))))\
      (forall ((|T:key.t| (_ BitVec 16)) (|U:key.t| (_ BitVec 16)))   (or (bvult |T:key.t| |U:key.t|)       (bvult |U:key.t| |T:key.t|)       (= |T:key.t| |U:key.t|)))\
      (forall ((|X:key.t| (_ BitVec 16))) (bvule #x0000 |X:key.t|))\
      (forall ((|T:key.t| (_ BitVec 16))          (|U:key.t| (_ BitVec 16))          (|V:key.t| (_ BitVec 16)))   (=> (and (bvult |T:key.t| |U:key.t|) (bvult |U:key.t| |V:key.t|))       (bvult |T:key.t| |V:key.t|)))\
      (forall ((|T:key.t| (_ BitVec 16)) (|U:key.t| (_ BitVec 16)))   (not (and (bvult |T:key.t| |U:key.t|) (bvult |U:key.t| |T:key.t|))))\
      (forall ((|T:key.t| (_ BitVec 16)) (|U:key.t| (_ BitVec 16)))   (or (bvult |T:key.t| |U:key.t|)       (bvult |U:key.t| |T:key.t|)       (= |T:key.t| |U:key.t|)))\
      (forall ((|X:key.iter.t| key.iter.t) (|Y:key.iter.t| key.iter.t))   (let ((a!1 (or (and (bvult (key.iter.val |X:key.iter.t|)                              (key.iter.val |Y:key.iter.t|))                       (not (key.iter.is_end |X:key.iter.t|))                       (not (key.iter.is_end |Y:key.iter.t|)))                  (and (key.iter.is_end |Y:key.iter.t|)                       (not (key.iter.is_end |X:key.iter.t|))))))     (= (|<:key.iter.t| |X:key.iter.t| |Y:key.iter.t|) a!1)))\
    ))");
}
bool init_gen::generate(delmap_test& obj) {

    // std::cout << slvr << std::endl;
    bool __res = solve();
    if (__res) {

    }

    obj.__init();
    return __res;
}
class ext__dmap__set_gen : public gen {
  public:
    int dst;
    delmap_test::key__iter__t hi;
    delmap_test::key__iter__t lo;
    ext__dmap__set_gen();
    bool generate(delmap_test&);
    bool execute(delmap_test&);
};
ext__dmap__set_gen::ext__dmap__set_gen(){
    mk_bv("key.t",16);
mk_sort("key.iter.t");
    mk_bv("id",1);
    const char *key__iter__val_domain[1] = {"key.iter.t"};
    mk_decl("key.iter.val",1,key__iter__val_domain,"key.t");
    const char *__lt_domain[2] = {"key.iter.t","key.iter.t"};
    mk_decl("<:key.iter.t",2,__lt_domain,"Bool");
    const char *key__iter__is_end_domain[1] = {"key.iter.t"};
    mk_decl("key.iter.is_end",1,key__iter__is_end_domain,"Bool");
    mk_const("fml:dst","id");
    mk_const("__ts0_c","Bool");
    mk_const("__fml:hi","key.iter.t");
    mk_const("__ts0_a","Bool");
    mk_const("__fml:lo","key.iter.t");
    mk_const("__ts0_d","Bool");
    mk_const("__ts0_b","Bool");
    add("(assert (and (forall ((|X:key.iter.t| key.iter.t) (|Y:key.iter.t| key.iter.t))\
       (let ((a!1 (or (and (bvult (key.iter.val |X:key.iter.t|)\
                                  (key.iter.val |Y:key.iter.t|))\
                           (not (key.iter.is_end |X:key.iter.t|))\
                           (not (key.iter.is_end |Y:key.iter.t|)))\
                      (and (key.iter.is_end |Y:key.iter.t|)\
                           (not (key.iter.is_end |X:key.iter.t|))))))\
         (= (|<:key.iter.t| |X:key.iter.t| |Y:key.iter.t|) a!1)))\
     (or __ts0_c __ts0_d)\
     (or (|<:key.iter.t| |__fml:lo| |__fml:hi|) (not __ts0_c))\
     (or (not __ts0_c) __ts0_a __ts0_b)\
     (or (not __ts0_c) (key.iter.is_end |__fml:hi|) (not __ts0_b))\
     (or (not __ts0_c) (not __ts0_a) (not (key.iter.is_end |__fml:hi|)))\
     (or (not __ts0_d) (not (|<:key.iter.t| |__fml:lo| |__fml:hi|)))))");
}
bool ext__dmap__set_gen::generate(delmap_test& obj) {
    push();
    randomize("fml:dst");
    __randomize<delmap_test::key__iter__t>(*this,apply("__fml:hi"));
    __randomize<delmap_test::key__iter__t>(*this,apply("__fml:lo"));

    // std::cout << slvr << std::endl;
    bool __res = solve();
    if (__res) {
        dst = eval_apply("fml:dst");
                __from_solver<delmap_test::key__iter__t>(*this,apply("__fml:hi"),hi);
                __from_solver<delmap_test::key__iter__t>(*this,apply("__fml:lo"),lo);

    }
    pop();
    obj.___ivy_gen = this;
    return __res;
}
bool ext__dmap__set_gen::execute(delmap_test& obj){
    std::cout << "> dmap.set(" << lo << ","  << hi << ","  << dst << ")" << std::endl;
    obj.ext__dmap__set(lo,hi,dst);
}
class ext__dmap__get_gen : public gen {
  public:
    delmap_test::key__iter__t y_nd;
    int k;
    delmap_test::key__iter__t y_nd_a;
    delmap_test::key__iter__t y;
    ext__dmap__get_gen();
    bool generate(delmap_test&);
    bool execute(delmap_test&);
};
ext__dmap__get_gen::ext__dmap__get_gen(){
    mk_bv("key.t",16);
mk_sort("key.iter.t");
    mk_bv("id",1);
    const char *key__iter__val_domain[1] = {"key.iter.t"};
    mk_decl("key.iter.val",1,key__iter__val_domain,"key.t");
    const char *__lt_domain[2] = {"key.iter.t","key.iter.t"};
    mk_decl("<:key.iter.t",2,__lt_domain,"Bool");
    const char *key__iter__is_end_domain[1] = {"key.iter.t"};
    mk_decl("key.iter.is_end",1,key__iter__is_end_domain,"Bool");
    mk_const("__new_fml:x","key.t");
    mk_const("__fml:y_nd","key.iter.t");
    mk_const("__fml:k","key.t");
    mk_const("__fml:y_nd_a","key.iter.t");
    mk_const("__fml:y","key.iter.t");
    mk_const("__m_fml:y","key.iter.t");
    add("(assert (and (forall ((|X:key.iter.t| key.iter.t) (|Y:key.iter.t| key.iter.t))\
       (let ((a!1 (or (and (bvult (key.iter.val |X:key.iter.t|)\
                                  (key.iter.val |Y:key.iter.t|))\
                           (not (key.iter.is_end |X:key.iter.t|))\
                           (not (key.iter.is_end |Y:key.iter.t|)))\
                      (and (key.iter.is_end |Y:key.iter.t|)\
                           (not (key.iter.is_end |X:key.iter.t|))))))\
         (= (|<:key.iter.t| |X:key.iter.t| |Y:key.iter.t|) a!1)))\
     (or (key.iter.is_end |__fml:y_nd|) (not or))\
     (or (not (key.iter.is_end |__fml:y_nd|)) or)\
     (= |__m_fml:y| |__fml:y_nd|)\
     (= |__new_fml:x| |__fml:k|)\
     (= (key.iter.is_end |__fml:y_nd_a|) (key.iter.is_end |__m_fml:y|))\
     (= (key.iter.val |__fml:y_nd|) (key.iter.val |__fml:y|))\
     (= (key.iter.val |__fml:y_nd_a|) |__new_fml:x|)))");
}
bool ext__dmap__get_gen::generate(delmap_test& obj) {
    push();
    __randomize<delmap_test::key__iter__t>(*this,apply("__fml:y_nd"));
    randomize("__fml:k");
    __randomize<delmap_test::key__iter__t>(*this,apply("__fml:y_nd_a"));
    __randomize<delmap_test::key__iter__t>(*this,apply("__fml:y"));

    // std::cout << slvr << std::endl;
    bool __res = solve();
    if (__res) {
                __from_solver<delmap_test::key__iter__t>(*this,apply("__fml:y_nd"),y_nd);
        k = eval_apply("__fml:k");
                __from_solver<delmap_test::key__iter__t>(*this,apply("__fml:y_nd_a"),y_nd_a);
                __from_solver<delmap_test::key__iter__t>(*this,apply("__fml:y"),y);

    }
    pop();
    obj.___ivy_gen = this;
    return __res;
}
bool ext__dmap__get_gen::execute(delmap_test& obj){
    std::cout << "> dmap.get(" << k << ")" << std::endl;
    std::cout << "= " << obj.ext__dmap__get(k) <<  std::endl;
}
std::ostream &operator <<(std::ostream &s, const delmap_test::key__iter__t &t){
    s<<"{";
    s<< "is_end:";
    s << t.is_end;
    s<<",";
    s<< "val:";
    s << t.val;
    s<<"}";
    return s;
}
template <>
void  __ser<delmap_test::key__iter__t>(std::vector<char> &res, const delmap_test::key__iter__t&t){
    __ser<bool>(res,t.is_end);
    __ser<int>(res,t.val);
}


int ask_ret(int bound) {
    int res;
    while(true) {
        std::cout << "? ";
        std::cin >> res;
        if (res >= 0 && res < bound) 
            return res;
        std::cout << "value out of range" << std::endl;
    }
}



    class delmap_test_repl : public delmap_test {

    public:

    virtual void ivy_assert(bool truth,const char *msg){
        if (!truth) {
            std::cerr << msg << ": assertion failed\n";
            exit(1);
        }
    }
    virtual void ivy_assume(bool truth,const char *msg){
        if (!truth) {
            std::cerr << msg << ": assumption failed\n";
            exit(1);
        }
    }
    delmap_test_repl() : delmap_test(){}

    };

// Override methods to implement low-level network service

bool is_white(int c) {
    return (c == ' ' || c == '\t' || c == '\n');
}

bool is_ident(int c) {
    return c == '_' || c == '.' || (c >= 'A' &&  c <= 'Z')
        || (c >= 'a' &&  c <= 'z')
        || (c >= '0' &&  c <= '9');
}

void skip_white(const std::string& str, int &pos){
    while (pos < str.size() && is_white(str[pos]))
        pos++;
}

struct syntax_error {
};

std::string get_ident(const std::string& str, int &pos) {
    std::string res = "";
    while (pos < str.size() && is_ident(str[pos])) {
        res.push_back(str[pos]);
        pos++;
    }
    if (res.size() == 0)
        throw syntax_error();
    return res;
}

ivy_value parse_value(const std::string& cmd, int &pos) {
    ivy_value res;
    skip_white(cmd,pos);
    if (pos < cmd.size() && cmd[pos] == '[') {
        while (true) {
            pos++;
            skip_white(cmd,pos);
            res.fields.push_back(parse_value(cmd,pos));
            skip_white(cmd,pos);
            if (pos < cmd.size() && cmd[pos] == ']')
                break;
            if (!(pos < cmd.size() && cmd[pos] == ','))
                throw syntax_error();
        }
        pos++;
    }
    else if (pos < cmd.size() && cmd[pos] == '{') {
        while (true) {
            ivy_value field;
            pos++;
            skip_white(cmd,pos);
            field.atom = get_ident(cmd,pos);
            skip_white(cmd,pos);
            if (!(pos < cmd.size() && cmd[pos] == ':'))
                 throw syntax_error();
            pos++;
            skip_white(cmd,pos);
            field.fields.push_back(parse_value(cmd,pos));
            res.fields.push_back(field);
            skip_white(cmd,pos);
            if (pos < cmd.size() && cmd[pos] == '}')
                break;
            if (!(pos < cmd.size() && cmd[pos] == ','))
                throw syntax_error();
        }
        pos++;
    }
    else if (pos < cmd.size() && cmd[pos] == '"') {
        pos++;
        res.atom = "";
        while (pos < cmd.size() && cmd[pos] != '"')
            res.atom.push_back(cmd[pos++]);
        if(pos == cmd.size())
            throw syntax_error();
        pos++;
    }
    else 
        res.atom = get_ident(cmd,pos);
    return res;
}

void parse_command(const std::string &cmd, std::string &action, std::vector<ivy_value> &args) {
    int pos = 0;
    skip_white(cmd,pos);
    action = get_ident(cmd,pos);
    skip_white(cmd,pos);
    if (pos < cmd.size() && cmd[pos] == '(') {
        pos++;
        skip_white(cmd,pos);
        args.push_back(parse_value(cmd,pos));
        while(true) {
            skip_white(cmd,pos);
            if (!(pos < cmd.size() && cmd[pos] == ','))
                break;
            pos++;
            args.push_back(parse_value(cmd,pos));
        }
        if (!(pos < cmd.size() && cmd[pos] == ')'))
            throw syntax_error();
        pos++;
    }
    skip_white(cmd,pos);
    if (pos != cmd.size())
        throw syntax_error();
}

struct bad_arity {
    std::string action;
    int num;
    bad_arity(std::string &_action, unsigned _num) : action(_action), num(_num) {}
};

void check_arity(std::vector<ivy_value> &args, unsigned num, std::string &action) {
    if (args.size() != num)
        throw bad_arity(action,num);
}

template <>
bool _arg<bool>(std::vector<ivy_value> &args, unsigned idx, int bound) {
    if (!(args[idx].atom == "true" || args[idx].atom == "false") || args[idx].fields.size())
        throw out_of_bounds(idx);
    return args[idx].atom == "true";
}

template <>
delmap_test::key__iter__t _arg<delmap_test::key__iter__t>(std::vector<ivy_value> &args, unsigned idx, int bound){
    delmap_test::key__iter__t res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds(idx);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "is_end") throw out_of_bounds("unexpected field: " + arg.fields[0].atom);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res.is_end = _arg<bool>(tmp_args,0,2);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field is_end: " + err.txt);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "val") throw out_of_bounds("unexpected field: " + arg.fields[1].atom);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res.val = _arg<int>(tmp_args,0,65536);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field val: " + err.txt);
    }
    return res;
}
template <>
void __deser<delmap_test::key__iter__t>(const std::vector<char> &inp, unsigned &pos, delmap_test::key__iter__t &res){
    __deser(inp,pos,res.is_end);
    __deser(inp,pos,res.val);
}
template <>
void  __from_solver<delmap_test::key__iter__t>( gen &g, const  z3::expr &v,delmap_test::key__iter__t &res){
    __from_solver(g,g.apply("key.iter.is_end",v),res.is_end);
    __from_solver(g,g.apply("key.iter.val",v),res.val);
}
template <>
z3::expr  __to_solver<delmap_test::key__iter__t>( gen &g, const  z3::expr &v,delmap_test::key__iter__t &val){
    z3::expr res = g.ctx.bool_val(1);
    res = res && __to_solver(g,g.apply("key.iter.is_end",v),val.is_end);
    res = res && __to_solver(g,g.apply("key.iter.val",v),val.val);
    return res;
}
template <>
void  __randomize<delmap_test::key__iter__t>( gen &g, const  z3::expr &v){
    __randomize<bool>(g,g.apply("key.iter.is_end",v));
    __randomize<int>(g,g.apply("key.iter.val",v));
}


class stdin_reader: public reader {
    std::string buf;

    virtual int fdes(){
        return 0;
    }
    virtual void read() {
        char tmp[257];
        int chars = ::read(0,tmp,256);
        tmp[chars] = 0;
        buf += std::string(tmp);
        size_t pos;
        while ((pos = buf.find('\n')) != std::string::npos) {
            std::string line = buf.substr(0,pos+1);
            buf.erase(0,pos+1);
            process(line);
        }
    }
    virtual void process(const std::string &line) {
        std::cout << line;
    }
};

class cmd_reader: public stdin_reader {

public:
    delmap_test_repl &ivy;    

    cmd_reader(delmap_test_repl &_ivy) : ivy(_ivy) {
        std::cout << "> "; std::cout.flush();
    }

    virtual void process(const std::string &cmd) {
        std::string action;
        std::vector<ivy_value> args;
        try {
            parse_command(cmd,action,args);

                if (action == "dmap.get") {
                    check_arity(args,1,action);
                    std::cout << "= " << ivy.ext__dmap__get(_arg<int>(args,0,65536)) << std::endl;
                }
                else
    
                if (action == "dmap.set") {
                    check_arity(args,3,action);
                    ivy.ext__dmap__set(_arg<delmap_test::key__iter__t>(args,0,0),_arg<delmap_test::key__iter__t>(args,1,0),_arg<int>(args,2,2));
                }
                else
    
            {
                std::cout << "undefined action: " << action << std::endl;
            }
        }
        catch (syntax_error&) {
            std::cout << "syntax error" << std::endl;
        }
        catch (out_of_bounds &err) {
            std::cout << err.txt << " out of bounds" << std::endl;
        }
        catch (bad_arity &err) {
            std::cout << "action " << err.action << " takes " << err.num  << " input parameters" << std::endl;
        }
        std::cout << "> "; std::cout.flush();
    }
};


std::vector<reader *> readers;

void install_reader(reader *r){
    readers.push_back(r);
}

std::vector<timer *> timers;

void install_timer(timer *r){
    timers.push_back(r);
}
int main(int argc, char **argv){
    if (argc != 1){
        std::cerr << "usage: delmap_test \n";
        exit(1);
    }
    std::vector<std::string> args;
    std::vector<ivy_value> arg_values(1);
    for(int i = 1; i < argc;i++){args.push_back(argv[i]);}
    delmap_test_repl ivy;

        init_gen my_init_gen;
        my_init_gen.generate(ivy);
        std::vector<gen *> generators;
        generators.push_back(new ext__dmap__get_gen);
        generators.push_back(new ext__dmap__set_gen);


    for(int cycle = 0; cycle < 1000; cycle++) {

        int choices = generators.size() + readers.size() + timers.size();
        int rnd = choices ? (rand() % choices) : 0;
        if (rnd < generators.size()) {
            gen &g = *generators[rnd];
            if (g.generate(ivy))
                g.execute(ivy);
            continue;
        }


        fd_set rdfds;
        FD_ZERO(&rdfds);
        int maxfds = 0;

        for (unsigned i = 0; i < readers.size(); i++) {
            reader *r = readers[i];
            int fds = r->fdes();
            FD_SET(fds,&rdfds);
            if (fds > maxfds)
                maxfds = fds;
        }

        int timer_min = 1;

        struct timeval timeout;
        timeout.tv_sec = timer_min/1000;
        timeout.tv_usec = 1000 * (timer_min % 1000);

        int foo = select(maxfds+1,&rdfds,0,0,&timeout);

        if (foo < 0)
            {perror("select failed"); exit(1);}
        
        if (foo == 0){
            // std::cout << "TIMEOUT\n";            
           cycle--;
           for (unsigned i = 0; i < timers.size(); i++){
               if (timer_min >= timers[i]->ms_delay()) {
                   cycle++;
                   break;
               }
           }
           for (unsigned i = 0; i < timers.size(); i++)
               timers[i]->timeout(timer_min);
        }
        else {
            for (unsigned i = 0; i < readers.size(); i++) {
                reader *r = readers[i];
                if (FD_ISSET(r->fdes(),&rdfds))
                    r->read();
            }
        }            
    }
}
