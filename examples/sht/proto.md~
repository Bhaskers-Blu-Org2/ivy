---
layout: page
title: Protocol
---

Now we get to the [actual protocol](proto.ivy). Each host has a hash
table and a delegation map describing where to find ranges of
keys. When the host receives a request to get or set the value of a
key in the directory, it looks up the key in the delegation map. If
the key is delegated to the local host, the operation is performed
directly on the host's hash table.  Otherwise, the request is
forwarded to the host indicated in the delegation map. Since the
delegation map of the local host may be out of data, the forwarded
request may be forwarded repreatedly until it reachs the host with
actual responsibility for the key. When this host receives the
forwarded request, it performs the operation on its local hash table
and returns a reply directly to the original requesting host. This
host the responds to the service client with an answer.

Initially, all keys belong to the master server numbered `0`. A host
that serves a range of keys can delegate that range to another host by
extracting a shard and sending it in a *delegate* message. The host
receiving the delegate message incorporates the shard into its own
hash table.  Both hosts update their delegation maps
accordingly. Hosts don't make any attempt to advertise the keys that
they own to other hosts. This means that a request for a key must
follow the original chain of delegation to get to the owner of the
key.

Here is the client-facing interface of the protocol:

    module sht_protocol(me,ref,trans,id,key,data,shard) = {

	action set(k:key.t,d:data) returns(ok:bool)
	action get(k:key.t) returns(ok:bool)
	action answer(k:key.t,d:data,lt:ref.txid)
	action delegate_(dst:id, lo:key.iter.t, hi:key.iter.t)  returns(ok:bool)
	...

The parameters are `me`, the host's id, `ref`, the [reference
object](reference.html), `trans` the [transport service](trans.html)
and data types `id`, 'key`, `data` and `shard` (`data` is the type of
values in the directory).




