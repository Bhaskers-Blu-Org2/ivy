---
layout: page
title: Networking
---

We saw previously how to [run the leader election example using a
REPL](helloworld.html).  Via the REPL, the user acted the role of the
environment, including the network. This is, of course somewhat
unsatisfactory. Ideally, we would like a real network to take this
role.

In this section, we'll see how to accomplish that. That is, we will
implment a protocol as a collection of processes communicating over a
network.

## A network interface

Ivy provides a simple interface to the Unix Datagram protocol (UDP) in
a module called `udp`. Here is the interface specification:

    module udp_simple(addr,pkt) = {

	import action recv(dst:addr,v:pkt)
	export action send(src:addr,dst:addr,v:pkt)

	relation sent(V:pkt, N:addr)
	init ~sent(V, N)

	object spec = {
	    before send {
		sent(v,dst) := true
	    }
	    before recv {
		assert sent(v,dst)
	    }
	}

	instance impl(X:addr) : udp_wrapper(addr,pkt,X)
	private impl
    }

The interface is a module with two parameters: the type `addr` of
network addresses, and the type `pkt` of packets.  It has two actions,
`recv` and `send`.  These are very similar to actions of the abstract
transport interface we used in the leader election protocol.  The only
difference is that the `send` action the source address of the packet
as a paramater as well as the destination address. We'll see the rason
for this shortly. Action `recv` is imported by the interface (meaning
the user must implement it) while `send` is exported (meaning that the
module implements it).

As in the leader example, the specification promises that only packets
that have been sent wil be received (but packets may be dropped,
duplicated or re-ordered). 

For now, ignore the definition of object `impl`. We'll come back to it
later.

Let's begin by writing a simple test program that uses `udp_simple`:







