#include "quic_monitor.h"

#include <sstream>
#include <algorithm>

#include <iostream>
#include <stdlib.h>
#include <sys/types.h>          /* See NOTES */
#include <sys/stat.h>
#include <fcntl.h>
#ifdef _WIN32
#include <winsock2.h>
#include <WS2tcpip.h>
#include <io.h>
#define isatty _isatty
#else
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h> 
#include <sys/select.h>
#include <unistd.h>
#define _open open
#define _dup2 dup2
#endif
#include <string.h>
#include <stdio.h>
#include <string>
typedef quic_monitor ivy_class;
std::ofstream __ivy_out;
std::ofstream __ivy_modelfile;
void __ivy_exit(int code){exit(code);}

class reader {
public:
    virtual int fdes() = 0;
    virtual void read() = 0;
    virtual void bind() {}
    virtual bool running() {return fdes() >= 0;}
    virtual ~reader() {}
};

class timer {
public:
    virtual int ms_delay() = 0;
    virtual void timeout(int) = 0;
    virtual ~timer() {}
};

#ifdef _WIN32
DWORD WINAPI ReaderThreadFunction( LPVOID lpParam ) 
{
    reader *cr = (reader *) lpParam;
    cr->bind();
    while (true)
        cr->read();
    return 0;
} 

DWORD WINAPI TimerThreadFunction( LPVOID lpParam ) 
{
    timer *cr = (reader *) lpParam;
    while (true) {
        int ms = timer->ms_delay();
        Sleep(ms);
        timer->timeout(ms);
    }
    return 0;
} 
#else
void * _thread_reader(void *rdr_void) {
    reader *rdr = (reader *) rdr_void;
    rdr->bind();
    while(rdr->running()) {
        rdr->read();
    }
    delete rdr;
    return 0; // just to stop warning
}

void * _thread_timer( void *tmr_void ) 
{
    timer *tmr = (timer *) tmr_void;
    while (true) {
        int ms = tmr->ms_delay();
        struct timespec ts;
        ts.tv_sec = ms/1000;
        ts.tv_nsec = (ms % 1000) * 1000000;
        nanosleep(&ts,NULL);
        tmr->timeout(ms);
    }
    return 0;
} 
#endif 

void quic_monitor::install_reader(reader *r) {
    #ifdef _WIN32

        DWORD dummy;
        HANDLE h = CreateThread( 
            NULL,                   // default security attributes
            0,                      // use default stack size  
            ReaderThreadFunction,   // thread function name
            r,                      // argument to thread function 
            0,                      // use default creation flags 
            &dummy);                // returns the thread identifier 
        if (h == NULL) {
            std::cerr << "failed to create thread" << std::endl;
            exit(1);
        }
        thread_ids.push_back(dummy);
    #else
        pthread_t thread;
        int res = pthread_create(&thread, NULL, _thread_reader, r);
        if (res) {
            std::cerr << "failed to create thread" << std::endl;
            exit(1);
        }
        thread_ids.push_back(thread);
    #endif
}      

void quic_monitor::install_thread(reader *r) {
    install_reader(r);
}

void quic_monitor::install_timer(timer *r) {
    #ifdef _WIN32

        DWORD dummy;
        HANDLE h = CreateThread( 
            NULL,                   // default security attributes
            0,                      // use default stack size  
            TimersThreadFunction,   // thread function name
            r,                      // argument to thread function 
            0,                      // use default creation flags 
            &dummy);                // returns the thread identifier 
        if (h == NULL) {
            std::cerr << "failed to create thread" << std::endl;
            exit(1);
        }
        thread_ids.push_back(dummy);
    #else
        pthread_t thread;
        int res = pthread_create(&thread, NULL, _thread_timer, r);
        if (res) {
            std::cerr << "failed to create thread" << std::endl;
            exit(1);
        }
        thread_ids.push_back(thread);
    #endif
}      


#ifdef _WIN32
    void quic_monitor::__lock() { WaitForSingleObject(mutex,INFINITE); }
    void quic_monitor::__unlock() { ReleaseMutex(mutex); }
#else
    void quic_monitor::__lock() { pthread_mutex_lock(&mutex); }
    void quic_monitor::__unlock() { pthread_mutex_unlock(&mutex); }
#endif
struct thunk__pc__handle{
    quic_monitor *__ivy;
    thunk__pc__handle(quic_monitor *__ivy): __ivy(__ivy){}
    void operator()(quic_monitor::ip__endpoint src, quic_monitor::ip__endpoint dst, quic_monitor::quic_packet p) const {
        __ivy->pc__handle(src,dst,p);
    }
};

/*++
Copyright (c) Microsoft Corporation

This string hash function is borrowed from Microsoft Z3
(https://github.com/Z3Prover/z3). 

--*/


#define mix(a,b,c)              \
{                               \
  a -= b; a -= c; a ^= (c>>13); \
  b -= c; b -= a; b ^= (a<<8);  \
  c -= a; c -= b; c ^= (b>>13); \
  a -= b; a -= c; a ^= (c>>12); \
  b -= c; b -= a; b ^= (a<<16); \
  c -= a; c -= b; c ^= (b>>5);  \
  a -= b; a -= c; a ^= (c>>3);  \
  b -= c; b -= a; b ^= (a<<10); \
  c -= a; c -= b; c ^= (b>>15); \
}

#ifndef __fallthrough
#define __fallthrough
#endif

namespace hash_space {

// I'm using Bob Jenkin's hash function.
// http://burtleburtle.net/bob/hash/doobs.html
unsigned string_hash(const char * str, unsigned length, unsigned init_value) {
    register unsigned a, b, c, len;

    /* Set up the internal state */
    len = length;
    a = b = 0x9e3779b9;  /* the golden ratio; an arbitrary value */
    c = init_value;      /* the previous hash value */

    /*---------------------------------------- handle most of the key */
    while (len >= 12) {
        a += reinterpret_cast<const unsigned *>(str)[0];
        b += reinterpret_cast<const unsigned *>(str)[1];
        c += reinterpret_cast<const unsigned *>(str)[2];
        mix(a,b,c);
        str += 12; len -= 12;
    }

    /*------------------------------------- handle the last 11 bytes */
    c += length;
    switch(len) {        /* all the case statements fall through */
    case 11: 
        c+=((unsigned)str[10]<<24);
        __fallthrough;
    case 10: 
        c+=((unsigned)str[9]<<16);
        __fallthrough;
    case 9 : 
        c+=((unsigned)str[8]<<8);
        __fallthrough;
        /* the first byte of c is reserved for the length */
    case 8 : 
        b+=((unsigned)str[7]<<24);
        __fallthrough;
    case 7 : 
        b+=((unsigned)str[6]<<16);
        __fallthrough;
    case 6 : 
        b+=((unsigned)str[5]<<8);
        __fallthrough;
    case 5 : 
        b+=str[4];
        __fallthrough;
    case 4 : 
        a+=((unsigned)str[3]<<24);
        __fallthrough;
    case 3 : 
        a+=((unsigned)str[2]<<16);
        __fallthrough;
    case 2 : 
        a+=((unsigned)str[1]<<8);
        __fallthrough;
    case 1 : 
        a+=str[0];
        __fallthrough;
        /* case 0: nothing left to add */
    }
    mix(a,b,c);
    /*-------------------------------------------- report the result */
    return c;
}

}




struct ivy_value {
    int pos;
    std::string atom;
    std::vector<ivy_value> fields;
    bool is_member() const {
        return atom.size() && fields.size();
    }
};
struct deser_err {
};

struct ivy_ser {
    virtual void  set(long long) = 0;
    virtual void  set(bool) = 0;
    virtual void  set(const std::string &) = 0;
    virtual void  open_list(int len) = 0;
    virtual void  close_list() = 0;
    virtual void  open_list_elem() = 0;
    virtual void  close_list_elem() = 0;
    virtual void  open_struct() = 0;
    virtual void  close_struct() = 0;
    virtual void  open_field(const std::string &) = 0;
    virtual void  close_field() = 0;
    virtual void  open_tag(int, const std::string &) {throw deser_err();}
    virtual void  close_tag() {}
    virtual ~ivy_ser(){}
};
struct ivy_binary_ser : public ivy_ser {
    std::vector<char> res;
    void set(long long inp) {
        for (int i = sizeof(long long)-1; i >= 0 ; i--)
            res.push_back((inp>>(8*i))&0xff);
    }
    void set(bool inp) {
        set((long long)inp);
    }
    void set(const std::string &inp) {
        for (unsigned i = 0; i < inp.size(); i++)
            res.push_back(inp[i]);
        res.push_back(0);
    }
    void open_list(int len) {
        set((long long)len);
    }
    void close_list() {}
    void open_list_elem() {}
    void close_list_elem() {}
    void open_struct() {}
    void close_struct() {}
    virtual void  open_field(const std::string &) {}
    void close_field() {}
    virtual void  open_tag(int tag, const std::string &) {
        set((long long)tag);
    }
    virtual void  close_tag() {}
};

struct ivy_deser {
    virtual void  get(long long&) = 0;
    virtual void  get(std::string &) = 0;
    virtual void  open_list() = 0;
    virtual void  close_list() = 0;
    virtual bool  open_list_elem() = 0;
    virtual void  close_list_elem() = 0;
    virtual void  open_struct() = 0;
    virtual void  close_struct() = 0;
    virtual void  open_field(const std::string &) = 0;
    virtual void  close_field() = 0;
    virtual int   open_tag(const std::vector<std::string> &) {throw deser_err();}
    virtual void  close_tag() {}
    virtual void  end() = 0;
    virtual ~ivy_deser(){}
};

struct ivy_binary_deser : public ivy_deser {
    std::vector<char> inp;
    int pos;
    std::vector<int> lenstack;
    ivy_binary_deser(const std::vector<char> &inp) : inp(inp),pos(0) {}
    virtual bool more(unsigned bytes) {return inp.size() >= pos + bytes;}
    virtual bool can_end() {return pos == inp.size();}
    void get(long long &res) {
       getn(res,8);
    }
    void getn(long long &res, int bytes) {
        if (!more(bytes))
            throw deser_err();
        res = 0;
        for (int i = 0; i < bytes; i++)
            res = (res << 8) | (((long long)inp[pos++]) & 0xff);
    }
    void get(std::string &res) {
        while (more(1) && inp[pos]) {
//            if (inp[pos] == '"')
//                throw deser_err();
            res.push_back(inp[pos++]);
        }
        if(!(more(1) && inp[pos] == 0))
            throw deser_err();
        pos++;
    }
    void open_list() {
        long long len;
        get(len);
        lenstack.push_back(len);
    }
    void close_list() {
        lenstack.pop_back();
    }
    bool open_list_elem() {
        return lenstack.back();
    }
    void close_list_elem() {
        lenstack.back()--;
    }
    void open_struct() {}
    void close_struct() {}
    virtual void  open_field(const std::string &) {}
    void close_field() {}
    int open_tag(const std::vector<std::string> &tags) {
        long long res;
        get(res);
        if (res >= tags.size())
            throw deser_err();
        return res;
    }
    void end() {
        if (!can_end())
            throw deser_err();
    }
};
struct ivy_socket_deser : public ivy_binary_deser {
      int sock;
    public:
      ivy_socket_deser(int sock, const std::vector<char> &inp)
          : ivy_binary_deser(inp), sock(sock) {}
    virtual bool more(unsigned bytes) {
        while (inp.size() < pos + bytes) {
            int oldsize = inp.size();
            int get = pos + bytes - oldsize;
            get = (get < 1024) ? 1024 : get;
            inp.resize(oldsize + get);
            int newbytes;
	    if ((newbytes = read(sock,&inp[oldsize],get)) < 0)
		 { std::cerr << "recvfrom failed\n"; exit(1); }
            inp.resize(oldsize + newbytes);
            if (newbytes == 0)
                 return false;
        }
        return true;
    }
    virtual bool can_end() {return true;}
};

struct out_of_bounds {
    std::string txt;
    int pos;
    out_of_bounds(int _idx, int pos = 0) : pos(pos){
        std::ostringstream os;
        os << "argument " << _idx+1;
        txt = os.str();
    }
    out_of_bounds(const std::string &s, int pos = 0) : txt(s), pos(pos) {}
};

template <class T> T _arg(std::vector<ivy_value> &args, unsigned idx, long long bound);

template <>
bool _arg<bool>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
    if (!(args[idx].atom == "true" || args[idx].atom == "false") || args[idx].fields.size())
        throw out_of_bounds(idx,args[idx].pos);
    return args[idx].atom == "true";
}

template <>
int _arg<int>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
    int res = atoi(args[idx].atom.c_str());
    if (bound && (res < 0 || res >= bound) || args[idx].fields.size())
        throw out_of_bounds(idx,args[idx].pos);
    return res;
}

template <>
long long _arg<long long>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
    long long res = atoll(args[idx].atom.c_str());
    if (bound && (res < 0 || res >= bound) || args[idx].fields.size())
        throw out_of_bounds(idx,args[idx].pos);
    return res;
}

std::ostream &operator <<(std::ostream &s, const __strlit &t){
    s << "\"" << t.c_str() << "\"";
    return s;
}

template <>
__strlit _arg<__strlit>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
    if (args[idx].fields.size())
        throw out_of_bounds(idx,args[idx].pos);
    return args[idx].atom;
}

template <class T> void __ser(ivy_ser &res, const T &inp);

template <>
void __ser<int>(ivy_ser &res, const int &inp) {
    res.set((long long)inp);
}

template <>
void __ser<long long>(ivy_ser &res, const long long &inp) {
    res.set(inp);
}

template <>
void __ser<bool>(ivy_ser &res, const bool &inp) {
    res.set(inp);
}

template <>
void __ser<__strlit>(ivy_ser &res, const __strlit &inp) {
    res.set(inp);
}

template <class T> void __deser(ivy_deser &inp, T &res);

template <>
void __deser<int>(ivy_deser &inp, int &res) {
    long long temp;
    inp.get(temp);
    res = temp;
}

template <>
void __deser<long long>(ivy_deser &inp, long long &res) {
    inp.get(res);
}

template <>
void __deser<__strlit>(ivy_deser &inp, __strlit &res) {
    inp.get(res);
}

template <>
void __deser<bool>(ivy_deser &inp, bool &res) {
    long long thing;
    inp.get(thing);
    res = thing;
}

class gen;

std::ostream &operator <<(std::ostream &s, const quic_monitor::ip__protocol &t);
template <>
quic_monitor::ip__protocol _arg<quic_monitor::ip__protocol>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<quic_monitor::ip__protocol>(ivy_ser &res, const quic_monitor::ip__protocol&);
template <>
void  __deser<quic_monitor::ip__protocol>(ivy_deser &inp, quic_monitor::ip__protocol &res);
std::ostream &operator <<(std::ostream &s, const quic_monitor::frame__ack &t);
template <>
quic_monitor::frame__ack _arg<quic_monitor::frame__ack>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<quic_monitor::frame__ack>(ivy_ser &res, const quic_monitor::frame__ack&);
template <>
void  __deser<quic_monitor::frame__ack>(ivy_deser &inp, quic_monitor::frame__ack &res);
std::ostream &operator <<(std::ostream &s, const quic_monitor::frame__ack__block &t);
template <>
quic_monitor::frame__ack__block _arg<quic_monitor::frame__ack__block>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<quic_monitor::frame__ack__block>(ivy_ser &res, const quic_monitor::frame__ack__block&);
template <>
void  __deser<quic_monitor::frame__ack__block>(ivy_deser &inp, quic_monitor::frame__ack__block &res);
std::ostream &operator <<(std::ostream &s, const quic_monitor::frame__stream &t);
template <>
quic_monitor::frame__stream _arg<quic_monitor::frame__stream>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<quic_monitor::frame__stream>(ivy_ser &res, const quic_monitor::frame__stream&);
template <>
void  __deser<quic_monitor::frame__stream>(ivy_deser &inp, quic_monitor::frame__stream &res);
std::ostream &operator <<(std::ostream &s, const quic_monitor::ip__endpoint &t);
template <>
quic_monitor::ip__endpoint _arg<quic_monitor::ip__endpoint>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<quic_monitor::ip__endpoint>(ivy_ser &res, const quic_monitor::ip__endpoint&);
template <>
void  __deser<quic_monitor::ip__endpoint>(ivy_deser &inp, quic_monitor::ip__endpoint &res);
std::ostream &operator <<(std::ostream &s, const quic_monitor::quic_packet &t);
template <>
quic_monitor::quic_packet _arg<quic_monitor::quic_packet>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<quic_monitor::quic_packet>(ivy_ser &res, const quic_monitor::quic_packet&);
template <>
void  __deser<quic_monitor::quic_packet>(ivy_deser &inp, quic_monitor::quic_packet &res);
std::ostream &operator <<(std::ostream &s, const quic_monitor::tls__client_hello &t);
template <>
quic_monitor::tls__client_hello _arg<quic_monitor::tls__client_hello>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<quic_monitor::tls__client_hello>(ivy_ser &res, const quic_monitor::tls__client_hello&);
template <>
void  __deser<quic_monitor::tls__client_hello>(ivy_deser &inp, quic_monitor::tls__client_hello &res);
std::ostream &operator <<(std::ostream &s, const quic_monitor::tls__extension &t);
template <>
quic_monitor::tls__extension _arg<quic_monitor::tls__extension>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<quic_monitor::tls__extension>(ivy_ser &res, const quic_monitor::tls__extension&);
template <>
void  __deser<quic_monitor::tls__extension>(ivy_deser &inp, quic_monitor::tls__extension &res);
std::ostream &operator <<(std::ostream &s, const quic_monitor::tls__handshake_record &t);
template <>
quic_monitor::tls__handshake_record _arg<quic_monitor::tls__handshake_record>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<quic_monitor::tls__handshake_record>(ivy_ser &res, const quic_monitor::tls__handshake_record&);
template <>
void  __deser<quic_monitor::tls__handshake_record>(ivy_deser &inp, quic_monitor::tls__handshake_record &res);
std::ostream &operator <<(std::ostream &s, const quic_monitor::tls__random &t);
template <>
quic_monitor::tls__random _arg<quic_monitor::tls__random>(std::vector<ivy_value> &args, unsigned idx, long long bound);
template <>
void  __ser<quic_monitor::tls__random>(ivy_ser &res, const quic_monitor::tls__random&);
template <>
void  __deser<quic_monitor::tls__random>(ivy_deser &inp, quic_monitor::tls__random &res);
bool operator==(const quic_monitor::__tup__ip__endpoint__long_long__long_long &x, const quic_monitor::__tup__ip__endpoint__long_long__long_long &y){
    return x.arg0 == y.arg0 && x.arg1 == y.arg1 && x.arg2 == y.arg2;
}
bool operator==(const quic_monitor::__tup__ip__endpoint__long_long &x, const quic_monitor::__tup__ip__endpoint__long_long &y){
    return x.arg0 == y.arg0 && x.arg1 == y.arg1;
}
bool operator==(const quic_monitor::__tup__ip__endpoint__ip__endpoint &x, const quic_monitor::__tup__ip__endpoint__ip__endpoint &y){
    return x.arg0 == y.arg0 && x.arg1 == y.arg1;
}

int quic_monitor::frame::temp_counter = 0;

std::ostream &operator <<(std::ostream &s, const quic_monitor::frame &t){
    s << "{";
    switch (t.tag) {
        case 0: s << "frame.stream:" << (static_cast<const quic_monitor::frame::twrap<quic_monitor::frame__stream> *>((t).ptr)->item); break;
        case 1: s << "frame.ack:" << (static_cast<const quic_monitor::frame::twrap<quic_monitor::frame__ack> *>((t).ptr)->item); break;

    }
    s << "}";
    return s;
}
template <>
quic_monitor::frame _arg<quic_monitor::frame>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
    if (args[idx].atom.size())
        throw out_of_bounds("unexpected value for sort frame: " + args[idx].atom,args[idx].pos);
    if (args[idx].fields.size() == 0)
        return quic_monitor::frame();
    if (args[idx].fields.size() != 1)
        throw out_of_bounds("too many fields for sort frame (expected one)",args[idx].pos);
    if (args[idx].fields[0].atom == "frame.stream") return quic_monitor::frame(0, new quic_monitor::frame::twrap<quic_monitor::frame__stream>(_arg<quic_monitor::frame__stream>(args[idx].fields[0].fields,0,0)));
    if (args[idx].fields[0].atom == "frame.ack") return quic_monitor::frame(1, new quic_monitor::frame::twrap<quic_monitor::frame__ack>(_arg<quic_monitor::frame__ack>(args[idx].fields[0].fields,0,0)));

        throw out_of_bounds("unexpected field sort SORTNAME: " + args[idx].fields[0].atom, args[idx].pos);
}
template <>
void __ser<quic_monitor::frame>(ivy_ser &res, const quic_monitor::frame &inp) {
    if (inp.tag == 0) {res.open_tag(0,"frame.stream"); __ser(res,(static_cast<const quic_monitor::frame::twrap<quic_monitor::frame__stream> *>((inp).ptr)->item)); res.close_tag();}
    if (inp.tag == 1) {res.open_tag(1,"frame.ack"); __ser(res,(static_cast<const quic_monitor::frame::twrap<quic_monitor::frame__ack> *>((inp).ptr)->item)); res.close_tag();}

}
template <>
void __deser<quic_monitor::frame>(ivy_deser &res, quic_monitor::frame &inp) {
    std::vector<std::string> tags;
    tags.push_back("frame.stream");
    tags.push_back("frame.ack");

    int tag = res.open_tag(tags);
    switch (tag) {
    case 0: {quic_monitor::frame__stream tmp; __deser(res,tmp); inp = quic_monitor::frame(0, new quic_monitor::frame::twrap<quic_monitor::frame__stream>(tmp)); break;} 
    case 1: {quic_monitor::frame__ack tmp; __deser(res,tmp); inp = quic_monitor::frame(1, new quic_monitor::frame::twrap<quic_monitor::frame__ack>(tmp)); break;} 

    }
    res.close_tag();
}
#ifdef Z3PP_H_
template <>
void __from_solver<quic_monitor::frame>( gen &g, const  z3::expr &v, quic_monitor::frame &res) {
    {
        z3::sort sort = g.sort("frame.stream");
        z3::func_decl pto = g.ctx.function("*>:frame",g.sort("frame"),g.sort("frame.stream"),g.ctx.bool_sort());
        std::cout <<  g.model << std::endl;
        Z3_ast_vector av = Z3_model_get_sort_universe(g.ctx, g.model, sort);
        if (av) {
            z3::expr_vector univ(g.ctx,av);
            for (unsigned i = 0; i < univ.size(); i++){
                if (eq(g.model.eval(pto(v,univ[i]),true),g.ctx.bool_val(true))){
                    quic_monitor::frame__stream tmp;
                    __from_solver(g,univ[i],tmp);                    res = quic_monitor::frame(0, new quic_monitor::frame::twrap<quic_monitor::frame__stream>(tmp));
                }
            }
        }
    }
    {
        z3::sort sort = g.sort("frame.ack");
        z3::func_decl pto = g.ctx.function("*>:frame",g.sort("frame"),g.sort("frame.ack"),g.ctx.bool_sort());
        std::cout <<  g.model << std::endl;
        Z3_ast_vector av = Z3_model_get_sort_universe(g.ctx, g.model, sort);
        if (av) {
            z3::expr_vector univ(g.ctx,av);
            for (unsigned i = 0; i < univ.size(); i++){
                if (eq(g.model.eval(pto(v,univ[i]),true),g.ctx.bool_val(true))){
                    quic_monitor::frame__ack tmp;
                    __from_solver(g,univ[i],tmp);                    res = quic_monitor::frame(1, new quic_monitor::frame::twrap<quic_monitor::frame__ack>(tmp));
                }
            }
        }
    }

}
template <>
z3::expr __to_solver<quic_monitor::frame>( gen &g, const  z3::expr &v, quic_monitor::frame &val) {
//    std::cout << v << ":" << v.get_sort() << std::endl;
    if (val.tag == 0) {
        z3::func_decl pto = g.ctx.function("*>:frame",g.sort("frame"),g.sort("frame.stream"),g.ctx.bool_sort());
        z3::expr X = g.ctx.constant("X",g.sort("frame.stream"));
        quic_monitor::frame__stream tmp = (static_cast<const quic_monitor::frame::twrap<quic_monitor::frame__stream> *>((val).ptr)->item);
        return exists(X,pto(v,X) && __to_solver(g,X,tmp));
    }
    if (val.tag == 1) {
        z3::func_decl pto = g.ctx.function("*>:frame",g.sort("frame"),g.sort("frame.ack"),g.ctx.bool_sort());
        z3::expr X = g.ctx.constant("X",g.sort("frame.ack"));
        quic_monitor::frame__ack tmp = (static_cast<const quic_monitor::frame::twrap<quic_monitor::frame__ack> *>((val).ptr)->item);
        return exists(X,pto(v,X) && __to_solver(g,X,tmp));
    }

    z3::expr conj = g.ctx.bool_val(false);
    {
        z3::func_decl pto = g.ctx.function("*>:frame",g.sort("frame"),g.sort("frame.stream"),g.ctx.bool_sort());
        z3::expr Y = g.ctx.constant("Y",g.sort("frame.stream"));
        conj = conj && forall(Y,!pto(v,Y));
    }
    {
        z3::func_decl pto = g.ctx.function("*>:frame",g.sort("frame"),g.sort("frame.ack"),g.ctx.bool_sort());
        z3::expr Y = g.ctx.constant("Y",g.sort("frame.ack"));
        conj = conj && forall(Y,!pto(v,Y));
    }

    return conj;
}
template <>
void __randomize<quic_monitor::frame>( gen &g, const  z3::expr &apply_expr) {
    std::ostringstream os;
    os << "__frame__tmp" << quic_monitor::frame::temp_counter++;
    std::string temp = os.str();
    z3::sort range = apply_expr.get_sort();
    z3::expr disj = g.ctx.bool_val(false);
int tag = rand() % 2;
    if (tag == 0) {
        z3::func_decl pto = g.ctx.function("*>:frame",g.sort("frame"),g.sort("frame.stream"),g.ctx.bool_sort());
        z3::expr X = g.ctx.constant(temp.c_str(),g.sort("frame.stream"));
        z3::expr pred = pto(apply_expr,X);
        g.add_alit(pred);
        __randomize<quic_monitor::frame__stream>(g,X);
    }
    if (tag == 1) {
        z3::func_decl pto = g.ctx.function("*>:frame",g.sort("frame"),g.sort("frame.ack"),g.ctx.bool_sort());
        z3::expr X = g.ctx.constant(temp.c_str(),g.sort("frame.ack"));
        z3::expr pred = pto(apply_expr,X);
        g.add_alit(pred);
        __randomize<quic_monitor::frame__ack>(g,X);
    }

}
#endif

int quic_monitor::tls__handshake::temp_counter = 0;

std::ostream &operator <<(std::ostream &s, const quic_monitor::tls__handshake &t){
    s << "{";
    switch (t.tag) {
        case 0: s << "tls.client_hello:" << (static_cast<const quic_monitor::tls__handshake::twrap<quic_monitor::tls__client_hello> *>((t).ptr)->item); break;

    }
    s << "}";
    return s;
}
template <>
quic_monitor::tls__handshake _arg<quic_monitor::tls__handshake>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
    if (args[idx].atom.size())
        throw out_of_bounds("unexpected value for sort tls.handshake: " + args[idx].atom,args[idx].pos);
    if (args[idx].fields.size() == 0)
        return quic_monitor::tls__handshake();
    if (args[idx].fields.size() != 1)
        throw out_of_bounds("too many fields for sort tls.handshake (expected one)",args[idx].pos);
    if (args[idx].fields[0].atom == "tls.client_hello") return quic_monitor::tls__handshake(0, new quic_monitor::tls__handshake::twrap<quic_monitor::tls__client_hello>(_arg<quic_monitor::tls__client_hello>(args[idx].fields[0].fields,0,0)));

        throw out_of_bounds("unexpected field sort SORTNAME: " + args[idx].fields[0].atom, args[idx].pos);
}
template <>
void __ser<quic_monitor::tls__handshake>(ivy_ser &res, const quic_monitor::tls__handshake &inp) {
    if (inp.tag == 0) {res.open_tag(0,"tls.client_hello"); __ser(res,(static_cast<const quic_monitor::tls__handshake::twrap<quic_monitor::tls__client_hello> *>((inp).ptr)->item)); res.close_tag();}

}
template <>
void __deser<quic_monitor::tls__handshake>(ivy_deser &res, quic_monitor::tls__handshake &inp) {
    std::vector<std::string> tags;
    tags.push_back("tls.client_hello");

    int tag = res.open_tag(tags);
    switch (tag) {
    case 0: {quic_monitor::tls__client_hello tmp; __deser(res,tmp); inp = quic_monitor::tls__handshake(0, new quic_monitor::tls__handshake::twrap<quic_monitor::tls__client_hello>(tmp)); break;} 

    }
    res.close_tag();
}
#ifdef Z3PP_H_
template <>
void __from_solver<quic_monitor::tls__handshake>( gen &g, const  z3::expr &v, quic_monitor::tls__handshake &res) {
    {
        z3::sort sort = g.sort("tls.client_hello");
        z3::func_decl pto = g.ctx.function("*>:tls.handshake",g.sort("tls.handshake"),g.sort("tls.client_hello"),g.ctx.bool_sort());
        std::cout <<  g.model << std::endl;
        Z3_ast_vector av = Z3_model_get_sort_universe(g.ctx, g.model, sort);
        if (av) {
            z3::expr_vector univ(g.ctx,av);
            for (unsigned i = 0; i < univ.size(); i++){
                if (eq(g.model.eval(pto(v,univ[i]),true),g.ctx.bool_val(true))){
                    quic_monitor::tls__client_hello tmp;
                    __from_solver(g,univ[i],tmp);                    res = quic_monitor::tls__handshake(0, new quic_monitor::tls__handshake::twrap<quic_monitor::tls__client_hello>(tmp));
                }
            }
        }
    }

}
template <>
z3::expr __to_solver<quic_monitor::tls__handshake>( gen &g, const  z3::expr &v, quic_monitor::tls__handshake &val) {
//    std::cout << v << ":" << v.get_sort() << std::endl;
    if (val.tag == 0) {
        z3::func_decl pto = g.ctx.function("*>:tls.handshake",g.sort("tls.handshake"),g.sort("tls.client_hello"),g.ctx.bool_sort());
        z3::expr X = g.ctx.constant("X",g.sort("tls.client_hello"));
        quic_monitor::tls__client_hello tmp = (static_cast<const quic_monitor::tls__handshake::twrap<quic_monitor::tls__client_hello> *>((val).ptr)->item);
        return exists(X,pto(v,X) && __to_solver(g,X,tmp));
    }

    z3::expr conj = g.ctx.bool_val(false);
    {
        z3::func_decl pto = g.ctx.function("*>:tls.handshake",g.sort("tls.handshake"),g.sort("tls.client_hello"),g.ctx.bool_sort());
        z3::expr Y = g.ctx.constant("Y",g.sort("tls.client_hello"));
        conj = conj && forall(Y,!pto(v,Y));
    }

    return conj;
}
template <>
void __randomize<quic_monitor::tls__handshake>( gen &g, const  z3::expr &apply_expr) {
    std::ostringstream os;
    os << "__tls.handshake__tmp" << quic_monitor::tls__handshake::temp_counter++;
    std::string temp = os.str();
    z3::sort range = apply_expr.get_sort();
    z3::expr disj = g.ctx.bool_val(false);
int tag = rand() % 1;
    if (tag == 0) {
        z3::func_decl pto = g.ctx.function("*>:tls.handshake",g.sort("tls.handshake"),g.sort("tls.client_hello"),g.ctx.bool_sort());
        z3::expr X = g.ctx.constant(temp.c_str(),g.sort("tls.client_hello"));
        z3::expr pred = pto(apply_expr,X);
        g.add_alit(pred);
        __randomize<quic_monitor::tls__client_hello>(g,X);
    }

}
#endif

int quic_monitor::tls__record::temp_counter = 0;

std::ostream &operator <<(std::ostream &s, const quic_monitor::tls__record &t){
    s << "{";
    switch (t.tag) {
        case 0: s << "tls.handshake_record:" << (static_cast<const quic_monitor::tls__record::twrap<quic_monitor::tls__handshake_record> *>((t).ptr)->item); break;

    }
    s << "}";
    return s;
}
template <>
quic_monitor::tls__record _arg<quic_monitor::tls__record>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
    if (args[idx].atom.size())
        throw out_of_bounds("unexpected value for sort tls.record: " + args[idx].atom,args[idx].pos);
    if (args[idx].fields.size() == 0)
        return quic_monitor::tls__record();
    if (args[idx].fields.size() != 1)
        throw out_of_bounds("too many fields for sort tls.record (expected one)",args[idx].pos);
    if (args[idx].fields[0].atom == "tls.handshake_record") return quic_monitor::tls__record(0, new quic_monitor::tls__record::twrap<quic_monitor::tls__handshake_record>(_arg<quic_monitor::tls__handshake_record>(args[idx].fields[0].fields,0,0)));

        throw out_of_bounds("unexpected field sort SORTNAME: " + args[idx].fields[0].atom, args[idx].pos);
}
template <>
void __ser<quic_monitor::tls__record>(ivy_ser &res, const quic_monitor::tls__record &inp) {
    if (inp.tag == 0) {res.open_tag(0,"tls.handshake_record"); __ser(res,(static_cast<const quic_monitor::tls__record::twrap<quic_monitor::tls__handshake_record> *>((inp).ptr)->item)); res.close_tag();}

}
template <>
void __deser<quic_monitor::tls__record>(ivy_deser &res, quic_monitor::tls__record &inp) {
    std::vector<std::string> tags;
    tags.push_back("tls.handshake_record");

    int tag = res.open_tag(tags);
    switch (tag) {
    case 0: {quic_monitor::tls__handshake_record tmp; __deser(res,tmp); inp = quic_monitor::tls__record(0, new quic_monitor::tls__record::twrap<quic_monitor::tls__handshake_record>(tmp)); break;} 

    }
    res.close_tag();
}
#ifdef Z3PP_H_
template <>
void __from_solver<quic_monitor::tls__record>( gen &g, const  z3::expr &v, quic_monitor::tls__record &res) {
    {
        z3::sort sort = g.sort("tls.handshake_record");
        z3::func_decl pto = g.ctx.function("*>:tls.record",g.sort("tls.record"),g.sort("tls.handshake_record"),g.ctx.bool_sort());
        std::cout <<  g.model << std::endl;
        Z3_ast_vector av = Z3_model_get_sort_universe(g.ctx, g.model, sort);
        if (av) {
            z3::expr_vector univ(g.ctx,av);
            for (unsigned i = 0; i < univ.size(); i++){
                if (eq(g.model.eval(pto(v,univ[i]),true),g.ctx.bool_val(true))){
                    quic_monitor::tls__handshake_record tmp;
                    __from_solver(g,univ[i],tmp);                    res = quic_monitor::tls__record(0, new quic_monitor::tls__record::twrap<quic_monitor::tls__handshake_record>(tmp));
                }
            }
        }
    }

}
template <>
z3::expr __to_solver<quic_monitor::tls__record>( gen &g, const  z3::expr &v, quic_monitor::tls__record &val) {
//    std::cout << v << ":" << v.get_sort() << std::endl;
    if (val.tag == 0) {
        z3::func_decl pto = g.ctx.function("*>:tls.record",g.sort("tls.record"),g.sort("tls.handshake_record"),g.ctx.bool_sort());
        z3::expr X = g.ctx.constant("X",g.sort("tls.handshake_record"));
        quic_monitor::tls__handshake_record tmp = (static_cast<const quic_monitor::tls__record::twrap<quic_monitor::tls__handshake_record> *>((val).ptr)->item);
        return exists(X,pto(v,X) && __to_solver(g,X,tmp));
    }

    z3::expr conj = g.ctx.bool_val(false);
    {
        z3::func_decl pto = g.ctx.function("*>:tls.record",g.sort("tls.record"),g.sort("tls.handshake_record"),g.ctx.bool_sort());
        z3::expr Y = g.ctx.constant("Y",g.sort("tls.handshake_record"));
        conj = conj && forall(Y,!pto(v,Y));
    }

    return conj;
}
template <>
void __randomize<quic_monitor::tls__record>( gen &g, const  z3::expr &apply_expr) {
    std::ostringstream os;
    os << "__tls.record__tmp" << quic_monitor::tls__record::temp_counter++;
    std::string temp = os.str();
    z3::sort range = apply_expr.get_sort();
    z3::expr disj = g.ctx.bool_val(false);
int tag = rand() % 1;
    if (tag == 0) {
        z3::func_decl pto = g.ctx.function("*>:tls.record",g.sort("tls.record"),g.sort("tls.handshake_record"),g.ctx.bool_sort());
        z3::expr X = g.ctx.constant(temp.c_str(),g.sort("tls.handshake_record"));
        z3::expr pred = pto(apply_expr,X);
        g.add_alit(pred);
        __randomize<quic_monitor::tls__handshake_record>(g,X);
    }

}
#endif
	    std::ostream &operator <<(std::ostream &s, const quic_monitor::stream_data &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    quic_monitor::stream_data _arg<quic_monitor::stream_data>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        quic_monitor::stream_data a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<int>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<quic_monitor::stream_data>(ivy_deser &inp, quic_monitor::stream_data &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<quic_monitor::stream_data>(ivy_ser &res, const quic_monitor::stream_data &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, quic_monitor::stream_data& val) {
	        z3::expr z3end = g.apply("stream_data.end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("stream_data.value",z3val,g.int_to_z3(g.sort("stream_pos"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<quic_monitor::stream_data>( gen &g, const  z3::expr &v,quic_monitor::stream_data &res){
	        int __end;
	        __from_solver(g,g.apply("stream_data.end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("stream_data.value",v,g.int_to_z3(g.sort("stream_pos"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<quic_monitor::stream_data>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("stream_pos"),__sz);
                z3::expr pred =  g.apply("stream_data.end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<int>(g,g.apply("stream_data.value",v,g.int_to_z3(g.sort("stream_pos"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const quic_monitor::frame__ack__block__arr &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    quic_monitor::frame__ack__block__arr _arg<quic_monitor::frame__ack__block__arr>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        quic_monitor::frame__ack__block__arr a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<quic_monitor::frame__ack__block>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<quic_monitor::frame__ack__block__arr>(ivy_deser &inp, quic_monitor::frame__ack__block__arr &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<quic_monitor::frame__ack__block__arr>(ivy_ser &res, const quic_monitor::frame__ack__block__arr &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, quic_monitor::frame__ack__block__arr& val) {
	        z3::expr z3end = g.apply("frame.ack.block.arr.end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("frame.ack.block.arr.value",z3val,g.int_to_z3(g.sort("frame.ack.block.idx"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<quic_monitor::frame__ack__block__arr>( gen &g, const  z3::expr &v,quic_monitor::frame__ack__block__arr &res){
	        int __end;
	        __from_solver(g,g.apply("frame.ack.block.arr.end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("frame.ack.block.arr.value",v,g.int_to_z3(g.sort("frame.ack.block.idx"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<quic_monitor::frame__ack__block__arr>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("frame.ack.block.idx"),__sz);
                z3::expr pred =  g.apply("frame.ack.block.arr.end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<quic_monitor::frame__ack__block>(g,g.apply("frame.ack.block.arr.value",v,g.int_to_z3(g.sort("frame.ack.block.idx"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const quic_monitor::frame__arr &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    quic_monitor::frame__arr _arg<quic_monitor::frame__arr>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        quic_monitor::frame__arr a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<quic_monitor::frame>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<quic_monitor::frame__arr>(ivy_deser &inp, quic_monitor::frame__arr &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<quic_monitor::frame__arr>(ivy_ser &res, const quic_monitor::frame__arr &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, quic_monitor::frame__arr& val) {
	        z3::expr z3end = g.apply("frame.arr.end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("frame.arr.value",z3val,g.int_to_z3(g.sort("frame.idx"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<quic_monitor::frame__arr>( gen &g, const  z3::expr &v,quic_monitor::frame__arr &res){
	        int __end;
	        __from_solver(g,g.apply("frame.arr.end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("frame.arr.value",v,g.int_to_z3(g.sort("frame.idx"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<quic_monitor::frame__arr>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("frame.idx"),__sz);
                z3::expr pred =  g.apply("frame.arr.end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<quic_monitor::frame>(g,g.apply("frame.arr.value",v,g.int_to_z3(g.sort("frame.idx"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const quic_monitor::tls__cipher_suite_seq &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    quic_monitor::tls__cipher_suite_seq _arg<quic_monitor::tls__cipher_suite_seq>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        quic_monitor::tls__cipher_suite_seq a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<int>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<quic_monitor::tls__cipher_suite_seq>(ivy_deser &inp, quic_monitor::tls__cipher_suite_seq &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<quic_monitor::tls__cipher_suite_seq>(ivy_ser &res, const quic_monitor::tls__cipher_suite_seq &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, quic_monitor::tls__cipher_suite_seq& val) {
	        z3::expr z3end = g.apply("tls.cipher_suite_seq.end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("tls.cipher_suite_seq.value",z3val,g.int_to_z3(g.sort("tls.cipher_suite_idx"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<quic_monitor::tls__cipher_suite_seq>( gen &g, const  z3::expr &v,quic_monitor::tls__cipher_suite_seq &res){
	        int __end;
	        __from_solver(g,g.apply("tls.cipher_suite_seq.end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("tls.cipher_suite_seq.value",v,g.int_to_z3(g.sort("tls.cipher_suite_idx"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<quic_monitor::tls__cipher_suite_seq>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("tls.cipher_suite_idx"),__sz);
                z3::expr pred =  g.apply("tls.cipher_suite_seq.end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<int>(g,g.apply("tls.cipher_suite_seq.value",v,g.int_to_z3(g.sort("tls.cipher_suite_idx"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const quic_monitor::vector__tls__extension__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    quic_monitor::vector__tls__extension__ _arg<quic_monitor::vector__tls__extension__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        quic_monitor::vector__tls__extension__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<quic_monitor::tls__extension>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<quic_monitor::vector__tls__extension__>(ivy_deser &inp, quic_monitor::vector__tls__extension__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<quic_monitor::vector__tls__extension__>(ivy_ser &res, const quic_monitor::vector__tls__extension__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, quic_monitor::vector__tls__extension__& val) {
	        z3::expr z3end = g.apply("vector[tls.extension].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[tls.extension].value",z3val,g.int_to_z3(g.sort("vector[tls.extension].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<quic_monitor::vector__tls__extension__>( gen &g, const  z3::expr &v,quic_monitor::vector__tls__extension__ &res){
	        int __end;
	        __from_solver(g,g.apply("vector[tls.extension].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[tls.extension].value",v,g.int_to_z3(g.sort("vector[tls.extension].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<quic_monitor::vector__tls__extension__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[tls.extension].domain"),__sz);
                z3::expr pred =  g.apply("vector[tls.extension].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<quic_monitor::tls__extension>(g,g.apply("vector[tls.extension].value",v,g.int_to_z3(g.sort("vector[tls.extension].domain"),__i)));
	    }
	    #endif

		    std::ostream &operator <<(std::ostream &s, const quic_monitor::vector__tls__handshake__ &a) {
	        s << '[';
		for (unsigned i = 0; i < a.size(); i++) {
		    if (i != 0)
		        s << ',';
		    s << a[i];
		}
	        s << ']';
		return s;
            }

	    template <>
	    quic_monitor::vector__tls__handshake__ _arg<quic_monitor::vector__tls__handshake__>(std::vector<ivy_value> &args, unsigned idx, long long bound) {
	        ivy_value &arg = args[idx];
	        if (arg.atom.size()) 
	            throw out_of_bounds(idx);
	        quic_monitor::vector__tls__handshake__ a;
	        a.resize(arg.fields.size());
		for (unsigned i = 0; i < a.size(); i++) {
		    a[i] = _arg<quic_monitor::tls__handshake>(arg.fields,i,0);
	        }
	        return a;
	    }

	    template <>
	    void __deser<quic_monitor::vector__tls__handshake__>(ivy_deser &inp, quic_monitor::vector__tls__handshake__ &res) {
	        inp.open_list();
	        while(inp.open_list_elem()) {
		    res.resize(res.size()+1);
	            __deser(inp,res.back());
		    inp.close_list_elem();
                }
		inp.close_list();
	    }

	    template <>
	    void __ser<quic_monitor::vector__tls__handshake__>(ivy_ser &res, const quic_monitor::vector__tls__handshake__ &inp) {
	        int sz = inp.size();
	        res.open_list(sz);
	        for (unsigned i = 0; i < (unsigned)sz; i++) {
		    res.open_list_elem();
	            __ser(res,inp[i]);
		    res.close_list_elem();
                }
	        res.close_list();
	    }

	    #ifdef Z3PP_H_
	    template <>
            z3::expr __to_solver(gen& g, const z3::expr& z3val, quic_monitor::vector__tls__handshake__& val) {
	        z3::expr z3end = g.apply("vector[tls.handshake].end",z3val);
	        z3::expr __ret = z3end  == g.int_to_z3(z3end.get_sort(),val.size());
	        unsigned __sz = val.size();
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __ret = __ret && __to_solver(g,g.apply("vector[tls.handshake].value",z3val,g.int_to_z3(g.sort("vector[tls.handshake].domain"),__i)),val[__i]);
                return __ret;
            }

	    template <>
	    void  __from_solver<quic_monitor::vector__tls__handshake__>( gen &g, const  z3::expr &v,quic_monitor::vector__tls__handshake__ &res){
	        int __end;
	        __from_solver(g,g.apply("vector[tls.handshake].end",v),__end);
	        unsigned __sz = (unsigned) __end;
	        res.resize(__sz);
	        for (unsigned __i = 0; __i < __sz; ++__i)
		    __from_solver(g,g.apply("vector[tls.handshake].value",v,g.int_to_z3(g.sort("vector[tls.handshake].domain"),__i)),res[__i]);
	    }

	    template <>
	    void  __randomize<quic_monitor::vector__tls__handshake__>( gen &g, const  z3::expr &v){
	        unsigned __sz = rand() % 4;
                z3::expr val_expr = g.int_to_z3(g.sort("vector[tls.handshake].domain"),__sz);
                z3::expr pred =  g.apply("vector[tls.handshake].end",v) == val_expr;
                g.add_alit(pred);
	        for (unsigned __i = 0; __i < __sz; ++__i)
	            __randomize<quic_monitor::tls__handshake>(g,g.apply("vector[tls.handshake].value",v,g.int_to_z3(g.sort("vector[tls.handshake].domain"),__i)));
	    }
	    #endif

	
    typedef struct tls_name_struct {
        const char *name;
        int value;
    } *tls_name_struct_ptr;

    struct tls_name_map : hash_space::hash_map<std::string,int> {};

    struct tls_name_struct tls_field_length_bytes[5] = {
        {"tls.handshake_record.fragment",2},
        {"tls.extension.content",2},
        {"tls.client_hello",3},
        {"tls.compression_method",1},
        {0,0}
    };
    tls_name_map tls_field_length_bytes_map;

    struct tls_name_struct *tls_field_bytes[6] = {
        {"tls.handshake_record.version",2},
        {"tls.extension_type",2},
        {"tls.gmt_unix_time",2},
        {"tls.cipher_suites",2},
        {"tls.compression_method",1},
        0
    };
    tls_name_map tls_field_bytes_map;

    struct tls_name_struct *tls_tags[3] = {
        {"tls.handshake_record",22},
        {"tls.client_hello",1},
        0        
    }
    tls_name_map tls_tags_map;

    void tls_make_name_map(tls_name_struct **vals, tls_name_map &map) {
        while (*vals) {
            map[(*vals)->name] = (*vals)->value;
            vals++;
        }
    }

    class quic_monitor::tls_deser_class : public ivy_binary_deser {
        int field_bytes;
        std:vector<unsigned> fence;

    public:

        tls_deser_class(const std::vector<char> &inp) : ivy_binary_deser(inp) {
            field_bytes = 2;
        }

        virtual bool more(unsigned bytes) {
            if (fence.size() > 0 && pos + bytes > fence.back())
                return false;
            return ivy_binary_deser::more(bytes);
        }
    
        virtual void open_field(const std::string &name) {
            if (tls_field_length_bytes.find(name) != tls_field_length_bytes.end()) {
                int length_field_bytes = tls_field_length_bytes[name];
                long long bytes;
                getn(bytes,length_field_bytes);
                fence.push_back(pos+bytes);
            }
            else if (fence.size() > 0)
                fence.push_back(fence.back());
            if (tls_field_bytes.find(name) != tls_field_bytes.end()) {
                field_bytes = tls_field_bytes[name]
            }
        }

        virtual void close_field() {
            if (tls_field_length_bytes.find(name) != tls_field_length_bytes.end()) {
                fence.pop_back();
            }
            else if (fence.size() > 0)
                fence.pop_back();
        }

        virtual int open_tag(const std::vector<std::string> &tags) {
            long long tag;
            getn(tag,1);
            for (int i = 0; i < tags.size(); i++) {
                if (tag == tls_tags_map[tags[i]])
                   open_field(tags[i]);
                   return i;
            }
            throw deser_err();
        }

        virtual void close_tag() {
            close_field();
        }

        virtual void get(long long &res) {
            getn(res,field_bytes);
        }

        virtual bool open_list_elem() {
            return more(1);
        }
        void close_list_elem() {}

        void open_list() {}
        void close_list() {}

        ~tls_deser_class(){}
    };


    class quic_monitor::quic_deser : public ivy_binary_deser {
        enum {quic_s_init,
              quic_s_type,
              quic_s_cid,
              quic_s_version,
              quic_s_pkt_num,
              quic_s_payload,
              quic_stream_id,
              quic_stream_off,
              quic_stream_len,
              quic_stream_fin,
              quic_stream_offset,
              quic_stream_length,
              quic_stream_data,
              quic_ack_largest,
              quic_ack_delay,
              quic_ack_block_count,
              quic_ack_gap,
              quic_ack_block,
              quic_s_done} state;
        bool long_format;
        char hdr_type;
        char frame_type;
        int data_remaining;
        long long ack_blocks_expected;
        long long ack_block_count;

    public:
        quic_deser(const std::vector<char> &inp) : ivy_binary_deser(inp),state(quic_s_init) {
            pos = 42; // skip 42 bytes of IP and UDP header
        }
        virtual void  get(long long &res) {
            switch (state) {
            case quic_s_init:
            {
                getn(res,1);
                long_format = (res & 0x80) ? true : false;
                hdr_type = res & 0x7f;
                res = long_format;
                state = quic_s_type;
            }
            break;
            case quic_s_type:
            {
                res = hdr_type;
                state = quic_s_cid;
            }
            break;
            case quic_s_cid:
            {
                ivy_binary_deser::get(res);
                state = quic_s_version;
            }
            break;
            case quic_s_version:
            {
                if (long_format)
                    ivy_binary_deser::getn(res,4);
                else
                    res = 0;
                state = quic_s_pkt_num;
            }
            break;
            case quic_s_pkt_num:
            {
                ivy_binary_deser::getn(res,(long_format || (hdr_type & 0x1f) == 0x1d) ? 4 : (hdr_type & 0x1f) == 0x1e ? 2 : 1);
                state = quic_s_payload;
            }
            break;
            case quic_stream_off:
            {
                res = (0x04 & frame_type) ? 1 : 0;
                state = quic_stream_len;
            }
            break;
            case quic_stream_len:
            {
                res = (0x02 & frame_type) ? 1 : 0;
                state = quic_stream_fin;
            }
            break;
            case quic_stream_fin:
            {
                res = (0x01 & frame_type) ? 1 : 0;
                state = quic_stream_id;
            }
            break;
            case quic_stream_id:
            {
                get_var_int(res);
                state = quic_stream_offset;
            }
            break;
            case quic_stream_offset:
            {
                if (0x04 & frame_type)
                    get_var_int(res);
                else res = 0;
                state = quic_stream_length;
            }
            break;
            case quic_stream_length:
            {
                if (0x02 & frame_type)
                    get_var_int(res);
                else res = 0;
                data_remaining = res;
                state = quic_stream_data;
            }
            break;
            case quic_stream_data:
            {
                ivy_binary_deser::getn(res,1);
            }
            break;
            case quic_ack_largest:
            {
                get_var_int(res);
                state = quic_ack_delay;
            }
            break;
            case quic_ack_delay:
            {
                get_var_int(res);
                state = quic_ack_block_count;
            }
            break;
            case quic_ack_gap:
            {
                if (ack_block_count == 0)
                    res = 0; // first ack block has no gap
                else
                    get_var_int(res);
                state = quic_ack_block;
            }
            break;
            case quic_ack_block:
            {
                get_var_int(res);
                state = quic_ack_gap;
                ack_block_count++;
            }
            break;
            default:
            throw deser_err();
            }
        }

        void get_var_int(long long &res) {
            static int lens[4] = {0,1,3,7};
            long long lobyte;
            ivy_binary_deser::getn(lobyte,1);
            int bytes = lens[(lobyte & 0xc0) >> 6];
            ivy_binary_deser::getn(res,bytes);
            res |= (lobyte & 0x3f) << (bytes << 3);
        }

        virtual int open_tag(const std::vector<std::string> &tags) {
            if (state == quic_s_payload) {
                long long ft;
                ivy_binary_deser::getn(ft,1);
                frame_type = ft;
                if (frame_type >= 0x10 && frame_type <= 0x17) {
                    state = quic_stream_off;
                    return 0;
                }
                if (frame_type == 0x0e) {
                    state = quic_ack_largest;
                    return 1;
                }
            }
            throw deser_err();
        }

        virtual bool open_list_elem() {
            if (state == quic_s_payload) {
               while (more(1) && inp[pos] == 0)
                   pos++;  // skip padding frames
               return more(1);
            }
            if (state == quic_ack_gap) {
                return ack_block_count < ack_blocks_expected;
            }
            if (state == quic_stream_data)
                return (0x02 & frame_type) ? (data_remaining-- > 0) : more(1);
            throw deser_err();
        }

        void open_list() {
            if (state == quic_ack_block_count) {
                get_var_int(ack_blocks_expected);
                ack_blocks_expected++;  // block count doesn't include first
                ack_block_count = 0;
                state = quic_ack_gap;
            }
        }
        void close_list() {}
        void close_list_elem() {}

        virtual void close_tag() {
            state = quic_s_payload;
        }

        ~quic_deser(){}
    };


            #include <stdint.h>

            // This struct holds the pcap global header

            typedef struct pcap_hdr_s {
                    uint32_t magic_number;   /* magic number */
                    uint16_t version_major;  /* major version number */
                    uint16_t version_minor;  /* minor version number */
                    int32_t  thiszone;       /* GMT to local correction */
                    uint32_t sigfigs;        /* accuracy of timestamps */
                    uint32_t snaplen;        /* max length of captured packets, in octets */
                    uint32_t network;        /* data link type */
            } pcap_hdr_t;

            // This struct holds the pcap packet header

            typedef struct pcaprec_hdr_s {
                    uint32_t ts_sec;         /* timestamp seconds */
                    uint32_t ts_usec;        /* timestamp microseconds */
                    uint32_t incl_len;       /* number of octets of packet saved in file */
                    uint32_t orig_len;       /* actual length of packet */
            } pcaprec_hdr_t;

            // This template is the reader object

            template <typename pkt, typename deser>
            class pcap_reader : public reader {

                int fd;                // The file descriptor
                pcap_hdr_t pcap_hdr;   // The global header
                thunk__pc__handle cb;          // The packet handler callback

            public:

                // In the constructor, we open the file and 
                // read the global header.

                pcap_reader(const std::string &name, thunk__pc__handle cb) : cb(cb) {
                    fd = ::open(name.c_str(),O_RDONLY,0666);
                    if (fd < 0) {
                        perror("cannot open pcap file to read");
                    }
                    if (::read(fd,&pcap_hdr,sizeof(pcap_hdr)) < sizeof(pcap_hdr)) {
                        perror("cannot read header of pcap file");
                    }
                }
            
                int fdes() { return fd; }

                void read() {
                    pcaprec_hdr_t rh;
                    int bytes = ::read(fd,&rh,sizeof(rh));
                    if (bytes == 0) {
                        fd = -1;   // indicate we are done if end-of-file
                        return;
                    }
                    if (bytes < sizeof(rh)) {
                        perror("cannot read record header from pcap file");
                    }

                    // Get the packet size from header. If truncated, exit.

                    unsigned size = rh.incl_len; // packet bytes actually stored
                    if (size < rh.orig_len) {
                        perror("packet was truncated in pcap file");
                    }

                    // Read the packet into a vector.

                    std::vector<char> buf;
                    buf.resize(size);
                    if (::read(fd,&buf[0],size) < size) {
                        perror("cannot read record body from pcap file");
                    }

                    // We handle only UDP packets for now. This is protocol 17.

                    if (!(size >= 24 && buf[23] == 17))
                        return;

                    // Get the source and destination addresses from the IP header and UDP headers

                    quic_monitor::ip__endpoint src;
                    src.protocol = quic_monitor::ip__udp;
                    src.addr = ntohl(*(uint32_t *)(&buf[26]));
                    src.port = ntohs(*(uint16_t *)(&buf[34]));

                    quic_monitor::ip__endpoint dst;
                    dst.protocol = quic_monitor::ip__udp;
                    dst.addr = ntohl(*(uint32_t *)(&buf[30]));
                    dst.port = ntohs(*(uint16_t *)(&buf[36]));

                    // Create a deserializer and deserialize the packet.

                    deser ds(buf);
                    pkt packet;
                
                    try {
                       __deser(ds,packet);
                    }

                    // If deserialization failure, print out the packet for
                    // debugging purposes.

                    catch(deser_err &err) {
                        std::cerr << "error: failed to deserialize packet in pcap file." << std::endl;
                        std::cerr << "hex dump of packet follows." << std::endl;
                        for (unsigned i = 0; i < buf.size(); i++) {
                            if (i > 0 && i % 16 == 0) 
                                std::cerr << std::endl;
                            if (i == ds.pos)
                                fprintf(stderr,"*");
                            fprintf(stderr,"%02X",((unsigned)buf[i]) & 0xff);
                        }
                    }

                    // Finally, if we got a good packet, hit the callback.

                    cb(src,dst,packet);
                }
            };

        int quic_monitor::___ivy_choose(int rng,const char *name,int id) {
        return 0;
    }
int quic_monitor::stream_data__value(const stream_data& a, int i){
    int val;
    val = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
int quic_monitor::stream_data__end(const stream_data& a){
    int val;
    val = (int)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
quic_monitor::frame__ack__block quic_monitor::frame__ack__block__arr__value(const frame__ack__block__arr& a, int i){
    frame__ack__block val;
    val.gap = (long long)___ivy_choose(0,"ret:val",0);
    val.blocks = (long long)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
int quic_monitor::frame__ack__block__arr__end(const frame__ack__block__arr& a){
    int val;
    val = (int)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
quic_monitor::frame quic_monitor::frame__arr__value(const frame__arr& a, int i){
    quic_monitor::frame val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
int quic_monitor::frame__arr__end(const frame__arr& a){
    int val;
    val = (int)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
int quic_monitor::tls__cipher_suite_seq__value(const tls__cipher_suite_seq& a, int i){
    int val;
    val = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
int quic_monitor::tls__cipher_suite_seq__end(const tls__cipher_suite_seq& a){
    int val;
    val = (int)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
quic_monitor::tls__extension quic_monitor::vector__tls__extension____value(const vector__tls__extension__& a, int i){
    tls__extension val;
    val.etype = (int)___ivy_choose(0,"ret:val",0);
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
int quic_monitor::vector__tls__extension____end(const vector__tls__extension__& a){
    int val;
    val = (int)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
quic_monitor::tls__handshake quic_monitor::vector__tls__handshake____value(const vector__tls__handshake__& a, int i){
    quic_monitor::tls__handshake val;
    val =  (0 <= i && i < a.size()) ? a[i] : val ;
    return val;
}
int quic_monitor::vector__tls__handshake____end(const vector__tls__handshake__& a){
    int val;
    val = (int)___ivy_choose(0,"ret:val",0);
    val =  a.size() ;
    return val;
}
void quic_monitor::imp__show_packet(const ip__endpoint& src, const ip__endpoint& dst, const quic_packet& pkt){
    {
    }
}
            struct __thunk__0 : thunk<quic_monitor::__tup__ip__endpoint__long_long,bool>{
                __thunk__0()  {
                }
                bool operator()(const quic_monitor::__tup__ip__endpoint__long_long &arg){
                    return false;
                }
            };
            struct __thunk__1 : thunk<quic_monitor::__tup__ip__endpoint__long_long__long_long,bool>{
                __thunk__1()  {
                }
                bool operator()(const quic_monitor::__tup__ip__endpoint__long_long__long_long &arg){
                    return false;
                }
            };
            struct __thunk__2 : thunk<quic_monitor::__tup__ip__endpoint__long_long__long_long,bool>{
                __thunk__2()  {
                }
                bool operator()(const quic_monitor::__tup__ip__endpoint__long_long__long_long &arg){
                    return false;
                }
            };
            struct __thunk__3 : thunk<quic_monitor::__tup__ip__endpoint__long_long,long long>{
                __thunk__3()  {
                }
                long long operator()(const quic_monitor::__tup__ip__endpoint__long_long &arg){
                    return (0 & 4611686018427387903);
                }
            };
            struct __thunk__4 : thunk<quic_monitor::__tup__ip__endpoint__long_long,long long>{
                __thunk__4()  {
                }
                long long operator()(const quic_monitor::__tup__ip__endpoint__long_long &arg){
                    return (0 & 4611686018427387903);
                }
            };
void quic_monitor::__init(){
    {
        {
            conn_seen = hash_thunk<quic_monitor::__tup__ip__endpoint__long_long,bool>(new __thunk__0());
            sent_pkt = hash_thunk<quic_monitor::__tup__ip__endpoint__long_long__long_long,bool>(new __thunk__1());
            acked_pkt = hash_thunk<quic_monitor::__tup__ip__endpoint__long_long__long_long,bool>(new __thunk__2());
            max_acked = hash_thunk<quic_monitor::__tup__ip__endpoint__long_long,long long>(new __thunk__3());
            ack_credit = hash_thunk<quic_monitor::__tup__ip__endpoint__long_long,long long>(new __thunk__4());
        }
    }
}
quic_monitor::tls__record quic_monitor::ext__tls__parser__deserialize(const stream_data& x){
    quic_monitor::tls__record y;
    {

        deser ds(x);

        try {
           __deser(ds,y);
        }

        // If deserialization failure, print out the packet for
        // debugging purposes.

        catch(deser_err &err) {
            std::cerr << "error: failed to deserialize data" << std::endl;
            std::cerr << "hex dump of data follows." << std::endl;
            for (unsigned i = 0; i < buf.size(); i++) {
                if (i > 0 && i % 16 == 0)
                    std::cerr << std::endl;
                if (i == ds.pos)
                    fprintf(stderr,"*");
                fprintf(stderr,"%02X",((unsigned)buf[i]) & 0xff);
            }
        }
    }
    return y;
}
int quic_monitor::ext__frame__ack__block__idx__next(int x){
    int y;
    y = (int)___ivy_choose(0,"fml:y",0);
    {
        y = (x + 1);
    }
    return y;
}
void quic_monitor::ext__show_packet(const ip__endpoint& src, const ip__endpoint& dst, const quic_packet& pkt){
    imp__show_packet(src, dst, pkt);
}
                                            struct __thunk__5 : thunk<quic_monitor::__tup__ip__endpoint__long_long__long_long,bool>{
    quic_monitor::ip__endpoint dst;
    long long loc__upper;
    long long loc__last;
    hash_thunk<quic_monitor::__tup__ip__endpoint__long_long__long_long,bool> acked_pkt;
    long long pcid;
                                                __thunk__5(quic_monitor::ip__endpoint dst,long long loc__upper,long long loc__last,hash_thunk<quic_monitor::__tup__ip__endpoint__long_long__long_long,bool> acked_pkt,long long pcid) : dst(dst),loc__upper(loc__upper),loc__last(loc__last),acked_pkt(acked_pkt),pcid(pcid){
                                                }
                                                bool operator()(const quic_monitor::__tup__ip__endpoint__long_long__long_long &arg){
                                                    return (((dst == arg.arg0) && (pcid == arg.arg1)) ? ((((loc__last < arg.arg2) || (loc__last == arg.arg2)) && ((arg.arg2 < loc__upper) || (arg.arg2 == loc__upper))) || acked_pkt[quic_monitor::__tup__ip__endpoint__long_long__long_long(dst,pcid,arg.arg2)]) : acked_pkt[quic_monitor::__tup__ip__endpoint__long_long__long_long(arg.arg0,arg.arg1,arg.arg2)]);
                                                }
                                            };
void quic_monitor::ext__frame__ack__handle(const frame__ack& f, const ip__endpoint& src, const ip__endpoint& dst, long long pcid){
    {
        int loc__idx;
    loc__idx = (int)___ivy_choose(0,"loc:idx",206);
        {
            loc__idx = 0;
            {
                long long loc__last;
    loc__last = (long long)___ivy_choose(0,"loc:last",205);
                {
                    loc__last = f.largest_acked;
                    if((max_acked[quic_monitor::__tup__ip__endpoint__long_long(dst,pcid)] < loc__last)){
                        {
                            max_acked[quic_monitor::__tup__ip__endpoint__long_long(dst,pcid)] = loc__last;
                        }
                    }
                    while((loc__idx < frame__ack__block__arr__end(f.ack_blocks))){
                        {
                            {
                                frame__ack__block loc__ack_block;
    loc__ack_block.gap = (long long)___ivy_choose(0,"loc:ack_block",204);
    loc__ack_block.blocks = (long long)___ivy_choose(0,"loc:ack_block",204);
                                {
                                    loc__ack_block = frame__ack__block__arr__value(f.ack_blocks,loc__idx);
                                    {
                                        long long loc__upper;
    loc__upper = (long long)___ivy_choose(0,"loc:upper",203);
                                        {
                                            loc__upper = ((loc__last - loc__ack_block.gap) & 4611686018427387903);
                                            loc__last = ((loc__upper - loc__ack_block.blocks) & 4611686018427387903);
                                            int __tmp0;
                                            __tmp0 = 1;
                                            for (long long N = loc__last; N < (loc__upper)+1; N++) {
                                                if (!(!(((loc__last < N) || (loc__last == N)) && ((N < loc__upper) || (N == loc__upper))) || sent_pkt[quic_monitor::__tup__ip__endpoint__long_long__long_long(dst,pcid,N)])) __tmp0 = 0;
                                            }
                                            ivy_assume(__tmp0, "quic_connection.ivy: line 268");
                                            acked_pkt = hash_thunk<quic_monitor::__tup__ip__endpoint__long_long__long_long,bool>(new __thunk__5(dst,loc__upper,loc__last,acked_pkt,pcid));
                                            loc__idx = ext__frame__ack__block__idx__next(loc__idx);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
void quic_monitor::imp__tls__event(const ip__endpoint& src, const ip__endpoint& dst, quic_monitor::tls__record rec){
    {
    }
}
void quic_monitor::ext__packet_event(const ip__endpoint& src, const ip__endpoint& dst, const quic_packet& pkt){
    {
        {
            long long loc__pcid;
    loc__pcid = (long long)___ivy_choose(0,"loc:pcid",212);
            {
                loc__pcid = pkt.hdr_cid;
                {
                    long long loc__0;
    loc__0 = (long long)___ivy_choose(0,"loc:0",211);
                    {
                        loc__0 = ext__decode_packet_number(src, dst, pkt);
                        {
                            long long loc__pnum;
    loc__pnum = (long long)___ivy_choose(0,"loc:pnum",210);
                            {
                                loc__pnum = loc__0;
                                ivy_assume(!sent_pkt[quic_monitor::__tup__ip__endpoint__long_long__long_long(src,loc__pcid,loc__pnum)], "quic_connection.ivy: line 156");
                                conn_seen[quic_monitor::__tup__ip__endpoint__long_long(src,loc__pcid)] = true;
                                sent_pkt[quic_monitor::__tup__ip__endpoint__long_long__long_long(src,loc__pcid,loc__pnum)] = true;
                                last_pkt_num[quic_monitor::__tup__ip__endpoint__long_long(src,loc__pcid)] = loc__pnum;
                                {
                                    bool loc__ack_only;
    loc__ack_only = (bool)___ivy_choose(0,"loc:ack_only",209);
                                    {
                                        int __tmp1;
                                        __tmp1 = 1;
                                        for (int I = 0; I < frame__arr__end(pkt.payload); I++) {
                                            if (!(!(((0 < I) || (0 == I)) && (I < frame__arr__end(pkt.payload))) || (frame__arr__value(pkt.payload,I)).tag == 1)) __tmp1 = 0;
                                        }
                                        loc__ack_only = __tmp1;
                                        if(loc__ack_only){
                                            {
                                                ivy_assume(((0 & 4611686018427387903) < ack_credit[quic_monitor::__tup__ip__endpoint__long_long(src,loc__pcid)]), "quic_connection.ivy: line 173");
                                                ack_credit[quic_monitor::__tup__ip__endpoint__long_long(src,loc__pcid)] = ((ack_credit[quic_monitor::__tup__ip__endpoint__long_long(src,loc__pcid)] - (1 & 4611686018427387903)) & 4611686018427387903);
                                            }
                                        }
                                        else {
                                            {
                                                ack_credit[quic_monitor::__tup__ip__endpoint__long_long(dst,loc__pcid)] = ((ack_credit[quic_monitor::__tup__ip__endpoint__long_long(dst,loc__pcid)] + (1 & 4611686018427387903)) & 4611686018427387903);
                                            }
                                        }
                                        if((pkt.hdr_type == (0x7f & 127))){
                                            {
                                                ivy_assume((frame__arr__end(pkt.payload) == 1), "quic_connection.ivy: line 182");
                                                ivy_assume((frame__arr__value(pkt.payload,0)).tag == 0, "quic_connection.ivy: line 183");
                                                ivy_assume(!initializing[quic_monitor::__tup__ip__endpoint__ip__endpoint(src,dst)], "quic_connection.ivy: line 184");
                                                initializing[quic_monitor::__tup__ip__endpoint__ip__endpoint(src,dst)] = true;
                                                initial_pkt_num[quic_monitor::__tup__ip__endpoint__ip__endpoint(src,dst)] = loc__pnum;
                                            }
                                        }
                                        else {
                                            if((pkt.hdr_type == (0x7d & 127))){
                                                if(initializing[quic_monitor::__tup__ip__endpoint__ip__endpoint(dst,src)]){
                                                    {
                                                        initializing[quic_monitor::__tup__ip__endpoint__ip__endpoint(dst,src)] = false;
                                                        {
                                                            long long loc__ipnum;
    loc__ipnum = (long long)___ivy_choose(0,"loc:ipnum",207);
                                                            {
                                                                loc__ipnum = initial_pkt_num[quic_monitor::__tup__ip__endpoint__ip__endpoint(dst,src)];
                                                                sent_pkt[quic_monitor::__tup__ip__endpoint__long_long__long_long(dst,loc__pcid,loc__ipnum)] = true;
                                                                last_pkt_num[quic_monitor::__tup__ip__endpoint__long_long(dst,loc__pcid)] = loc__ipnum;
                                                                ack_credit[quic_monitor::__tup__ip__endpoint__long_long(src,loc__pcid)] = (1 & 4611686018427387903);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        {
                                            int loc__idx;
    loc__idx = (int)___ivy_choose(0,"loc:idx",208);
                                            {
                                                loc__idx = 0;
                                                while((loc__idx < frame__arr__end(pkt.payload))){
                                                    {
                                                        {
                                                            frame__ack frame__ack;
                                                            if ((frame__arr__value(pkt.payload,loc__idx)).tag == 1) frame__ack = (static_cast<const quic_monitor::frame::twrap<quic_monitor::frame__ack> *>((frame__arr__value(pkt.payload,loc__idx)).ptr)->item);
                                                            if((frame__arr__value(pkt.payload,loc__idx)).tag == 1){
                                                                ext__frame__ack__handle(frame__ack, src, dst, loc__pcid);
                                                            }
                                                            else {
                                                                {
                                                                    frame__stream frame__stream;
                                                                    if ((frame__arr__value(pkt.payload,loc__idx)).tag == 0) frame__stream = (static_cast<const quic_monitor::frame::twrap<quic_monitor::frame__stream> *>((frame__arr__value(pkt.payload,loc__idx)).ptr)->item);
                                                                    if((frame__arr__value(pkt.payload,loc__idx)).tag == 0){
                                                                        ext__frame__stream__handle(frame__stream, src, dst, loc__pcid);
                                                                    }
                                                                    else {
                                                                        ext__frame__handle(frame__arr__value(pkt.payload,loc__idx), src, dst, loc__pcid);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        loc__idx = (loc__idx + 1);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
void quic_monitor::pc__handle(const ip__endpoint& src, const ip__endpoint& dst, const quic_packet& p){
    {
        ext__show_packet(src, dst, p);
        ext__packet_event(src, dst, p);
    }
}
void quic_monitor::ext__frame__stream__handle(const frame__stream& f, const ip__endpoint& src, const ip__endpoint& dst, long long pcid){
    if((f.id == 0)){
        {
            {
                quic_monitor::tls__record loc__0;
                {
                    loc__0 = ext__tls__parser__deserialize(f.data);
                    {
                        quic_monitor::tls__record loc__tr;
                        {
                            loc__tr = loc__0;
                            ext__tls__event(src, dst, loc__tr);
                        }
                    }
                }
            }
        }
    }
}
void quic_monitor::ext__frame__handle(quic_monitor::frame f, const ip__endpoint& src, const ip__endpoint& dst, long long pcid){
    {
    }
}
long long quic_monitor::ext__decode_packet_number(const ip__endpoint& src, const ip__endpoint& dst, const quic_packet& pkt){
    long long pnum;
    pnum = (long long)___ivy_choose(0,"fml:pnum",0);
    {
        long long loc__cid;
    loc__cid = (long long)___ivy_choose(0,"loc:cid",217);
        {
            loc__cid = pkt.hdr_cid;
            {
                long long loc__la;
    loc__la = (long long)___ivy_choose(0,"loc:la",216);
                {
                    loc__la = max_acked[quic_monitor::__tup__ip__endpoint__long_long(src,loc__cid)];
                    pnum = pkt.hdr_pkt_num;
                    if(conn_seen[quic_monitor::__tup__ip__endpoint__long_long(src,loc__cid)]){
                        {
                            long long loc__last;
    loc__last = (long long)___ivy_choose(0,"loc:last",215);
                            {
                                loc__last = last_pkt_num[quic_monitor::__tup__ip__endpoint__long_long(src,loc__cid)];
                                if((pkt.hdr_long || (pkt.hdr_type == (0x1d & 127)))){
                                    {
                                        ivy_assume(((pnum < ((loc__la + (0x7ffffffe & 4611686018427387903)) & 4611686018427387903)) || (pnum == ((loc__la + (0x7ffffffe & 4611686018427387903)) & 4611686018427387903))), "quic_connection.ivy: line 354");
                                        {
                                            long long loc__n;
                                            int __tmp2;
                                            __tmp2 = 0;
                                            int __tmp3;
                                            for (long long X__0 = (loc__last)+1; X__0 < 4611686018427387904; X__0++) {
                                                if(((loc__last < X__0) && (((X__0 >> 0) & 4294967295) == pnum))){
                                                    int __tmp4;
                                                    __tmp4 = X__0;
                                                    if(__tmp2){
                                                        if(!(__tmp4 < __tmp3)){
                                                            continue;
                                                        }
                                                    }
                                                    __tmp3 = __tmp4;
                                                    loc__n = X__0;
                                                    __tmp2= 1;
                                                    break;
                                                }
                                            }
                                            if(__tmp2){
                                                pnum = loc__n;
                                            }
                                        }
                                    }
                                }
                                else {
                                    if((pkt.hdr_type == (0x1e & 127))){
                                        {
                                            ivy_assume(((pnum < ((loc__la + (0x7ffe & 4611686018427387903)) & 4611686018427387903)) || (pnum == ((loc__la + (0x7ffe & 4611686018427387903)) & 4611686018427387903))), "quic_connection.ivy: line 363");
                                            {
                                                long long loc__n;
                                                int __tmp5;
                                                __tmp5 = 0;
                                                int __tmp6;
                                                for (long long X__0 = (loc__last)+1; X__0 < 4611686018427387904; X__0++) {
                                                    if(((loc__last < X__0) && (((X__0 >> 0) & 65535) == pnum))){
                                                        int __tmp7;
                                                        __tmp7 = X__0;
                                                        if(__tmp5){
                                                            if(!(__tmp7 < __tmp6)){
                                                                continue;
                                                            }
                                                        }
                                                        __tmp6 = __tmp7;
                                                        loc__n = X__0;
                                                        __tmp5= 1;
                                                        break;
                                                    }
                                                }
                                                if(__tmp5){
                                                    pnum = loc__n;
                                                }
                                            }
                                        }
                                    }
                                    else {
                                        {
                                            ivy_assume(((pnum < ((loc__la + (0x7e & 4611686018427387903)) & 4611686018427387903)) || (pnum == ((loc__la + (0x7e & 4611686018427387903)) & 4611686018427387903))), "quic_connection.ivy: line 372");
                                            {
                                                long long loc__n;
                                                int __tmp8;
                                                __tmp8 = 0;
                                                int __tmp9;
                                                for (long long X__0 = (loc__last)+1; X__0 < 4611686018427387904; X__0++) {
                                                    if(((loc__last < X__0) && (((X__0 >> 0) & 255) == pnum))){
                                                        int __tmp10;
                                                        __tmp10 = X__0;
                                                        if(__tmp8){
                                                            if(!(__tmp10 < __tmp9)){
                                                                continue;
                                                            }
                                                        }
                                                        __tmp9 = __tmp10;
                                                        loc__n = X__0;
                                                        __tmp8= 1;
                                                        break;
                                                    }
                                                }
                                                if(__tmp8){
                                                    pnum = loc__n;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return pnum;
}
void quic_monitor::ext__tls__event(const ip__endpoint& src, const ip__endpoint& dst, quic_monitor::tls__record rec){
    imp__tls__event(src, dst, rec);
}
void quic_monitor::__tick(int __timeout){
}
quic_monitor::quic_monitor(__strlit pc__name){
#ifdef _WIN32
mutex = CreateMutex(NULL,FALSE,NULL);
#else
pthread_mutex_init(&mutex,NULL);
#endif
__lock();
    __CARD__stream_pos = 0;
    __CARD__tls__gmt = 4294967296;
    __CARD__frame__ack__block__idx = 0;
    __CARD__vector__tls__extension____domain = 0;
    __CARD__tls__protocol_version = 65536;
    __CARD__vector__tls__handshake____domain = 0;
    __CARD__ip__addr = 4294967296;
    __CARD__byte = 256;
    __CARD__ip__port = 65536;
    __CARD__tls__cipher_suite = 65536;
    __CARD__pkt_num = 4611686018427387904;
    __CARD__cid = 4611686018427387904;
    __CARD__tls__extension_type = 65536;
    __CARD__version = 4294967296;
    __CARD__type_bits = 128;
    __CARD__tls__cipher_suite_idx = 0;
    __CARD__pc__pathname = 0;
    __CARD__frame__idx = 0;
    
    tls_make_name_map(tls_field_length_bytes,tls_field_length_bytes_map)
    tls_make_name_map(tls_field_bytes,tls_field_bytes_map)
    tls_make_name_map(tls_tags,tls_tags_map)
  
    install_reader(new pcap_reader<quic_packet,quic_deser>(pc__name,thunk__pc__handle(this)));
struct __thunk__6 : thunk<quic_monitor::__tup__ip__endpoint__long_long__long_long,bool>{
    __thunk__6()  {
    }
    bool operator()(const quic_monitor::__tup__ip__endpoint__long_long__long_long &arg){
        bool __tmp11;
    __tmp11 = (bool)___ivy_choose(0,"init",0);
        return __tmp11;
    }
};
acked_pkt = hash_thunk<quic_monitor::__tup__ip__endpoint__long_long__long_long,bool>(new __thunk__6());
struct __thunk__7 : thunk<quic_monitor::__tup__ip__endpoint__long_long,long long>{
    __thunk__7()  {
    }
    long long operator()(const quic_monitor::__tup__ip__endpoint__long_long &arg){
        long long __tmp12;
    __tmp12 = (long long)___ivy_choose(0,"init",0);
        return __tmp12;
    }
};
last_pkt_num = hash_thunk<quic_monitor::__tup__ip__endpoint__long_long,long long>(new __thunk__7());
struct __thunk__8 : thunk<quic_monitor::__tup__ip__endpoint__long_long,long long>{
    __thunk__8()  {
    }
    long long operator()(const quic_monitor::__tup__ip__endpoint__long_long &arg){
        long long __tmp13;
    __tmp13 = (long long)___ivy_choose(0,"init",0);
        return __tmp13;
    }
};
max_acked = hash_thunk<quic_monitor::__tup__ip__endpoint__long_long,long long>(new __thunk__8());
struct __thunk__9 : thunk<quic_monitor::__tup__ip__endpoint__ip__endpoint,bool>{
    __thunk__9()  {
    }
    bool operator()(const quic_monitor::__tup__ip__endpoint__ip__endpoint &arg){
        bool __tmp14;
    __tmp14 = (bool)___ivy_choose(0,"init",0);
        return __tmp14;
    }
};
initializing = hash_thunk<quic_monitor::__tup__ip__endpoint__ip__endpoint,bool>(new __thunk__9());
struct __thunk__10 : thunk<quic_monitor::__tup__ip__endpoint__long_long,long long>{
    __thunk__10()  {
    }
    long long operator()(const quic_monitor::__tup__ip__endpoint__long_long &arg){
        long long __tmp15;
    __tmp15 = (long long)___ivy_choose(0,"init",0);
        return __tmp15;
    }
};
ack_credit = hash_thunk<quic_monitor::__tup__ip__endpoint__long_long,long long>(new __thunk__10());
    this->pc__name = pc__name;
struct __thunk__11 : thunk<quic_monitor::__tup__ip__endpoint__long_long,bool>{
    __thunk__11()  {
    }
    bool operator()(const quic_monitor::__tup__ip__endpoint__long_long &arg){
        bool __tmp16;
    __tmp16 = (bool)___ivy_choose(0,"init",0);
        return __tmp16;
    }
};
conn_seen = hash_thunk<quic_monitor::__tup__ip__endpoint__long_long,bool>(new __thunk__11());
struct __thunk__12 : thunk<quic_monitor::__tup__ip__endpoint__long_long__long_long,bool>{
    __thunk__12()  {
    }
    bool operator()(const quic_monitor::__tup__ip__endpoint__long_long__long_long &arg){
        bool __tmp17;
    __tmp17 = (bool)___ivy_choose(0,"init",0);
        return __tmp17;
    }
};
sent_pkt = hash_thunk<quic_monitor::__tup__ip__endpoint__long_long__long_long,bool>(new __thunk__12());
struct __thunk__13 : thunk<quic_monitor::__tup__ip__endpoint__ip__endpoint,long long>{
    __thunk__13()  {
    }
    long long operator()(const quic_monitor::__tup__ip__endpoint__ip__endpoint &arg){
        long long __tmp18;
    __tmp18 = (long long)___ivy_choose(0,"init",0);
        return __tmp18;
    }
};
initial_pkt_num = hash_thunk<quic_monitor::__tup__ip__endpoint__ip__endpoint,long long>(new __thunk__13());
{
    {
        struct __thunk__14 : thunk<quic_monitor::__tup__ip__endpoint__long_long,bool>{
            __thunk__14()  {
            }
            bool operator()(const quic_monitor::__tup__ip__endpoint__long_long &arg){
                return false;
            }
        };
        conn_seen = hash_thunk<quic_monitor::__tup__ip__endpoint__long_long,bool>(new __thunk__14());
        struct __thunk__15 : thunk<quic_monitor::__tup__ip__endpoint__long_long__long_long,bool>{
            __thunk__15()  {
            }
            bool operator()(const quic_monitor::__tup__ip__endpoint__long_long__long_long &arg){
                return false;
            }
        };
        sent_pkt = hash_thunk<quic_monitor::__tup__ip__endpoint__long_long__long_long,bool>(new __thunk__15());
        struct __thunk__16 : thunk<quic_monitor::__tup__ip__endpoint__long_long__long_long,bool>{
            __thunk__16()  {
            }
            bool operator()(const quic_monitor::__tup__ip__endpoint__long_long__long_long &arg){
                return false;
            }
        };
        acked_pkt = hash_thunk<quic_monitor::__tup__ip__endpoint__long_long__long_long,bool>(new __thunk__16());
        struct __thunk__17 : thunk<quic_monitor::__tup__ip__endpoint__long_long,long long>{
            __thunk__17()  {
            }
            long long operator()(const quic_monitor::__tup__ip__endpoint__long_long &arg){
                return (0 & 4611686018427387903);
            }
        };
        max_acked = hash_thunk<quic_monitor::__tup__ip__endpoint__long_long,long long>(new __thunk__17());
        struct __thunk__18 : thunk<quic_monitor::__tup__ip__endpoint__long_long,long long>{
            __thunk__18()  {
            }
            long long operator()(const quic_monitor::__tup__ip__endpoint__long_long &arg){
                return (0 & 4611686018427387903);
            }
        };
        ack_credit = hash_thunk<quic_monitor::__tup__ip__endpoint__long_long,long long>(new __thunk__18());
    }
}
}
quic_monitor::~quic_monitor(){
    __lock(); // otherwise, thread may die holding lock!
    for (unsigned i = 0; i < thread_ids.size(); i++){
        pthread_cancel(thread_ids[i]);
        pthread_join(thread_ids[i],NULL);
    }
    __unlock();
}
std::ostream &operator <<(std::ostream &s, const quic_monitor::ip__endpoint &t){
    s<<"{";
    s<< "protocol:";
    s << t.protocol;
    s<<",";
    s<< "addr:";
    s << t.addr;
    s<<",";
    s<< "port:";
    s << t.port;
    s<<"}";
    return s;
}
template <>
void  __ser<quic_monitor::ip__endpoint>(ivy_ser &res, const quic_monitor::ip__endpoint&t){
    res.open_struct();
    res.open_field("protocol");
    __ser<quic_monitor::ip__protocol>(res,t.protocol);
    res.close_field();
    res.open_field("addr");
    __ser<int>(res,t.addr);
    res.close_field();
    res.open_field("port");
    __ser<int>(res,t.port);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const quic_monitor::frame__stream &t){
    s<<"{";
    s<< "off:";
    s << t.off;
    s<<",";
    s<< "len:";
    s << t.len;
    s<<",";
    s<< "fin:";
    s << t.fin;
    s<<",";
    s<< "id:";
    s << t.id;
    s<<",";
    s<< "offset:";
    s << t.offset;
    s<<",";
    s<< "length:";
    s << t.length;
    s<<",";
    s<< "data:";
    s << t.data;
    s<<"}";
    return s;
}
template <>
void  __ser<quic_monitor::frame__stream>(ivy_ser &res, const quic_monitor::frame__stream&t){
    res.open_struct();
    res.open_field("off");
    __ser<bool>(res,t.off);
    res.close_field();
    res.open_field("len");
    __ser<bool>(res,t.len);
    res.close_field();
    res.open_field("fin");
    __ser<bool>(res,t.fin);
    res.close_field();
    res.open_field("id");
    __ser<int>(res,t.id);
    res.close_field();
    res.open_field("offset");
    __ser<int>(res,t.offset);
    res.close_field();
    res.open_field("length");
    __ser<int>(res,t.length);
    res.close_field();
    res.open_field("data");
    __ser<quic_monitor::stream_data>(res,t.data);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const quic_monitor::frame__ack__block &t){
    s<<"{";
    s<< "gap:";
    s << t.gap;
    s<<",";
    s<< "blocks:";
    s << t.blocks;
    s<<"}";
    return s;
}
template <>
void  __ser<quic_monitor::frame__ack__block>(ivy_ser &res, const quic_monitor::frame__ack__block&t){
    res.open_struct();
    res.open_field("gap");
    __ser<long long>(res,t.gap);
    res.close_field();
    res.open_field("blocks");
    __ser<long long>(res,t.blocks);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const quic_monitor::frame__ack &t){
    s<<"{";
    s<< "largest_acked:";
    s << t.largest_acked;
    s<<",";
    s<< "ack_delay:";
    s << t.ack_delay;
    s<<",";
    s<< "ack_blocks:";
    s << t.ack_blocks;
    s<<"}";
    return s;
}
template <>
void  __ser<quic_monitor::frame__ack>(ivy_ser &res, const quic_monitor::frame__ack&t){
    res.open_struct();
    res.open_field("largest_acked");
    __ser<long long>(res,t.largest_acked);
    res.close_field();
    res.open_field("ack_delay");
    __ser<int>(res,t.ack_delay);
    res.close_field();
    res.open_field("ack_blocks");
    __ser<quic_monitor::frame__ack__block__arr>(res,t.ack_blocks);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const quic_monitor::quic_packet &t){
    s<<"{";
    s<< "hdr_long:";
    s << t.hdr_long;
    s<<",";
    s<< "hdr_type:";
    s << t.hdr_type;
    s<<",";
    s<< "hdr_cid:";
    s << t.hdr_cid;
    s<<",";
    s<< "hdr_version:";
    s << t.hdr_version;
    s<<",";
    s<< "hdr_pkt_num:";
    s << t.hdr_pkt_num;
    s<<",";
    s<< "payload:";
    s << t.payload;
    s<<"}";
    return s;
}
template <>
void  __ser<quic_monitor::quic_packet>(ivy_ser &res, const quic_monitor::quic_packet&t){
    res.open_struct();
    res.open_field("hdr_long");
    __ser<bool>(res,t.hdr_long);
    res.close_field();
    res.open_field("hdr_type");
    __ser<int>(res,t.hdr_type);
    res.close_field();
    res.open_field("hdr_cid");
    __ser<long long>(res,t.hdr_cid);
    res.close_field();
    res.open_field("hdr_version");
    __ser<int>(res,t.hdr_version);
    res.close_field();
    res.open_field("hdr_pkt_num");
    __ser<long long>(res,t.hdr_pkt_num);
    res.close_field();
    res.open_field("payload");
    __ser<quic_monitor::frame__arr>(res,t.payload);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const quic_monitor::tls__extension &t){
    s<<"{";
    s<< "etype:";
    s << t.etype;
    s<<",";
    s<< "content:";
    s << t.content;
    s<<"}";
    return s;
}
template <>
void  __ser<quic_monitor::tls__extension>(ivy_ser &res, const quic_monitor::tls__extension&t){
    res.open_struct();
    res.open_field("etype");
    __ser<int>(res,t.etype);
    res.close_field();
    res.open_field("content");
    __ser<quic_monitor::stream_data>(res,t.content);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const quic_monitor::tls__random &t){
    s<<"{";
    s<< "gmt_unix_time:";
    s << t.gmt_unix_time;
    s<<",";
    s<< "random_bytes:";
    s << t.random_bytes;
    s<<"}";
    return s;
}
template <>
void  __ser<quic_monitor::tls__random>(ivy_ser &res, const quic_monitor::tls__random&t){
    res.open_struct();
    res.open_field("gmt_unix_time");
    __ser<int>(res,t.gmt_unix_time);
    res.close_field();
    res.open_field("random_bytes");
    __ser<quic_monitor::stream_data>(res,t.random_bytes);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const quic_monitor::tls__client_hello &t){
    s<<"{";
    s<< "client_version:";
    s << t.client_version;
    s<<",";
    s<< "rand_info:";
    s << t.rand_info;
    s<<",";
    s<< "session_id:";
    s << t.session_id;
    s<<",";
    s<< "cipher_suites:";
    s << t.cipher_suites;
    s<<",";
    s<< "extensions:";
    s << t.extensions;
    s<<"}";
    return s;
}
template <>
void  __ser<quic_monitor::tls__client_hello>(ivy_ser &res, const quic_monitor::tls__client_hello&t){
    res.open_struct();
    res.open_field("client_version");
    __ser<int>(res,t.client_version);
    res.close_field();
    res.open_field("rand_info");
    __ser<quic_monitor::tls__random>(res,t.rand_info);
    res.close_field();
    res.open_field("session_id");
    __ser<quic_monitor::stream_data>(res,t.session_id);
    res.close_field();
    res.open_field("cipher_suites");
    __ser<quic_monitor::tls__cipher_suite_seq>(res,t.cipher_suites);
    res.close_field();
    res.open_field("extensions");
    __ser<quic_monitor::vector__tls__extension__>(res,t.extensions);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const quic_monitor::tls__handshake_record &t){
    s<<"{";
    s<< "version:";
    s << t.version;
    s<<",";
    s<< "fragment:";
    s << t.fragment;
    s<<"}";
    return s;
}
template <>
void  __ser<quic_monitor::tls__handshake_record>(ivy_ser &res, const quic_monitor::tls__handshake_record&t){
    res.open_struct();
    res.open_field("version");
    __ser<int>(res,t.version);
    res.close_field();
    res.open_field("fragment");
    __ser<quic_monitor::vector__tls__handshake__>(res,t.fragment);
    res.close_field();
    res.close_struct();
}
std::ostream &operator <<(std::ostream &s, const quic_monitor::ip__protocol &t){
    if (t == quic_monitor::ip__udp) s<<"udp";
    if (t == quic_monitor::ip__tcp) s<<"tcp";
    return s;
}
template <>
void  __ser<quic_monitor::ip__protocol>(ivy_ser &res, const quic_monitor::ip__protocol&t){
    __ser(res,(int)t);
}


int ask_ret(long long bound) {
    int res;
    while(true) {
        __ivy_out << "? ";
        std::cin >> res;
        if (res >= 0 && res < bound) 
            return res;
        std::cerr << "value out of range" << std::endl;
    }
}



    class quic_monitor_repl : public quic_monitor {

    public:

    virtual void ivy_assert(bool truth,const char *msg){
        if (!truth) {
            __ivy_out << "assertion_failed(\"" << msg << "\")" << std::endl;
            std::cerr << msg << ": error: assertion failed\n";
            
            __ivy_exit(1);
        }
    }
    virtual void ivy_assume(bool truth,const char *msg){
        if (!truth) {
            __ivy_out << "assumption_failed(\"" << msg << "\")" << std::endl;
            std::cerr << msg << ": error: assumption failed\n";
            
            __ivy_exit(1);
        }
    }
    quic_monitor_repl(__strlit pc__name) : quic_monitor(pc__name){}
    virtual void imp__tls__event(const ip__endpoint& src, const ip__endpoint& dst, quic_monitor::tls__record rec){
    __ivy_out  << std::hex << std::showbase  << "< tls.event" << "(" << src << "," << dst << "," << rec << ")" << std::endl;
}
    virtual void imp__show_packet(const ip__endpoint& src, const ip__endpoint& dst, const quic_packet& pkt){
    __ivy_out  << std::hex << std::showbase  << "< show_packet" << "(" << src << "," << dst << "," << pkt << ")" << std::endl;
}

    };

// Override methods to implement low-level network service

bool is_white(int c) {
    return (c == ' ' || c == '\t' || c == '\n' || c == '\r');
}

bool is_ident(int c) {
    return c == '_' || c == '.' || (c >= 'A' &&  c <= 'Z')
        || (c >= 'a' &&  c <= 'z')
        || (c >= '0' &&  c <= '9');
}

void skip_white(const std::string& str, int &pos){
    while (pos < str.size() && is_white(str[pos]))
        pos++;
}

struct syntax_error {
    int pos;
    syntax_error(int pos) : pos(pos) {}
};

void throw_syntax(int pos){
    throw syntax_error(pos);
}

std::string get_ident(const std::string& str, int &pos) {
    std::string res = "";
    while (pos < str.size() && is_ident(str[pos])) {
        res.push_back(str[pos]);
        pos++;
    }
    if (res.size() == 0)
        throw_syntax(pos);
    return res;
}

ivy_value parse_value(const std::string& cmd, int &pos) {
    ivy_value res;
    res.pos = pos;
    skip_white(cmd,pos);
    if (pos < cmd.size() && cmd[pos] == '[') {
        while (true) {
            pos++;
            skip_white(cmd,pos);
            if (pos < cmd.size() && cmd[pos] == ']')
                break;
            res.fields.push_back(parse_value(cmd,pos));
            skip_white(cmd,pos);
            if (pos < cmd.size() && cmd[pos] == ']')
                break;
            if (!(pos < cmd.size() && cmd[pos] == ','))
                throw_syntax(pos);
        }
        pos++;
    }
    else if (pos < cmd.size() && cmd[pos] == '{') {
        while (true) {
            ivy_value field;
            pos++;
            skip_white(cmd,pos);
            field.atom = get_ident(cmd,pos);
            skip_white(cmd,pos);
            if (!(pos < cmd.size() && cmd[pos] == ':'))
                 throw_syntax(pos);
            pos++;
            skip_white(cmd,pos);
            field.fields.push_back(parse_value(cmd,pos));
            res.fields.push_back(field);
            skip_white(cmd,pos);
            if (pos < cmd.size() && cmd[pos] == '}')
                break;
            if (!(pos < cmd.size() && cmd[pos] == ','))
                throw_syntax(pos);
        }
        pos++;
    }
    else if (pos < cmd.size() && cmd[pos] == '"') {
        pos++;
        res.atom = "";
        while (pos < cmd.size() && cmd[pos] != '"')
            res.atom.push_back(cmd[pos++]);
        if(pos == cmd.size())
            throw_syntax(pos);
        pos++;
    }
    else 
        res.atom = get_ident(cmd,pos);
    return res;
}

void parse_command(const std::string &cmd, std::string &action, std::vector<ivy_value> &args) {
    int pos = 0;
    skip_white(cmd,pos);
    action = get_ident(cmd,pos);
    skip_white(cmd,pos);
    if (pos < cmd.size() && cmd[pos] == '(') {
        pos++;
        skip_white(cmd,pos);
        args.push_back(parse_value(cmd,pos));
        while(true) {
            skip_white(cmd,pos);
            if (!(pos < cmd.size() && cmd[pos] == ','))
                break;
            pos++;
            args.push_back(parse_value(cmd,pos));
        }
        if (!(pos < cmd.size() && cmd[pos] == ')'))
            throw_syntax(pos);
        pos++;
    }
    skip_white(cmd,pos);
    if (pos != cmd.size())
        throw_syntax(pos);
}

struct bad_arity {
    std::string action;
    int num;
    bad_arity(std::string &_action, unsigned _num) : action(_action), num(_num) {}
};

void check_arity(std::vector<ivy_value> &args, unsigned num, std::string &action) {
    if (args.size() != num)
        throw bad_arity(action,num);
}

template <>
quic_monitor::frame__ack _arg<quic_monitor::frame__ack>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    quic_monitor::frame__ack res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 3) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "largest_acked") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res.largest_acked = _arg<long long>(tmp_args,0,4611686018427387904);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field largest_acked: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "ack_delay") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res.ack_delay = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field ack_delay: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "ack_blocks") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res.ack_blocks = _arg<quic_monitor::frame__ack__block__arr>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field ack_blocks: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<quic_monitor::frame__ack>(ivy_deser &inp, quic_monitor::frame__ack &res){
    inp.open_struct();
    inp.open_field("largest_acked");
    __deser(inp,res.largest_acked);
    inp.close_field();
    inp.open_field("ack_delay");
    __deser(inp,res.ack_delay);
    inp.close_field();
    inp.open_field("ack_blocks");
    __deser(inp,res.ack_blocks);
    inp.close_field();
    inp.close_struct();
}
template <>
quic_monitor::frame__ack__block _arg<quic_monitor::frame__ack__block>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    quic_monitor::frame__ack__block res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "gap") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res.gap = _arg<long long>(tmp_args,0,4611686018427387904);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field gap: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "blocks") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res.blocks = _arg<long long>(tmp_args,0,4611686018427387904);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field blocks: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<quic_monitor::frame__ack__block>(ivy_deser &inp, quic_monitor::frame__ack__block &res){
    inp.open_struct();
    inp.open_field("gap");
    __deser(inp,res.gap);
    inp.close_field();
    inp.open_field("blocks");
    __deser(inp,res.blocks);
    inp.close_field();
    inp.close_struct();
}
template <>
quic_monitor::frame__stream _arg<quic_monitor::frame__stream>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    quic_monitor::frame__stream res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 7) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "off") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res.off = _arg<bool>(tmp_args,0,2);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field off: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "len") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res.len = _arg<bool>(tmp_args,0,2);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field len: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "fin") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res.fin = _arg<bool>(tmp_args,0,2);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field fin: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "id") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res.id = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field id: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "offset") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res.offset = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field offset: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "length") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res.length = _arg<int>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field length: " + err.txt,err.pos);
    }
    if (arg.fields[6].is_member()){
        tmp_args[0] = arg.fields[6].fields[0];
        if (arg.fields[6].atom != "data") throw out_of_bounds("unexpected field: " + arg.fields[6].atom,arg.fields[6].pos);
    }
    else{
        tmp_args[0] = arg.fields[6];
    }
    try{
        res.data = _arg<quic_monitor::stream_data>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field data: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<quic_monitor::frame__stream>(ivy_deser &inp, quic_monitor::frame__stream &res){
    inp.open_struct();
    inp.open_field("off");
    __deser(inp,res.off);
    inp.close_field();
    inp.open_field("len");
    __deser(inp,res.len);
    inp.close_field();
    inp.open_field("fin");
    __deser(inp,res.fin);
    inp.close_field();
    inp.open_field("id");
    __deser(inp,res.id);
    inp.close_field();
    inp.open_field("offset");
    __deser(inp,res.offset);
    inp.close_field();
    inp.open_field("length");
    __deser(inp,res.length);
    inp.close_field();
    inp.open_field("data");
    __deser(inp,res.data);
    inp.close_field();
    inp.close_struct();
}
template <>
quic_monitor::ip__endpoint _arg<quic_monitor::ip__endpoint>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    quic_monitor::ip__endpoint res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 3) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "protocol") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res.protocol = _arg<quic_monitor::ip__protocol>(tmp_args,0,2);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field protocol: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "addr") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res.addr = _arg<int>(tmp_args,0,4294967296);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field addr: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "port") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res.port = _arg<int>(tmp_args,0,65536);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field port: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<quic_monitor::ip__endpoint>(ivy_deser &inp, quic_monitor::ip__endpoint &res){
    inp.open_struct();
    inp.open_field("protocol");
    __deser(inp,res.protocol);
    inp.close_field();
    inp.open_field("addr");
    __deser(inp,res.addr);
    inp.close_field();
    inp.open_field("port");
    __deser(inp,res.port);
    inp.close_field();
    inp.close_struct();
}
template <>
quic_monitor::quic_packet _arg<quic_monitor::quic_packet>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    quic_monitor::quic_packet res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 6) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "hdr_long") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res.hdr_long = _arg<bool>(tmp_args,0,2);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field hdr_long: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "hdr_type") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res.hdr_type = _arg<int>(tmp_args,0,128);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field hdr_type: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "hdr_cid") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res.hdr_cid = _arg<long long>(tmp_args,0,4611686018427387904);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field hdr_cid: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "hdr_version") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res.hdr_version = _arg<int>(tmp_args,0,4294967296);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field hdr_version: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "hdr_pkt_num") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res.hdr_pkt_num = _arg<long long>(tmp_args,0,4611686018427387904);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field hdr_pkt_num: " + err.txt,err.pos);
    }
    if (arg.fields[5].is_member()){
        tmp_args[0] = arg.fields[5].fields[0];
        if (arg.fields[5].atom != "payload") throw out_of_bounds("unexpected field: " + arg.fields[5].atom,arg.fields[5].pos);
    }
    else{
        tmp_args[0] = arg.fields[5];
    }
    try{
        res.payload = _arg<quic_monitor::frame__arr>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field payload: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<quic_monitor::quic_packet>(ivy_deser &inp, quic_monitor::quic_packet &res){
    inp.open_struct();
    inp.open_field("hdr_long");
    __deser(inp,res.hdr_long);
    inp.close_field();
    inp.open_field("hdr_type");
    __deser(inp,res.hdr_type);
    inp.close_field();
    inp.open_field("hdr_cid");
    __deser(inp,res.hdr_cid);
    inp.close_field();
    inp.open_field("hdr_version");
    __deser(inp,res.hdr_version);
    inp.close_field();
    inp.open_field("hdr_pkt_num");
    __deser(inp,res.hdr_pkt_num);
    inp.close_field();
    inp.open_field("payload");
    __deser(inp,res.payload);
    inp.close_field();
    inp.close_struct();
}
template <>
quic_monitor::tls__client_hello _arg<quic_monitor::tls__client_hello>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    quic_monitor::tls__client_hello res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 5) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "client_version") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res.client_version = _arg<int>(tmp_args,0,65536);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field client_version: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "rand_info") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res.rand_info = _arg<quic_monitor::tls__random>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field rand_info: " + err.txt,err.pos);
    }
    if (arg.fields[2].is_member()){
        tmp_args[0] = arg.fields[2].fields[0];
        if (arg.fields[2].atom != "session_id") throw out_of_bounds("unexpected field: " + arg.fields[2].atom,arg.fields[2].pos);
    }
    else{
        tmp_args[0] = arg.fields[2];
    }
    try{
        res.session_id = _arg<quic_monitor::stream_data>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field session_id: " + err.txt,err.pos);
    }
    if (arg.fields[3].is_member()){
        tmp_args[0] = arg.fields[3].fields[0];
        if (arg.fields[3].atom != "cipher_suites") throw out_of_bounds("unexpected field: " + arg.fields[3].atom,arg.fields[3].pos);
    }
    else{
        tmp_args[0] = arg.fields[3];
    }
    try{
        res.cipher_suites = _arg<quic_monitor::tls__cipher_suite_seq>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field cipher_suites: " + err.txt,err.pos);
    }
    if (arg.fields[4].is_member()){
        tmp_args[0] = arg.fields[4].fields[0];
        if (arg.fields[4].atom != "extensions") throw out_of_bounds("unexpected field: " + arg.fields[4].atom,arg.fields[4].pos);
    }
    else{
        tmp_args[0] = arg.fields[4];
    }
    try{
        res.extensions = _arg<quic_monitor::vector__tls__extension__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field extensions: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<quic_monitor::tls__client_hello>(ivy_deser &inp, quic_monitor::tls__client_hello &res){
    inp.open_struct();
    inp.open_field("client_version");
    __deser(inp,res.client_version);
    inp.close_field();
    inp.open_field("rand_info");
    __deser(inp,res.rand_info);
    inp.close_field();
    inp.open_field("session_id");
    __deser(inp,res.session_id);
    inp.close_field();
    inp.open_field("cipher_suites");
    __deser(inp,res.cipher_suites);
    inp.close_field();
    inp.open_field("extensions");
    __deser(inp,res.extensions);
    inp.close_field();
    inp.close_struct();
}
template <>
quic_monitor::tls__extension _arg<quic_monitor::tls__extension>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    quic_monitor::tls__extension res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "etype") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res.etype = _arg<int>(tmp_args,0,65536);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field etype: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "content") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res.content = _arg<quic_monitor::stream_data>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field content: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<quic_monitor::tls__extension>(ivy_deser &inp, quic_monitor::tls__extension &res){
    inp.open_struct();
    inp.open_field("etype");
    __deser(inp,res.etype);
    inp.close_field();
    inp.open_field("content");
    __deser(inp,res.content);
    inp.close_field();
    inp.close_struct();
}
template <>
quic_monitor::tls__handshake_record _arg<quic_monitor::tls__handshake_record>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    quic_monitor::tls__handshake_record res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "version") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res.version = _arg<int>(tmp_args,0,65536);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field version: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "fragment") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res.fragment = _arg<quic_monitor::vector__tls__handshake__>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field fragment: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<quic_monitor::tls__handshake_record>(ivy_deser &inp, quic_monitor::tls__handshake_record &res){
    inp.open_struct();
    inp.open_field("version");
    __deser(inp,res.version);
    inp.close_field();
    inp.open_field("fragment");
    __deser(inp,res.fragment);
    inp.close_field();
    inp.close_struct();
}
template <>
quic_monitor::tls__random _arg<quic_monitor::tls__random>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    quic_monitor::tls__random res;
    ivy_value &arg = args[idx];
    if (arg.atom.size() || arg.fields.size() != 2) throw out_of_bounds("wrong number of fields",args[idx].pos);
    std::vector<ivy_value> tmp_args(1);
    if (arg.fields[0].is_member()){
        tmp_args[0] = arg.fields[0].fields[0];
        if (arg.fields[0].atom != "gmt_unix_time") throw out_of_bounds("unexpected field: " + arg.fields[0].atom,arg.fields[0].pos);
    }
    else{
        tmp_args[0] = arg.fields[0];
    }
    try{
        res.gmt_unix_time = _arg<int>(tmp_args,0,4294967296);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field gmt_unix_time: " + err.txt,err.pos);
    }
    if (arg.fields[1].is_member()){
        tmp_args[0] = arg.fields[1].fields[0];
        if (arg.fields[1].atom != "random_bytes") throw out_of_bounds("unexpected field: " + arg.fields[1].atom,arg.fields[1].pos);
    }
    else{
        tmp_args[0] = arg.fields[1];
    }
    try{
        res.random_bytes = _arg<quic_monitor::stream_data>(tmp_args,0,0);
;
    }
    catch(const out_of_bounds &err){
        throw out_of_bounds("in field random_bytes: " + err.txt,err.pos);
    }
    return res;
}
template <>
void __deser<quic_monitor::tls__random>(ivy_deser &inp, quic_monitor::tls__random &res){
    inp.open_struct();
    inp.open_field("gmt_unix_time");
    __deser(inp,res.gmt_unix_time);
    inp.close_field();
    inp.open_field("random_bytes");
    __deser(inp,res.random_bytes);
    inp.close_field();
    inp.close_struct();
}
template <>
quic_monitor::ip__protocol _arg<quic_monitor::ip__protocol>(std::vector<ivy_value> &args, unsigned idx, long long bound){
    ivy_value &arg = args[idx];
    if (arg.atom.size() == 0 || arg.fields.size() != 0) throw out_of_bounds(idx,arg.pos);
    if(arg.atom == "udp") return quic_monitor::ip__udp;
    if(arg.atom == "tcp") return quic_monitor::ip__tcp;
    throw out_of_bounds("bad value: " + arg.atom,arg.pos);
}
template <>
void __deser<quic_monitor::ip__protocol>(ivy_deser &inp, quic_monitor::ip__protocol &res){
    int __res;
    __deser(inp,__res);
    res = (quic_monitor::ip__protocol)__res;
}


class stdin_reader: public reader {
    std::string buf;
    std::string eof_flag;

public:
    bool eof(){
      return eof_flag.size();
    }
    virtual int fdes(){
        return 0;
    }
    virtual void read() {
        char tmp[257];
        int chars = ::read(0,tmp,256);
        if (chars == 0) {  // EOF
            if (buf.size())
                process(buf);
            eof_flag = "eof";
        }
        tmp[chars] = 0;
        buf += std::string(tmp);
        size_t pos;
        while ((pos = buf.find('\n')) != std::string::npos) {
            std::string line = buf.substr(0,pos+1);
            buf.erase(0,pos+1);
            process(line);
        }
    }
    virtual void process(const std::string &line) {
        __ivy_out << line;
    }
};

class cmd_reader: public stdin_reader {
    int lineno;
public:
    quic_monitor_repl &ivy;    

    cmd_reader(quic_monitor_repl &_ivy) : ivy(_ivy) {
        lineno = 1;
        if (isatty(fdes()))
            __ivy_out << "> "; __ivy_out.flush();
    }

    virtual void process(const std::string &cmd) {
        std::string action;
        std::vector<ivy_value> args;
        try {
            parse_command(cmd,action,args);
            ivy.__lock();

            {
                std::cerr << "undefined action: " << action << std::endl;
            }
            ivy.__unlock();
        }
        catch (syntax_error& err) {
            std::cerr << "line " << lineno << ":" << err.pos << ": syntax error" << std::endl;
        }
        catch (out_of_bounds &err) {
            std::cerr << "line " << lineno << ":" << err.pos << ": " << err.txt << " bad value" << std::endl;
        }
        catch (bad_arity &err) {
            std::cerr << "action " << err.action << " takes " << err.num  << " input parameters" << std::endl;
        }
        if (isatty(fdes()))
            __ivy_out << "> "; __ivy_out.flush();
        lineno++;
    }
};



int main(int argc, char **argv){
        int test_iters = 100;

    int runs = 1;
    int seed = 1;
    int sleep_ms = 10;
    int final_ms = 0; 
    std::vector<char *> pargs; // positional args
    pargs.push_back(argv[0]);
    for (int i = 1; i < argc; i++) {
        std::string arg = argv[i];
        size_t p = arg.find('=');
        if (p == std::string::npos)
            pargs.push_back(argv[i]);
        else {
            std::string param = arg.substr(0,p);
            std::string value = arg.substr(p+1);
            if (param == "out") {
                __ivy_out.open(value.c_str());
                if (!__ivy_out) {
                    std::cerr << "cannot open to write: " << value << std::endl;
                    return 1;
                }
            }
            else if (param == "iters") {
                test_iters = atoi(value.c_str());
            }
            else if (param == "runs") {
                runs = atoi(value.c_str());
            }
            else if (param == "seed") {
                seed = atoi(value.c_str());
            }
            else if (param == "delay") {
                sleep_ms = atoi(value.c_str());
            }
            else if (param == "wait") {
                final_ms = atoi(value.c_str());
            }
            else if (param == "modelfile") {
                __ivy_modelfile.open(value.c_str());
                if (!__ivy_modelfile) {
                    std::cerr << "cannot open to write: " << value << std::endl;
                    return 1;
                }
            }
            else {
                std::cerr << "unknown option: " << param << std::endl;
                return 1;
            }
        }
    }
    srand(seed);
    if (!__ivy_out.is_open())
        __ivy_out.basic_ios<char>::rdbuf(std::cout.rdbuf());
    argc = pargs.size();
    argv = &pargs[0];
    if (argc == 3){
        argc--;
        int fd = _open(argv[argc],0);
        if (fd < 0){
            std::cerr << "cannot open to read: " << argv[argc] << "\n";
            __ivy_exit(1);
        }
        _dup2(fd, 0);
    }
    if (argc != 2){
        std::cerr << "usage: quic_monitor pc__name\n";
        __ivy_exit(1);
    }
    std::vector<std::string> args;
    std::vector<ivy_value> arg_values(1);
    for(int i = 1; i < argc;i++){args.push_back(argv[i]);}
    __strlit p__pc__name;
    try {
        int pos = 0;
        arg_values[0] = parse_value(args[0],pos);
        p__pc__name =  _arg<__strlit>(arg_values,0,0);
    }
    catch(out_of_bounds &) {
        std::cerr << "parameter pc__name out of bounds\n";
        __ivy_exit(1);
    }
    catch(syntax_error &) {
        std::cerr << "syntax error in command argument\n";
        __ivy_exit(1);
    }

#ifdef _WIN32
    // Boilerplate from windows docs

    {
        WORD wVersionRequested;
        WSADATA wsaData;
        int err;

    /* Use the MAKEWORD(lowbyte, highbyte) macro declared in Windef.h */
        wVersionRequested = MAKEWORD(2, 2);

        err = WSAStartup(wVersionRequested, &wsaData);
        if (err != 0) {
            /* Tell the user that we could not find a usable */
            /* Winsock DLL.                                  */
            printf("WSAStartup failed with error: %d\n", err);
            return 1;
        }

    /* Confirm that the WinSock DLL supports 2.2.*/
    /* Note that if the DLL supports versions greater    */
    /* than 2.2 in addition to 2.2, it will still return */
    /* 2.2 in wVersion since that is the version we      */
    /* requested.                                        */

        if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2) {
            /* Tell the user that we could not find a usable */
            /* WinSock DLL.                                  */
            printf("Could not find a usable version of Winsock.dll\n");
            WSACleanup();
            return 1;
        }
    }
#endif
    quic_monitor_repl ivy(p__pc__name);


    
    ivy.__unlock();

    // The main thread waits for all reader threads to die

    for(unsigned i = 0; true ; i++) {
        ivy.__lock();
        if (i >= ivy.thread_ids.size()){
            ivy.__unlock();
            break;
        }
        pthread_t tid = ivy.thread_ids[i];
        ivy.__unlock();
        pthread_join(tid,NULL);
    }
    return 0;

    return 0;
}
